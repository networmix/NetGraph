
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://networmix.github.io/NetGraph/reference/design/">
      
      
        <link rel="prev" href="../../examples/clos-fabric/">
      
      
        <link rel="next" href="../dsl/">
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Design - NetGraph</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#netgraph-design-and-implementation" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="NetGraph" class="md-header__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            NetGraph
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Design
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../getting-started/installation/" class="md-tabs__link">
          
  
  
  Getting Started

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../examples/bundled-scenarios/" class="md-tabs__link">
          
  
  
  Examples

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="./" class="md-tabs__link">
          
  
  
  Reference

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="NetGraph" class="md-nav__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    NetGraph
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Getting Started
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Getting Started
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Installation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/tutorial/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Quickstart
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Examples
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Examples
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/bundled-scenarios/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bundled Scenarios
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Basic Example
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/clos-fabric/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Clos Fabric
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    Reference
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Reference
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Design
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Design
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Overview
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#architecture-layers" class="md-nav__link">
    <span class="md-ellipsis">
      
        Architecture Layers
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#package-structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Package Structure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integration-points" class="md-nav__link">
    <span class="md-ellipsis">
      
        Integration Points
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#execution-flow" class="md-nav__link">
    <span class="md-ellipsis">
      
        Execution Flow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scenario-dsl-and-input-expansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Scenario DSL and Input Expansion
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Scenario DSL and Input Expansion">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dsl-expansion-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        DSL Expansion Process
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-model" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Model
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Data Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      
        Link
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        RiskGroup
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node-and-link-selection" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node and Link Selection
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disabled-elements" class="md-nav__link">
    <span class="md-ellipsis">
      
        Disabled Elements
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#filtered-analysis-exclusions" class="md-nav__link">
    <span class="md-ellipsis">
      
        Filtered Analysis (Exclusions)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph-construction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Graph Construction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analysis-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      
        Analysis Algorithms
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest-path-first-spf-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Shortest-Path First (SPF) Algorithm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pseudocode-simplified-see-implementation-for-complete-details" class="md-nav__link">
    <span class="md-ellipsis">
      
        Pseudocode (simplified, see implementation for complete details)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maximum-flow-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Maximum Flow Algorithm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#routing-semantics-ipigp-vs-sdnte" class="md-nav__link">
    <span class="md-ellipsis">
      
        Routing Semantics: IP/IGP vs SDN/TE
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flow-placement-strategies" class="md-nav__link">
    <span class="md-ellipsis">
      
        Flow Placement Strategies
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flow-policy-presets" class="md-nav__link">
    <span class="md-ellipsis">
      
        Flow Policy Presets
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pseudocode-simplified-max-flow-loop" class="md-nav__link">
    <span class="md-ellipsis">
      
        Pseudocode (simplified max-flow loop)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#managers-and-workflow-orchestration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Managers and Workflow Orchestration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflow-engine-and-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Workflow Engine and Steps
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results-storage" class="md-nav__link">
    <span class="md-ellipsis">
      
        Results storage
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-elements-and-comparisons" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Elements and Comparisons
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performance-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Performance Considerations
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cross-references" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cross-references
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dsl/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    DSL
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../workflow/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Workflow
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    CLI
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schemas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Schemas
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    API
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../api-full/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    API Full
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Overview
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#architecture-layers" class="md-nav__link">
    <span class="md-ellipsis">
      
        Architecture Layers
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#package-structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Package Structure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integration-points" class="md-nav__link">
    <span class="md-ellipsis">
      
        Integration Points
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#execution-flow" class="md-nav__link">
    <span class="md-ellipsis">
      
        Execution Flow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scenario-dsl-and-input-expansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Scenario DSL and Input Expansion
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Scenario DSL and Input Expansion">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dsl-expansion-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        DSL Expansion Process
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-model" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Model
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Data Model">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      
        Link
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        RiskGroup
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node-and-link-selection" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node and Link Selection
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disabled-elements" class="md-nav__link">
    <span class="md-ellipsis">
      
        Disabled Elements
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#filtered-analysis-exclusions" class="md-nav__link">
    <span class="md-ellipsis">
      
        Filtered Analysis (Exclusions)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph-construction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Graph Construction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analysis-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      
        Analysis Algorithms
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest-path-first-spf-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Shortest-Path First (SPF) Algorithm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pseudocode-simplified-see-implementation-for-complete-details" class="md-nav__link">
    <span class="md-ellipsis">
      
        Pseudocode (simplified, see implementation for complete details)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maximum-flow-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Maximum Flow Algorithm
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#routing-semantics-ipigp-vs-sdnte" class="md-nav__link">
    <span class="md-ellipsis">
      
        Routing Semantics: IP/IGP vs SDN/TE
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flow-placement-strategies" class="md-nav__link">
    <span class="md-ellipsis">
      
        Flow Placement Strategies
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flow-policy-presets" class="md-nav__link">
    <span class="md-ellipsis">
      
        Flow Policy Presets
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pseudocode-simplified-max-flow-loop" class="md-nav__link">
    <span class="md-ellipsis">
      
        Pseudocode (simplified max-flow loop)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#managers-and-workflow-orchestration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Managers and Workflow Orchestration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflow-engine-and-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Workflow Engine and Steps
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results-storage" class="md-nav__link">
    <span class="md-ellipsis">
      
        Results storage
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-elements-and-comparisons" class="md-nav__link">
    <span class="md-ellipsis">
      
        Design Elements and Comparisons
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performance-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      
        Performance Considerations
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cross-references" class="md-nav__link">
    <span class="md-ellipsis">
      
        Cross-references
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="netgraph-design-and-implementation">NetGraph Design and Implementation<a class="headerlink" href="#netgraph-design-and-implementation" title="Permanent link">&para;</a></h1>
<p>This document describes NetGraph's internal design: scenario DSL, data models, execution flow, algorithms, manager components, and result handling. It focuses on architecture and key implementation details.</p>
<h2 id="overview">Overview<a class="headerlink" href="#overview" title="Permanent link">&para;</a></h2>
<p>NetGraph is a network scenario analysis engine using a <strong>hybrid Python+C++ architecture</strong>. It takes a scenario (defined in a YAML DSL) as input, builds a directed multigraph model of the network, and runs a configurable workflow of analysis steps (like traffic placement or max-flow capacity) to produce structured results.</p>
<h3 id="architecture-layers">Architecture Layers<a class="headerlink" href="#architecture-layers" title="Permanent link">&para;</a></h3>
<p><strong>Python Layer (NetGraph):</strong></p>
<ul>
<li>CLI and API: Entry points to load scenarios and invoke analyses</li>
<li>Scenario DSL Parser: Validates and expands the YAML scenario into an internal model</li>
<li>Domain Model: In-memory representation of nodes, links, risk groups, etc., with selection and grouping utilities</li>
<li>Managers: Orchestrators for higher-level behaviors (demand expansion, failure enumeration)</li>
<li>Workflow Engine: Composes steps into end-to-end analyses, storing outputs in a results store</li>
<li>Results Store: Collects outputs and metadata from each step, enabling structured JSON export</li>
<li>Analysis bridge: <code>AnalysisContext</code> builds Core graphs from the model, manages name/ID mapping, and executes Core algorithms</li>
<li>NetworkExplorer: Network hierarchy traversal and hardware cost/power aggregation</li>
</ul>
<p><strong>C++ Layer (NetGraph-Core):</strong></p>
<ul>
<li>StrictMultiDiGraph: Immutable directed multigraph with CSR adjacency representation</li>
<li>Shortest Paths (SPF): Dijkstra's algorithm with multipath support and configurable edge selection</li>
<li>K-Shortest Paths: Yen's algorithm for finding k-shortest simple paths</li>
<li>Max-Flow: Successive shortest paths with blocking flow augmentation and configurable flow placement policies</li>
<li>Backend Interface: Abstraction for algorithm execution (CPU backend provided)</li>
</ul>
<h3 id="package-structure">Package Structure<a class="headerlink" href="#package-structure" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>ngraph/
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>├── analysis/       # AnalysisContext, FailureManager, placement
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>├── model/          # Network, Node, Link, demand/, failure/, flow/
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>├── dsl/            # YAML parsing (blueprints/, selectors/, expansion/)
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>├── workflow/       # WorkflowStep implementations
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>├── results/        # Results store and flow result types
</span><span id="__span-0-7"><a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>├── schemas/        # JSON Schema for scenario validation
</span><span id="__span-0-8"><a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>├── types/          # Enums, DTOs, type aliases
</span><span id="__span-0-9"><a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>├── profiling/      # Performance profiling
</span><span id="__span-0-10"><a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a>├── lib/            # NetworkX integration
</span><span id="__span-0-11"><a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a>├── utils/          # Utilities (ids, yaml, seeds)
</span><span id="__span-0-12"><a id="__codelineno-0-12" name="__codelineno-0-12" href="#__codelineno-0-12"></a>├── scenario.py     # Scenario orchestrator
</span><span id="__span-0-13"><a id="__codelineno-0-13" name="__codelineno-0-13" href="#__codelineno-0-13"></a>├── explorer.py     # NetworkExplorer
</span><span id="__span-0-14"><a id="__codelineno-0-14" name="__codelineno-0-14" href="#__codelineno-0-14"></a>└── cli.py          # Command-line interface
</span></code></pre></div>
<h3 id="integration-points">Integration Points<a class="headerlink" href="#integration-points" title="Permanent link">&para;</a></h3>
<p>The Python layer uses the <code>analyze()</code> function and <code>AnalysisContext</code> class (<code>ngraph.analysis</code>) to:</p>
<ol>
<li>Build Core graphs from Network instances with optional pseudo-nodes for source/sink groups</li>
<li>Map node names (str) to NodeId (int32) and link IDs (str) to EdgeId/ext_edge_id (int64)</li>
<li>Execute analysis methods (max_flow, shortest_paths, sensitivity) with efficient masking</li>
<li>Translate results (costs, flows, paths) back to scenario-level objects</li>
</ol>
<p>Core algorithms release the GIL during execution, enabling concurrent Python threads to execute analysis in parallel with minimal Python-level overhead.</p>
<p><strong>Primary API:</strong></p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="kn">from</span><span class="w"> </span><span class="nn">ngraph</span><span class="w"> </span><span class="kn">import</span> <span class="n">analyze</span><span class="p">,</span> <span class="n">Mode</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="c1"># One-off analysis (unbound context)</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="n">flow</span> <span class="o">=</span> <span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">)</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="s2">&quot;^src$&quot;</span><span class="p">,</span> <span class="s2">&quot;^dst$&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Mode</span><span class="o">.</span><span class="n">COMBINE</span><span class="p">)</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="c1"># Efficient repeated analysis (bound context)</span>
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="n">ctx</span> <span class="o">=</span> <span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s2">&quot;^src$&quot;</span><span class="p">,</span> <span class="n">sink</span><span class="o">=</span><span class="s2">&quot;^dst$&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Mode</span><span class="o">.</span><span class="n">COMBINE</span><span class="p">)</span>
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a><span class="n">baseline</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">max_flow</span><span class="p">()</span>
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="n">degraded</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="n">excluded_links</span><span class="o">=</span><span class="n">failed_links</span><span class="p">)</span>
</span></code></pre></div>
<p>The <code>AnalysisContext</code> encapsulates all graph building and provides properties for advanced use by workflow steps and the FailureManager.</p>
<h3 id="execution-flow">Execution Flow<a class="headerlink" href="#execution-flow" title="Permanent link">&para;</a></h3>
<p>The diagram below shows the architecture and end-to-end execution flow from scenario input through both Python and C++ layers to final results. The Python layer handles scenario loading, workflow orchestration, and result aggregation, while compute-intensive graph algorithms execute in C++ with the GIL released for parallel execution.</p>
<p><img alt="NetGraph execution flow" src="../../assets/diagrams/system_pipeline.dot.svg" /></p>
<h2 id="scenario-dsl-and-input-expansion">Scenario DSL and Input Expansion<a class="headerlink" href="#scenario-dsl-and-input-expansion" title="Permanent link">&para;</a></h2>
<p>NetGraph scenarios are defined in YAML using a declarative DSL (see <a href="../dsl/">DSL Reference</a>). The DSL allows concise specification of network topologies, traffic demands, failure policies, and analysis workflows. Before execution, scenario files are validated against a JSON Schema to catch errors early (unknown keys, type mismatches), enforcing strict definitions.</p>
<p>Key elements of the DSL include:</p>
<ul>
<li>
<p><strong>Seed</strong>: A master random seed for the scenario to ensure deterministic behavior across runs.</p>
</li>
<li>
<p><strong>Blueprints</strong>: Reusable templates for subsets of the topology. A blueprint defines internal node types, roles, and optional internal links. Blueprints enable defining a complex multi-node topology once and instantiating it multiple times with different parameters.</p>
</li>
<li>
<p><strong>Node Groups</strong>: Definitions of node groups in the topology, either explicitly or via patterns. Groups can use a blueprint (<code>blueprint</code>) with parameters (<code>params</code>), or define a number of nodes (<code>count</code>) with a naming template (<code>template</code>).</p>
</li>
<li>
<p><strong>Links</strong>: Rules to generate links between node groups. Instead of enumerating every link, a link rule specifies source and target selectors (by path pattern), a wiring pattern (e.g. mesh for full mesh or one_to_one for paired links), number of parallel links (<code>count</code>), and link properties (capacity, cost, attributes like distance, hardware, risk group tags, etc.). Link properties are specified at the top level, not inside a wrapper. Advanced matching allows filtering nodes by attributes with logical conditions (AND/OR) to apply link rules to selected nodes only. A single rule can thus expand into many concrete links.</p>
</li>
<li>
<p><strong>Rules</strong>: Optional modifications applied after the initial expansion. <code>node_rules</code> or <code>link_rules</code> can match specific nodes or links (by path or endpoints) and change their attributes or disable them. This allows fine-tuning or simulating removals without changing the base definitions.</p>
</li>
<li>
<p><strong>Risk Groups</strong>: Named shared-risk groups (potentially nested) that nodes or links can belong to. These are used in failure scenarios to correlate failures (e.g. all links in a risk group fail together).</p>
</li>
<li>
<p><strong>Demands</strong>: Traffic demand definitions specifying source node sets, target node sets (by regex or attribute path selectors), and volume. Each demand can also include priority or custom flow placement policy.</p>
</li>
<li>
<p><strong>Failure Policies</strong>: Definitions of failure scenarios or modes, possibly with weights (probabilities). For example, a policy might say "with 5% chance, fail any single core node" or "fail all links in risk_group X". The failure manager uses these policies to generate specific failure combinations for simulation.</p>
</li>
<li>
<p><strong>Workflow</strong>: An ordered list of analysis steps to execute. Each step has a <code>type</code> (the analysis to perform, such as "MaxFlow" or "TrafficMatrixPlacement"), a unique name, and parameters (like number of iterations, etc.). The workflow definition orchestrates the analysis pipeline.</p>
</li>
</ul>
<h3 id="dsl-expansion-process">DSL Expansion Process<a class="headerlink" href="#dsl-expansion-process" title="Permanent link">&para;</a></h3>
<p>The loader validates and expands DSL definitions into concrete nodes and links. Unknown fields or schema violations cause an immediate error before any expansion. After schema validation, blueprints are resolved (each blueprint group becomes actual Node objects), group name patterns are expanded into individual names, and adjacency rules are iterated over matching source-target node sets to create Link objects. All nodes and links are then validated in runtime to ensure they are valid (e.g., no duplicate node names, all link endpoints exist).</p>
<h2 id="data-model">Data Model<a class="headerlink" href="#data-model" title="Permanent link">&para;</a></h2>
<p>Once the scenario is parsed and expanded, NetGraph represents the network with a set of core model classes. These define the in-memory representation of the scenario topology and enforce structural invariants (unique node names, valid link endpoints).</p>
<h3 id="node">Node<a class="headerlink" href="#node" title="Permanent link">&para;</a></h3>
<p>A Node represents a network node (vertex). Each node has:</p>
<ul>
<li>
<p>a unique name (string identifier),</p>
</li>
<li>
<p>a disabled flag (if the node is turned off in the scenario),</p>
</li>
<li>
<p>a set of risk_groups (associating the node with any failure domains), and</p>
</li>
<li>
<p>an attrs dictionary for arbitrary metadata (e.g., region, device type, hardware info)</p>
</li>
</ul>
<h3 id="link">Link<a class="headerlink" href="#link" title="Permanent link">&para;</a></h3>
<p>A Link represents a directed link between a source and target node. Each link has:</p>
<ul>
<li>
<p>source and target node names,</p>
</li>
<li>
<p>capacity (float, e.g. in some bandwidth unit),</p>
</li>
<li>
<p>cost (float, e.g. distance or latency metric),</p>
</li>
<li>
<p>disabled flag,</p>
</li>
<li>
<p>risk_groups set,</p>
</li>
<li>
<p>attrs dict for metadata (e.g. distance_km, fiber type), and</p>
</li>
<li>
<p>an auto-generated unique id</p>
</li>
</ul>
<p>The id is constructed as "source|target|<random_base64>", ensuring each link has a distinct identifier. The model stores each link as directed (source -&gt; target). When the analysis graph is built, a reverse edge is added by default so algorithms see bidirectional connectivity.</p>
<h3 id="riskgroup">RiskGroup<a class="headerlink" href="#riskgroup" title="Permanent link">&para;</a></h3>
<p>A RiskGroup represents a named failure domain or shared-risk link group (SRLG). Risk groups can be hierarchical (a risk group may have children risk groups). Each RiskGroup has:</p>
<ul>
<li>
<p>a name,</p>
</li>
<li>
<p>list of children RiskGroups (which inherit the failure domain property),</p>
</li>
<li>
<p>disabled flag (if the entire group is considered initially failed in the scenario), and</p>
</li>
<li>
<p>an attrs dict for any metadata</p>
</li>
</ul>
<p>Hierarchical risk groups allow, for example, defining a large domain composed of smaller sub-domains. A failure event could disable an entire group, implicitly affecting all its descendants.</p>
<h3 id="network">Network<a class="headerlink" href="#network" title="Permanent link">&para;</a></h3>
<p>A Network is the container class that holds all nodes, links, and top-level risk groups for the scenario. The Network class maintains:</p>
<ul>
<li>
<p>nodes: Dict[name, Node],</p>
</li>
<li>
<p>links: Dict[id, Link],</p>
</li>
<li>
<p>risk_groups: Dict[name, RiskGroup],</p>
</li>
</ul>
<p>Network is the container for scenario topology. It enforces invariants during construction: adding a link validates that source and target nodes exist; adding a node rejects duplicates by name. Components are never removed from the Network; the <code>disabled</code> flag marks them inactive. The Network also maintains a selection cache for <code>select_node_groups_by_path</code> to avoid repeated regex/attribute queries.</p>
<h3 id="node-and-link-selection">Node and Link Selection<a class="headerlink" href="#node-and-link-selection" title="Permanent link">&para;</a></h3>
<p>The model supports selecting groups of nodes via a unified selector system used by algorithms to choose source/sink sets matching on structured names or attributes.</p>
<p><strong>Selector Forms:</strong></p>
<p>Selectors can be specified as:</p>
<ol>
<li><strong>String pattern</strong>: A regex matched against node names (anchored at start via <code>re.match()</code>)</li>
<li><strong>Selector object</strong>: A dict with <code>path</code>, <code>group_by</code>, and/or <code>match</code> fields</li>
</ol>
<p><strong>String Pattern Behavior:</strong></p>
<p>When using a regex pattern, if the regex contains capturing groups, the concatenated capture groups form the group label; otherwise, the entire pattern string is used as the label. For instance, the pattern <code>r"(\w+)-(\d+)"</code> on node names could produce group labels like "metroA-1" etc.</p>
<p><strong>Attribute-based Grouping:</strong></p>
<p>Use <code>group_by</code> in a selector object to group nodes by an attribute value:</p>
<div class="language-yaml highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="nt">source</span><span class="p">:</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">  </span><span class="nt">group_by</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;role&quot;</span>
</span></code></pre></div>
<p>This groups nodes by the value of <code>node.attrs["role"]</code> (e.g., "core", "leaf"), returning a dict mapping each distinct value to the list of nodes with that value. Nodes missing the attribute are excluded.</p>
<p><strong>Attribute-based Filtering:</strong></p>
<p>Use <code>match</code> in a selector object to filter nodes by attribute conditions:</p>
<div class="language-yaml highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="nt">source</span><span class="p">:</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="w">  </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;^dc1/.*&quot;</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="w">  </span><span class="nt">match</span><span class="p">:</span>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">    </span><span class="nt">conditions</span><span class="p">:</span>
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">attr</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;tier&quot;</span>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="w">        </span><span class="nt">op</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;==&quot;</span>
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="w">        </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;leaf&quot;</span>
</span></code></pre></div>
<p>This selection mechanism allows workflow steps and API calls to refer to nodes flexibly (using human-readable patterns instead of explicit lists), which is particularly useful in large topologies.</p>
<h3 id="disabled-elements">Disabled Elements<a class="headerlink" href="#disabled-elements" title="Permanent link">&para;</a></h3>
<p>Nodes or links marked as disabled=True represent elements present in the design but out of service for the analysis. The base model keeps them in the collection but analysis functions filter them out when selecting active nodes. This design preserves topology information (e.g., you know a link exists but is just turned off) and allows easily enabling it later if needed.</p>
<h3 id="filtered-analysis-exclusions">Filtered Analysis (Exclusions)<a class="headerlink" href="#filtered-analysis-exclusions" title="Permanent link">&para;</a></h3>
<p>To simulate failures or other what-if scenarios without modifying the base network, NetGraph uses analysis-time exclusions. Instead of creating a stateful view object, you pass sets of excluded nodes and links directly to analysis functions.</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="c1"># Analyze with specific exclusions</span>
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="n">results</span> <span class="o">=</span> <span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">)</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span>
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>    <span class="s2">&quot;^A$&quot;</span><span class="p">,</span>
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>    <span class="s2">&quot;^B$&quot;</span><span class="p">,</span>
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>    <span class="n">excluded_nodes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Node5&quot;</span><span class="p">},</span>
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>    <span class="n">excluded_links</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A|B|xyz123&quot;</span><span class="p">}</span>
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="p">)</span>
</span></code></pre></div>
<p>This approach avoids mutating the base graph when simulating failures (e.g., deleting nodes or toggling flags). It separates the static scenario (base network) from dynamic conditions (exclusions), enabling thread-safe parallel analyses and eliminating deep copies for each failure scenario.</p>
<p><strong>Implementation:</strong> For repeated analysis (Monte Carlo, FailureManager), exclusions are applied via boolean masks passed to Core algorithms. The graph is built once without exclusions, and masks disable specific elements at algorithm execution time. This enables O(|excluded|) mask updates rather than O(V+E) graph rebuilding. For one-off solver calls, exclusions may be applied during graph construction for simplicity.</p>
<p>Multiple concurrent analyses can run on the same base network with different exclusion sets. This is important for performing parallel simulations (e.g., analyzing many failure combinations in a Monte Carlo) efficiently.</p>
<h3 id="graph-construction">Graph Construction<a class="headerlink" href="#graph-construction" title="Permanent link">&para;</a></h3>
<p>NetGraph builds graphs through <code>AnalysisContext</code> which translates from the Python domain model to NetGraph-Core's C++ representation.</p>
<p><strong>Python Side (<code>ngraph.analysis.AnalysisContext</code>):</strong></p>
<p>A single construction method is provided:</p>
<ul>
<li><code>AnalysisContext.from_network()</code>: Constructs an immutable context with pre-built Core graph, mappers, algorithms instance, and pre-computed disabled topology. Exclusions are applied at algorithm call time via boolean masks rather than during graph construction.</li>
</ul>
<p><strong>Graph Construction Steps:</strong></p>
<ul>
<li>Collects nodes from Network (real + optional pseudo nodes for augmentation)</li>
<li>Assigns stable node IDs (sorted by name for determinism)</li>
<li>Encodes link_id + direction as ext_edge_id (packed int64)</li>
<li>Constructs NumPy arrays (src, dst, capacity, cost, ext_edge_ids)</li>
<li>Supports augmentation edges (e.g., pseudo-source/sink for multi-source max-flow)</li>
</ul>
<p><strong>AnalysisContext Internals:</strong></p>
<p><code>AnalysisContext</code> encapsulates pre-built graph components as internal attributes:</p>
<ul>
<li><code>_handle</code>, <code>_multidigraph</code>: Core graph structures</li>
<li><code>_node_mapper</code>, <code>_edge_mapper</code>: Name ↔ ID translation</li>
<li><code>_algorithms</code>: Core Algorithms instance</li>
<li><code>_disabled_node_ids</code>, <code>_disabled_link_ids</code>: Pre-computed disabled topology</li>
<li><code>_link_id_to_edge_indices</code>: Pre-computed mapping for O(|excluded|) mask building</li>
<li><code>_pseudo_context</code>: Optional context for pseudo source/sink node mappings</li>
</ul>
<p>When analyzing many failure scenarios, the graph is built once via <code>AnalysisContext.from_network()</code> and exclusions are applied via boolean masks. The mask builders automatically include disabled nodes/links, ensuring disabled topology is always excluded. This avoids rebuilding the graph for each iteration, providing significant speedup for Monte Carlo simulations.</p>
<p><strong>Disabled Topology Handling:</strong></p>
<p>Disabled nodes and links from the Network are pre-computed during <code>AnalysisContext.from_network()</code> and stored in the context. The mask builders automatically include these disabled elements alongside any per-iteration exclusions.</p>
<p><strong>C++ Side (<code>netgraph_core.StrictMultiDiGraph</code>):</strong></p>
<ul>
<li>Immutable directed multigraph using Compressed Sparse Row (CSR) adjacency</li>
<li>Nodes identified by NodeId (int32), edges by EdgeId (int32)</li>
<li>Each edge stores capacity (float64), cost (int64), and ext_edge_id (int64)</li>
<li>Edges sorted by (cost, src, dst) for deterministic algorithm behavior</li>
<li>Zero-copy NumPy views for array access (capacities, costs, ext_edge_ids)</li>
<li>Efficient neighbor iteration via CSR structure</li>
</ul>
<p><strong>Edge Direction Handling:</strong></p>
<p>If <code>add_reverse=True</code> (default), graph construction creates bidirectional edges for each network link:</p>
<ul>
<li>Forward edge: original link direction with ext_edge_id encoding (link_id, 'fwd')</li>
<li>Reverse edge: opposite direction with ext_edge_id encoding (link_id, 'rev')</li>
</ul>
<p>This allows algorithms to consider traffic flowing in both directions on physical links.
The Core graph itself is always directed; bidirectionality is achieved by explicit reverse edges.</p>
<p><strong>Augmentation Support:</strong></p>
<p>For algorithms requiring virtual source/sink nodes (e.g., multi-source max-flow), the adapter
adds augmentation edges with ext_edge_id = -1 (sentinel for non-network edges). These edges
are not mapped back to scenario links in results.</p>
<h3 id="analysis-algorithms">Analysis Algorithms<a class="headerlink" href="#analysis-algorithms" title="Permanent link">&para;</a></h3>
<p>NetGraph's core algorithms execute in C++ via NetGraph-Core. Algorithms operate on the immutable StrictMultiDiGraph and support masking (runtime exclusions via boolean arrays) for efficient repeated analysis under different failure scenarios without graph reconstruction.</p>
<p>All Core algorithms release the Python GIL during execution, enabling concurrent execution across multiple Python threads without GIL contention.</p>
<h3 id="shortest-path-first-spf-algorithm">Shortest-Path First (SPF) Algorithm<a class="headerlink" href="#shortest-path-first-spf-algorithm" title="Permanent link">&para;</a></h3>
<p>Implemented in C++ (<code>netgraph::core::shortest_paths</code>), using Dijkstra's algorithm
with configurable edge selection and optional multipath predecessor recording.</p>
<p><strong>Core Features:</strong></p>
<p><strong>Edge Selection Policies:</strong></p>
<p>The algorithm evaluates parallel edges per neighbor using <code>EdgeSelection</code> configuration:</p>
<ul>
<li><code>multi_edge=true</code> (default): Include all parallel edges u→v with minimal cost among (u,v) pairs</li>
<li><code>multi_edge=false</code>: Select single edge per (u,v) pair using tie-breaking:</li>
<li><code>PreferHigherResidual</code>: Choose edge with highest residual capacity (secondary: lowest edge ID)</li>
<li><code>Deterministic</code>: Choose edge with lowest edge ID for reproducibility</li>
<li><code>require_capacity=true</code>: Only consider edges with residual capacity &gt; kMinCap (used in max-flow)</li>
<li><code>require_capacity=false</code> (default): Consider all edges regardless of residual capacity</li>
</ul>
<p><strong>Capacity-Aware Tie-Breaking:</strong></p>
<p>When multiple nodes or edges have equal cost, SPF uses residual capacity for tie-breaking to improve flow distribution:</p>
<ul>
<li><strong>Node-level</strong>: Priority queue ordered by (cost, -residual, node). Among equal-cost nodes, prefers paths with higher bottleneck capacity. This naturally guides flow toward higher-capacity routes.</li>
<li><strong>Edge-level</strong>: When <code>multi_edge=false</code> and <code>tie_break=PreferHigherResidual</code>, selects the parallel edge with most available capacity among equal-cost options.</li>
</ul>
<p>This tie-breaking is applied even in IP/IGP mode (<code>require_capacity=false</code>) using static capacities, improving flow distribution without altering routing topology.</p>
<p><strong>Multipath Support:</strong></p>
<p>With <code>multipath=True</code>, SPF stores all minimal-cost predecessors forming a DAG:
<code>pred[node] = {predecessor: [edge_ids...]}</code>. This DAG captures all equal-cost paths
in a compact form, used by max-flow for flow splitting.</p>
<p><strong>Early Termination:</strong></p>
<p>If <code>dst</code> is provided, SPF stops expanding after popping <code>dst</code> from the priority queue
(continuing only while heap front cost equals dst cost to capture equal-cost predecessors).
This optimization reduces work when only source-to-sink distances are needed.</p>
<p><strong>Masking:</strong></p>
<p>Optional <code>node_mask</code> and <code>edge_mask</code> boolean arrays enable runtime exclusions without
rebuilding the graph. Used by FailureManager for efficient Monte Carlo analysis.</p>
<p><strong>Complexity:</strong></p>
<p>Using binary heap with capacity-aware tie-breaking: (O((V+E) \log V)) time, (O(V+E)) space for costs, predecessors, and residual tracking.</p>
<h3 id="pseudocode-simplified-see-implementation-for-complete-details">Pseudocode (simplified, see implementation for complete details)<a class="headerlink" href="#pseudocode-simplified-see-implementation-for-complete-details" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>function SPF(graph, src, dst=None, multipath=True, edge_selection):
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>    costs = { src: 0 }
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>    pred  = { src: {} }
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>    min_residual_to_node = { src: infinity }  # Track bottleneck capacity for tie-breaking
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>    # Priority queue with node-level tie-breaking by residual capacity
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>    # QItem: (cost, -residual, node) - negated residual for max-heap behavior
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a>    pq = [(0, -infinity, src)]
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a>    best_dst_cost = None
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a>
</span><span id="__span-5-11"><a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a>    while pq:
</span><span id="__span-5-12"><a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a>        (c, neg_res, u) = heappop(pq)
</span><span id="__span-5-13"><a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a>        if c &gt; costs[u]:
</span><span id="__span-5-14"><a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a>            continue  # stale entry
</span><span id="__span-5-15"><a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a>
</span><span id="__span-5-16"><a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a>        if dst is not None and u == dst and best_dst_cost is None:
</span><span id="__span-5-17"><a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a>            best_dst_cost = c
</span><span id="__span-5-18"><a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a>        if dst is not None and u == dst:
</span><span id="__span-5-19"><a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a>            if not pq or pq[0][0] &gt; best_dst_cost:
</span><span id="__span-5-20"><a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a>                break
</span><span id="__span-5-21"><a id="__codelineno-5-21" name="__codelineno-5-21" href="#__codelineno-5-21"></a>            continue
</span><span id="__span-5-22"><a id="__codelineno-5-22" name="__codelineno-5-22" href="#__codelineno-5-22"></a>
</span><span id="__span-5-23"><a id="__codelineno-5-23" name="__codelineno-5-23" href="#__codelineno-5-23"></a>        # Relax edges from u
</span><span id="__span-5-24"><a id="__codelineno-5-24" name="__codelineno-5-24" href="#__codelineno-5-24"></a>        for v in neighbors(u):
</span><span id="__span-5-25"><a id="__codelineno-5-25" name="__codelineno-5-25" href="#__codelineno-5-25"></a>            # Edge selection among parallel edges u-&gt;v
</span><span id="__span-5-26"><a id="__codelineno-5-26" name="__codelineno-5-26" href="#__codelineno-5-26"></a>            min_cost = inf
</span><span id="__span-5-27"><a id="__codelineno-5-27" name="__codelineno-5-27" href="#__codelineno-5-27"></a>            selected_edges = []
</span><span id="__span-5-28"><a id="__codelineno-5-28" name="__codelineno-5-28" href="#__codelineno-5-28"></a>
</span><span id="__span-5-29"><a id="__codelineno-5-29" name="__codelineno-5-29" href="#__codelineno-5-29"></a>            for e_id in edges_between(u, v):
</span><span id="__span-5-30"><a id="__codelineno-5-30" name="__codelineno-5-30" href="#__codelineno-5-30"></a>                residual_cap = residual[e_id] if has_residual else capacity[e_id]
</span><span id="__span-5-31"><a id="__codelineno-5-31" name="__codelineno-5-31" href="#__codelineno-5-31"></a>
</span><span id="__span-5-32"><a id="__codelineno-5-32" name="__codelineno-5-32" href="#__codelineno-5-32"></a>                # Skip if capacity filtering enabled and edge has no residual
</span><span id="__span-5-33"><a id="__codelineno-5-33" name="__codelineno-5-33" href="#__codelineno-5-33"></a>                if edge_selection.require_capacity and residual_cap &lt; kMinCap:
</span><span id="__span-5-34"><a id="__codelineno-5-34" name="__codelineno-5-34" href="#__codelineno-5-34"></a>                    continue
</span><span id="__span-5-35"><a id="__codelineno-5-35" name="__codelineno-5-35" href="#__codelineno-5-35"></a>
</span><span id="__span-5-36"><a id="__codelineno-5-36" name="__codelineno-5-36" href="#__codelineno-5-36"></a>                edge_cost = cost[e_id]
</span><span id="__span-5-37"><a id="__codelineno-5-37" name="__codelineno-5-37" href="#__codelineno-5-37"></a>
</span><span id="__span-5-38"><a id="__codelineno-5-38" name="__codelineno-5-38" href="#__codelineno-5-38"></a>                if edge_cost &lt; min_cost:
</span><span id="__span-5-39"><a id="__codelineno-5-39" name="__codelineno-5-39" href="#__codelineno-5-39"></a>                    min_cost = edge_cost
</span><span id="__span-5-40"><a id="__codelineno-5-40" name="__codelineno-5-40" href="#__codelineno-5-40"></a>                    selected_edges = select_edge_by_policy(e_id, edge_selection, residual_cap)
</span><span id="__span-5-41"><a id="__codelineno-5-41" name="__codelineno-5-41" href="#__codelineno-5-41"></a>
</span><span id="__span-5-42"><a id="__codelineno-5-42" name="__codelineno-5-42" href="#__codelineno-5-42"></a>                elif edge_cost == min_cost:
</span><span id="__span-5-43"><a id="__codelineno-5-43" name="__codelineno-5-43" href="#__codelineno-5-43"></a>                    if edge_selection.multi_edge:
</span><span id="__span-5-44"><a id="__codelineno-5-44" name="__codelineno-5-44" href="#__codelineno-5-44"></a>                        selected_edges.append(e_id)  # Keep all equal-cost edges
</span><span id="__span-5-45"><a id="__codelineno-5-45" name="__codelineno-5-45" href="#__codelineno-5-45"></a>                    else:
</span><span id="__span-5-46"><a id="__codelineno-5-46" name="__codelineno-5-46" href="#__codelineno-5-46"></a>                        # Edge-level tie-breaking for single-edge selection
</span><span id="__span-5-47"><a id="__codelineno-5-47" name="__codelineno-5-47" href="#__codelineno-5-47"></a>                        selected_edges = tiebreak_edge(selected_edges, e_id,
</span><span id="__span-5-48"><a id="__codelineno-5-48" name="__codelineno-5-48" href="#__codelineno-5-48"></a>                                                      edge_selection.tie_break, residual_cap)
</span><span id="__span-5-49"><a id="__codelineno-5-49" name="__codelineno-5-49" href="#__codelineno-5-49"></a>
</span><span id="__span-5-50"><a id="__codelineno-5-50" name="__codelineno-5-50" href="#__codelineno-5-50"></a>            if not selected_edges:
</span><span id="__span-5-51"><a id="__codelineno-5-51" name="__codelineno-5-51" href="#__codelineno-5-51"></a>                continue  # no admissible edges to v
</span><span id="__span-5-52"><a id="__codelineno-5-52" name="__codelineno-5-52" href="#__codelineno-5-52"></a>
</span><span id="__span-5-53"><a id="__codelineno-5-53" name="__codelineno-5-53" href="#__codelineno-5-53"></a>            new_cost = c + min_cost
</span><span id="__span-5-54"><a id="__codelineno-5-54" name="__codelineno-5-54" href="#__codelineno-5-54"></a>
</span><span id="__span-5-55"><a id="__codelineno-5-55" name="__codelineno-5-55" href="#__codelineno-5-55"></a>            # Compute bottleneck capacity: min of path residual and max edge residual
</span><span id="__span-5-56"><a id="__codelineno-5-56" name="__codelineno-5-56" href="#__codelineno-5-56"></a>            max_edge_res = max(residual[e] for e in selected_edges)
</span><span id="__span-5-57"><a id="__codelineno-5-57" name="__codelineno-5-57" href="#__codelineno-5-57"></a>            path_residual = min(min_residual_to_node[u], max_edge_res)
</span><span id="__span-5-58"><a id="__codelineno-5-58" name="__codelineno-5-58" href="#__codelineno-5-58"></a>
</span><span id="__span-5-59"><a id="__codelineno-5-59" name="__codelineno-5-59" href="#__codelineno-5-59"></a>            # Relaxation: found shorter path
</span><span id="__span-5-60"><a id="__codelineno-5-60" name="__codelineno-5-60" href="#__codelineno-5-60"></a>            if new_cost &lt; costs[v]:
</span><span id="__span-5-61"><a id="__codelineno-5-61" name="__codelineno-5-61" href="#__codelineno-5-61"></a>                costs[v] = new_cost
</span><span id="__span-5-62"><a id="__codelineno-5-62" name="__codelineno-5-62" href="#__codelineno-5-62"></a>                min_residual_to_node[v] = path_residual
</span><span id="__span-5-63"><a id="__codelineno-5-63" name="__codelineno-5-63" href="#__codelineno-5-63"></a>                pred[v] = { u: selected_edges }
</span><span id="__span-5-64"><a id="__codelineno-5-64" name="__codelineno-5-64" href="#__codelineno-5-64"></a>                pq.push((new_cost, -path_residual, v))  # Node-level tie-breaking by capacity
</span><span id="__span-5-65"><a id="__codelineno-5-65" name="__codelineno-5-65" href="#__codelineno-5-65"></a>
</span><span id="__span-5-66"><a id="__codelineno-5-66" name="__codelineno-5-66" href="#__codelineno-5-66"></a>            # Multipath: found equal-cost alternative
</span><span id="__span-5-67"><a id="__codelineno-5-67" name="__codelineno-5-67" href="#__codelineno-5-67"></a>            elif multipath and new_cost == costs[v]:
</span><span id="__span-5-68"><a id="__codelineno-5-68" name="__codelineno-5-68" href="#__codelineno-5-68"></a>                pred[v][u] = selected_edges
</span><span id="__span-5-69"><a id="__codelineno-5-69" name="__codelineno-5-69" href="#__codelineno-5-69"></a>                # Don&#39;t update min_residual_to_node in multipath (collecting all paths)
</span><span id="__span-5-70"><a id="__codelineno-5-70" name="__codelineno-5-70" href="#__codelineno-5-70"></a>
</span><span id="__span-5-71"><a id="__codelineno-5-71" name="__codelineno-5-71" href="#__codelineno-5-71"></a>        if best_dst_cost is not None and (not pq or pq[0][0] &gt; best_dst_cost):
</span><span id="__span-5-72"><a id="__codelineno-5-72" name="__codelineno-5-72" href="#__codelineno-5-72"></a>            break
</span><span id="__span-5-73"><a id="__codelineno-5-73" name="__codelineno-5-73" href="#__codelineno-5-73"></a>
</span><span id="__span-5-74"><a id="__codelineno-5-74" name="__codelineno-5-74" href="#__codelineno-5-74"></a>    return costs, pred
</span><span id="__span-5-75"><a id="__codelineno-5-75" name="__codelineno-5-75" href="#__codelineno-5-75"></a>
</span><span id="__span-5-76"><a id="__codelineno-5-76" name="__codelineno-5-76" href="#__codelineno-5-76"></a>
</span><span id="__span-5-77"><a id="__codelineno-5-77" name="__codelineno-5-77" href="#__codelineno-5-77"></a># Tie-breaking policies for edge selection when multi_edge=false:
</span><span id="__span-5-78"><a id="__codelineno-5-78" name="__codelineno-5-78" href="#__codelineno-5-78"></a>function tiebreak_edge(current_edges, new_edge, tie_break, new_residual):
</span><span id="__span-5-79"><a id="__codelineno-5-79" name="__codelineno-5-79" href="#__codelineno-5-79"></a>    if tie_break == PreferHigherResidual:
</span><span id="__span-5-80"><a id="__codelineno-5-80" name="__codelineno-5-80" href="#__codelineno-5-80"></a>        # Select edge with highest residual capacity
</span><span id="__span-5-81"><a id="__codelineno-5-81" name="__codelineno-5-81" href="#__codelineno-5-81"></a>        if new_residual &gt; current_best_residual + epsilon:
</span><span id="__span-5-82"><a id="__codelineno-5-82" name="__codelineno-5-82" href="#__codelineno-5-82"></a>            return [new_edge]
</span><span id="__span-5-83"><a id="__codelineno-5-83" name="__codelineno-5-83" href="#__codelineno-5-83"></a>        elif abs(new_residual - current_best_residual) &lt;= epsilon:
</span><span id="__span-5-84"><a id="__codelineno-5-84" name="__codelineno-5-84" href="#__codelineno-5-84"></a>            # Secondary tie-break: deterministic by edge ID
</span><span id="__span-5-85"><a id="__codelineno-5-85" name="__codelineno-5-85" href="#__codelineno-5-85"></a>            return [min(new_edge, current_edges[0])]
</span><span id="__span-5-86"><a id="__codelineno-5-86" name="__codelineno-5-86" href="#__codelineno-5-86"></a>    else:  # Deterministic
</span><span id="__span-5-87"><a id="__codelineno-5-87" name="__codelineno-5-87" href="#__codelineno-5-87"></a>        # Select edge with smallest ID for reproducibility
</span><span id="__span-5-88"><a id="__codelineno-5-88" name="__codelineno-5-88" href="#__codelineno-5-88"></a>        return [min(new_edge, current_edges[0])]
</span></code></pre></div>
<p><strong>Key Tie-Breaking Mechanisms:</strong></p>
<ol>
<li>
<p><strong>Node-level tie-breaking</strong>: When multiple nodes have equal cost in the priority queue, prefer nodes reachable via paths with higher bottleneck (residual) capacity. This naturally distributes flows across equal-cost paths based on available capacity.</p>
</li>
<li>
<p><strong>Edge-level tie-breaking</strong> (when <code>multi_edge=false</code>):
   - <code>PreferHigherResidual</code>: Among parallel equal-cost edges (u,v), select the one with highest residual capacity
   - <code>Deterministic</code>: Select edge with smallest ID for reproducible results</p>
</li>
<li>
<p><strong>Multipath behavior</strong>: When <code>multipath=true</code>, all equal-cost predecessors are retained without capacity-based filtering, enabling flow splitting across all equal-cost paths.</p>
</li>
</ol>
<h3 id="maximum-flow-algorithm">Maximum Flow Algorithm<a class="headerlink" href="#maximum-flow-algorithm" title="Permanent link">&para;</a></h3>
<p>Implemented in C++ (<code>netgraph::core::max_flow</code>), using successive shortest paths with
blocking flow augmentation. The algorithm blends Edmonds-Karp (augment along shortest
paths) and Dinic (push blocking flows on a level graph) with cost awareness and
configurable flow splitting across equal-cost parallel edges.</p>
<p><strong>Goal:</strong> Compute maximum feasible flow between source and sink under edge capacity constraints.</p>
<p><strong>Multi-source/multi-sink:</strong> Handled by <code>AnalysisContext</code> which creates pseudo-source and pseudo-sink nodes with large-capacity, zero-cost edges to/from real endpoints. The C++ algorithm operates on single source and single sink.</p>
<p><strong>Routing Semantics:</strong> The algorithm's behavior is controlled by <code>require_capacity</code> and <code>shortest_path</code>:</p>
<ul>
<li><code>require_capacity=true</code> + <code>shortest_path=false</code> (SDN/TE): SPF filters to edges with residual capacity, routes adapt iteratively during placement</li>
<li><code>require_capacity=false</code> + <code>shortest_path=true</code> (IP/IGP): SPF uses all edges based on cost, single-pass flow placement over fixed equal-cost paths</li>
</ul>
<p>See "Routing Semantics: IP/IGP vs SDN/TE" section for detailed explanation.</p>
<p>The residual network is maintained via <code>FlowState</code>, which tracks per-edge flow and computes residual capacities on demand. For each edge u→v:</p>
<ul>
<li>Forward residual capacity: <code>capacity(u,v) - flow(u,v)</code></li>
<li>Reverse residual capacity (for flow cancellation): <code>flow(u,v)</code></li>
</ul>
<p>SPF operates over the residual graph by requesting edges with <code>require_capacity=true</code>, which filters to edges with positive residual capacity. The <code>FlowState</code> provides a residual capacity view without graph mutation.</p>
<p>Note: Reverse residual arcs for flow cancellation are distinct from physical reverse edges added via <code>add_reverse=True</code> during graph construction. Physical reverse edges model bidirectional links with independent capacity; residual reverse arcs enable flow augmentation/cancellation.</p>
<p>The core loop finds augmenting paths using the cost-aware SPF described above:</p>
<p>Run SPF from source to sink with <code>multi_edge=true</code> and <code>require_capacity=true</code> (filters to edges with positive residual capacity). This computes shortest-path distances and a predecessor DAG over forward residual edges. The edge cost can represent distance, latency, or preference; SPF selects paths minimizing cumulative cost.</p>
<p>If the pseudo-sink is not reached (i.e., no augmenting path exists), stop: the max flow is achieved.</p>
<p>Otherwise, determine how much flow can be sent along the found paths:</p>
<p>Using the predecessor DAG from SPF, <code>FlowState.place_on_dag</code> computes blocking flow considering parallel edges and the splitting policy. For PROPORTIONAL: builds reversed residual graph, assigns BFS levels, uses DFS to push flow with capacity-proportional splits. For EQUAL_BALANCED: performs topological traversal with equal splits, computes global scale factor to prevent oversubscription.</p>
<p>This yields flow amount <code>f</code> and per-edge flow assignments tracking which edges carry flow and their utilization.</p>
<p>The algorithm then augments the flow: <code>FlowState</code> increases each edge's flow by its assigned portion. Per-edge flows and residual capacities are updated for the next iteration.</p>
<p>Add f to the total flow counter.</p>
<p>If <code>f</code> is below tolerance <code>kMinFlow</code> (negligible flow placed due to numerical limits or exhausted capacity), terminate iteration.</p>
<p>Repeat to find the next augmenting path (back to step 1).</p>
<p>If <code>shortest_path=True</code>, the algorithm performs only one augmentation pass and returns (useful when the goal is a single cheapest augmentation rather than maximum flow).</p>
<p>After the loop, the C++ algorithm computes a FlowSummary which includes:</p>
<ul>
<li>
<p>total_flow: the sum of flow from source to sink achieved</p>
</li>
<li>
<p>edge_flows: per-edge flow assignments (optional, populated when requested)</p>
</li>
<li>
<p>residual_capacity: remaining capacity on each edge = capacity - flow (optional, populated when requested)</p>
</li>
<li>
<p>reachable_nodes: the set of nodes reachable from the source in the final residual network (optional, identifies the source side of the min-cut)</p>
</li>
<li>
<p>min_cut: the list of edges that are saturated and go from reachable to non-reachable (these form the minimum cut)</p>
</li>
<li>
<p>cost_distribution: flow volume placed at each path cost tier. Core returns parallel arrays (<code>costs</code>, <code>flows</code>); AnalysisContext converts these to <code>Dict[Cost, Flow]</code> mapping in <code>FlowSummary.cost_distribution</code>.</p>
</li>
</ul>
<p>This is returned along with the total flow value.</p>
<h3 id="routing-semantics-ipigp-vs-sdnte">Routing Semantics: IP/IGP vs SDN/TE<a class="headerlink" href="#routing-semantics-ipigp-vs-sdnte" title="Permanent link">&para;</a></h3>
<p>NetGraph models two fundamentally different routing paradigms through the <code>require_capacity</code> and <code>shortest_path</code> parameters:</p>
<p><strong>IP/IGP Semantics (<code>require_capacity=false</code> + <code>shortest_path=true</code>):</strong></p>
<p>Traditional IP routing with Interior Gateway Protocols (OSPF, IS-IS):</p>
<ul>
<li>Routes computed based on link costs/metrics only, ignoring available capacity</li>
<li>Single SPF computation determines equal-cost paths; forwarding is fixed until topology/cost change</li>
<li>Traffic follows predetermined paths even as links saturate</li>
<li>Models best-effort forwarding with potential packet loss when demand exceeds capacity</li>
<li>No iterative augmentation: flow placed in single pass over fixed equal-cost DAG</li>
<li>Use case: Simulating production IP networks, validating IGP designs</li>
</ul>
<p><strong>SDN/TE Semantics (<code>require_capacity=true</code> + <code>shortest_path=false</code>, default):</strong></p>
<p>Software-Defined Networking and Traffic Engineering:</p>
<ul>
<li>Routes adapt dynamically to residual link capacities during flow placement</li>
<li>SPF recomputed after each flow placement iteration, excluding saturated links</li>
<li>Iterative augmentation continues until max-flow achieved or capacity exhausted</li>
<li>Flow placement respects capacity constraints, never oversubscribing links</li>
<li>Models centralized traffic engineering with real-time capacity awareness</li>
<li>Use case: Optimal demand placement, capacity planning, failure impact analysis</li>
</ul>
<p>This distinction is fundamental: IP networks route on cost alone with fixed forwarding tables (congestion managed via queuing/drops), while TE systems route dynamically on both cost and available capacity (congestion avoided via admission control). The <code>require_capacity</code> parameter controls whether SPF filters to available capacity; <code>shortest_path</code> controls whether routes are recomputed iteratively or fixed after initial SPF.</p>
<h3 id="flow-placement-strategies">Flow Placement Strategies<a class="headerlink" href="#flow-placement-strategies" title="Permanent link">&para;</a></h3>
<p>Beyond routing semantics, NetGraph controls how flow splits across equal-cost parallel edges through <code>FlowPlacement</code>:</p>
<ul>
<li><strong>PROPORTIONAL</strong> (default, models WCMP/Weighted ECMP):</li>
<li>Splits flow across parallel equal-cost edges proportional to residual capacity</li>
<li>Example: Two 100G links get 50/50 split; one 100G + one 10G get 91/9 split</li>
<li>Maximizes utilization by preferring higher-capacity paths</li>
<li>Used in networks with heterogeneous link speeds (common in fabrics with multi-generation hardware)</li>
<li>
<p>Can be used iteratively (e.g., successive max-flow augmentations)</p>
</li>
<li>
<p><strong>EQUAL_BALANCED</strong> (models traditional ECMP):</p>
</li>
<li>Splits flow equally across all parallel equal-cost edges regardless of capacity</li>
<li>Example: Two 100G links get 50/50; one 100G + one 10G still attempt 50/50 (10G saturates first)</li>
<li>Models IP hash-based load balancing (5-tuple hashing distributes flows uniformly)</li>
<li>Single-pass admission: computes one global scale factor to avoid oversubscription</li>
<li>For IP ECMP simulation: use with <code>require_capacity=false</code> + <code>shortest_path=true</code></li>
</ul>
<p><code>FlowState.place_on_dag</code> implements single-pass placement over a fixed SPF DAG:</p>
<ul>
<li>
<p><strong>PROPORTIONAL</strong>: Constructs reversed residual graph from predecessor DAG. Uses Dinic-style BFS leveling and DFS push from sink to source. Within each edge group (parallel edges between node pair), splits flow proportionally to residual capacity. Distributes pushed flow back to underlying edges maintaining proportional ratios. Can be called iteratively on updated residuals.</p>
</li>
<li>
<p><strong>EQUAL_BALANCED</strong>: Performs topological traversal (Kahn's algorithm) from source to sink over forward DAG. Assigns equal splits across all outgoing parallel edges from each node. Computes global scale factor as <code>min(edge_capacity / edge_assignment)</code> across all edges to prevent oversubscription. Applies scale uniformly and stops. This models single-pass ECMP admission where the forwarding DAG doesn't change mid-flow.</p>
</li>
</ul>
<p><strong>Configuration Examples:</strong></p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="c1"># IP/ECMP: Traditional router behavior (cost-based routing, equal splits)</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">)</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span>
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>    <span class="n">flow_placement</span><span class="o">=</span><span class="n">FlowPlacement</span><span class="o">.</span><span class="n">EQUAL_BALANCED</span><span class="p">,</span>
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>    <span class="n">shortest_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Single SPF tier</span>
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a>    <span class="n">require_capacity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Ignore capacity when routing</span>
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a>
</span><span id="__span-6-7"><a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a><span class="c1"># SDN/TE with WCMP: Capacity-aware routing with proportional splits</span>
</span><span id="__span-6-8"><a id="__codelineno-6-8" name="__codelineno-6-8" href="#__codelineno-6-8"></a><span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">)</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span>
</span><span id="__span-6-9"><a id="__codelineno-6-9" name="__codelineno-6-9" href="#__codelineno-6-9"></a>    <span class="n">flow_placement</span><span class="o">=</span><span class="n">FlowPlacement</span><span class="o">.</span><span class="n">PROPORTIONAL</span><span class="p">,</span>
</span><span id="__span-6-10"><a id="__codelineno-6-10" name="__codelineno-6-10" href="#__codelineno-6-10"></a>    <span class="n">shortest_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Iterative augmentation</span>
</span><span id="__span-6-11"><a id="__codelineno-6-11" name="__codelineno-6-11" href="#__codelineno-6-11"></a>    <span class="n">require_capacity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Adapt routes to capacity</span>
</span><span id="__span-6-12"><a id="__codelineno-6-12" name="__codelineno-6-12" href="#__codelineno-6-12"></a>
</span><span id="__span-6-13"><a id="__codelineno-6-13" name="__codelineno-6-13" href="#__codelineno-6-13"></a><span class="c1"># WCMP: Fixed equal-cost paths with bandwidth-weighted splits</span>
</span><span id="__span-6-14"><a id="__codelineno-6-14" name="__codelineno-6-14" href="#__codelineno-6-14"></a><span class="n">analyze</span><span class="p">(</span><span class="n">network</span><span class="p">)</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span>
</span><span id="__span-6-15"><a id="__codelineno-6-15" name="__codelineno-6-15" href="#__codelineno-6-15"></a>    <span class="n">flow_placement</span><span class="o">=</span><span class="n">FlowPlacement</span><span class="o">.</span><span class="n">PROPORTIONAL</span><span class="p">,</span>
</span><span id="__span-6-16"><a id="__codelineno-6-16" name="__codelineno-6-16" href="#__codelineno-6-16"></a>    <span class="n">shortest_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Single tier of equal-cost paths</span>
</span><span id="__span-6-17"><a id="__codelineno-6-17" name="__codelineno-6-17" href="#__codelineno-6-17"></a>    <span class="n">require_capacity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Fixed paths regardless of utilization</span>
</span></code></pre></div>
<p>These configurations enable realistic modeling of diverse forwarding behaviors: from traditional IP networks with best-effort delivery to modern SDN deployments with capacity-aware traffic engineering.</p>
<h3 id="flow-policy-presets">Flow Policy Presets<a class="headerlink" href="#flow-policy-presets" title="Permanent link">&para;</a></h3>
<p>For traffic matrix placement, NetGraph provides <code>FlowPolicyPreset</code> values that bundle the routing semantics described above into convenient configurations. These presets map to real-world network behaviors:</p>
<table>
<thead>
<tr>
<th>Preset</th>
<th>Behavior</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHORTEST_PATHS_ECMP</code></td>
<td>IP/IGP with hash-based ECMP</td>
<td>Traditional routers (OSPF/IS-IS), equal splits across equal-cost paths</td>
</tr>
<tr>
<td><code>SHORTEST_PATHS_WCMP</code></td>
<td>IP/IGP with weighted ECMP</td>
<td>Routers with WCMP support, proportional splits based on link capacity</td>
</tr>
<tr>
<td><code>TE_WCMP_UNLIM</code></td>
<td>MPLS-TE / SDN with WCMP</td>
<td>Capacity-aware TE with unlimited tunnels, iterative placement</td>
</tr>
<tr>
<td><code>TE_ECMP_16_LSP</code></td>
<td>MPLS-TE with 16 LSPs</td>
<td>Fixed 16 ECMP tunnels per demand, models RSVP-TE with LSP limits</td>
</tr>
<tr>
<td><code>TE_ECMP_UP_TO_256_LSP</code></td>
<td>MPLS-TE with up to 256 LSPs</td>
<td>Scalable TE with tunnel limit, models SR-TE or large-scale RSVP</td>
</tr>
</tbody>
</table>
<p><strong>Detailed Configuration Mapping (preset internals):</strong></p>
<table>
<thead>
<tr>
<th>Preset</th>
<th><code>require_capacity</code></th>
<th><code>multi_edge</code></th>
<th><code>max_flow_count</code></th>
<th><code>flow_placement</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHORTEST_PATHS_ECMP</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>1</code></td>
<td><code>EQUAL_BALANCED</code></td>
</tr>
<tr>
<td><code>SHORTEST_PATHS_WCMP</code></td>
<td><code>false</code></td>
<td><code>true</code></td>
<td><code>1</code></td>
<td><code>PROPORTIONAL</code></td>
</tr>
<tr>
<td><code>TE_WCMP_UNLIM</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td>unlimited</td>
<td><code>PROPORTIONAL</code></td>
</tr>
<tr>
<td><code>TE_ECMP_16_LSP</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>16</code></td>
<td><code>EQUAL_BALANCED</code></td>
</tr>
<tr>
<td><code>TE_ECMP_UP_TO_256_LSP</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td><code>256</code></td>
<td><code>EQUAL_BALANCED</code></td>
</tr>
</tbody>
</table>
<p><strong>Key parameters (preset-managed):</strong></p>
<ul>
<li><code>require_capacity</code>: When <code>false</code>, paths are selected based on link costs alone (models IP/IGP routing). When <code>true</code>, paths adapt to residual capacity during placement (models SDN/TE). See <a href="#routing-semantics-ipigp-vs-sdnte">Routing Semantics</a> for details.</li>
<li><code>multi_edge</code>: When <code>true</code>, uses all parallel equal-cost edges (hop-by-hop ECMP); when <code>false</code>, each flow uses a single path (tunnel/LSP semantics).</li>
<li><code>max_flow_count</code>: Internal per-preset limit on flows/LSPs for TE presets; not a user-facing parameter.</li>
<li><code>flow_placement</code>: <code>EQUAL_BALANCED</code> splits equally across paths; <code>PROPORTIONAL</code> splits by residual capacity.</li>
</ul>
<p><strong>Example: Modeling IP vs MPLS Networks</strong></p>
<div class="language-yaml highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="c1"># IP network with traditional ECMP (e.g., data center leaf-spine)</span>
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="nt">demands</span><span class="p">:</span>
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a><span class="w">  </span><span class="nt">dc_traffic</span><span class="p">:</span>
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a><span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">source</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">^rack1/</span>
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a><span class="w">      </span><span class="nt">target</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">^rack2/</span>
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a><span class="w">      </span><span class="nt">volume</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1000.0</span>
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a><span class="w">      </span><span class="nt">flow_policy</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">SHORTEST_PATHS_ECMP</span>
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>
</span><span id="__span-7-9"><a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a><span class="c1"># MPLS-TE network with capacity-aware tunnel placement</span>
</span><span id="__span-7-10"><a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a><span class="nt">demands</span><span class="p">:</span>
</span><span id="__span-7-11"><a id="__codelineno-7-11" name="__codelineno-7-11" href="#__codelineno-7-11"></a><span class="w">  </span><span class="nt">backbone_traffic</span><span class="p">:</span>
</span><span id="__span-7-12"><a id="__codelineno-7-12" name="__codelineno-7-12" href="#__codelineno-7-12"></a><span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">source</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">^metro1/</span>
</span><span id="__span-7-13"><a id="__codelineno-7-13" name="__codelineno-7-13" href="#__codelineno-7-13"></a><span class="w">      </span><span class="nt">target</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">^metro2/</span>
</span><span id="__span-7-14"><a id="__codelineno-7-14" name="__codelineno-7-14" href="#__codelineno-7-14"></a><span class="w">      </span><span class="nt">volume</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000.0</span>
</span><span id="__span-7-15"><a id="__codelineno-7-15" name="__codelineno-7-15" href="#__codelineno-7-15"></a><span class="w">      </span><span class="nt">flow_policy</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">TE_WCMP_UNLIM</span>
</span></code></pre></div>
<h3 id="pseudocode-simplified-max-flow-loop">Pseudocode (simplified max-flow loop)<a class="headerlink" href="#pseudocode-simplified-max-flow-loop" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>function MAX_FLOW(graph, S, T, placement=PROPORTIONAL, require_capacity=True):
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a>    flow_state = FlowState(graph)  # Tracks per-edge flow and residuals
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a>    total_flow = 0
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a>    cost_distribution = []
</span><span id="__span-8-5"><a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a>
</span><span id="__span-8-6"><a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a>    while True:
</span><span id="__span-8-7"><a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a>        # Configure edge selection for SPF
</span><span id="__span-8-8"><a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a>        edge_selection = EdgeSelection(
</span><span id="__span-8-9"><a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>            multi_edge=True,
</span><span id="__span-8-10"><a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a>            require_capacity=require_capacity,
</span><span id="__span-8-11"><a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a>            tie_break=Deterministic
</span><span id="__span-8-12"><a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a>        )
</span><span id="__span-8-13"><a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a>
</span><span id="__span-8-14"><a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a>        # Find shortest augmenting paths in residual graph
</span><span id="__span-8-15"><a id="__codelineno-8-15" name="__codelineno-8-15" href="#__codelineno-8-15"></a>        residuals = flow_state.residual_view() if require_capacity else None
</span><span id="__span-8-16"><a id="__codelineno-8-16" name="__codelineno-8-16" href="#__codelineno-8-16"></a>        costs, dag = SPF(graph, S, T,
</span><span id="__span-8-17"><a id="__codelineno-8-17" name="__codelineno-8-17" href="#__codelineno-8-17"></a>                        multipath=True,
</span><span id="__span-8-18"><a id="__codelineno-8-18" name="__codelineno-8-18" href="#__codelineno-8-18"></a>                        edge_selection=edge_selection,
</span><span id="__span-8-19"><a id="__codelineno-8-19" name="__codelineno-8-19" href="#__codelineno-8-19"></a>                        residual=residuals)
</span><span id="__span-8-20"><a id="__codelineno-8-20" name="__codelineno-8-20" href="#__codelineno-8-20"></a>
</span><span id="__span-8-21"><a id="__codelineno-8-21" name="__codelineno-8-21" href="#__codelineno-8-21"></a>        if T not in dag:  # No augmenting path exists
</span><span id="__span-8-22"><a id="__codelineno-8-22" name="__codelineno-8-22" href="#__codelineno-8-22"></a>            break
</span><span id="__span-8-23"><a id="__codelineno-8-23" name="__codelineno-8-23" href="#__codelineno-8-23"></a>
</span><span id="__span-8-24"><a id="__codelineno-8-24" name="__codelineno-8-24" href="#__codelineno-8-24"></a>        # Push blocking flow through predecessor DAG
</span><span id="__span-8-25"><a id="__codelineno-8-25" name="__codelineno-8-25" href="#__codelineno-8-25"></a>        path_cost = costs[T]
</span><span id="__span-8-26"><a id="__codelineno-8-26" name="__codelineno-8-26" href="#__codelineno-8-26"></a>        placed = flow_state.place_on_dag(S, T, dag, infinity, placement)
</span><span id="__span-8-27"><a id="__codelineno-8-27" name="__codelineno-8-27" href="#__codelineno-8-27"></a>
</span><span id="__span-8-28"><a id="__codelineno-8-28" name="__codelineno-8-28" href="#__codelineno-8-28"></a>        if placed &lt; kMinFlow:  # Negligible flow placed
</span><span id="__span-8-29"><a id="__codelineno-8-29" name="__codelineno-8-29" href="#__codelineno-8-29"></a>            break
</span><span id="__span-8-30"><a id="__codelineno-8-30" name="__codelineno-8-30" href="#__codelineno-8-30"></a>
</span><span id="__span-8-31"><a id="__codelineno-8-31" name="__codelineno-8-31" href="#__codelineno-8-31"></a>        total_flow += placed
</span><span id="__span-8-32"><a id="__codelineno-8-32" name="__codelineno-8-32" href="#__codelineno-8-32"></a>        cost_distribution.append((path_cost, placed))
</span><span id="__span-8-33"><a id="__codelineno-8-33" name="__codelineno-8-33" href="#__codelineno-8-33"></a>
</span><span id="__span-8-34"><a id="__codelineno-8-34" name="__codelineno-8-34" href="#__codelineno-8-34"></a>    # Compute min-cut, reachability, cost distribution
</span><span id="__span-8-35"><a id="__codelineno-8-35" name="__codelineno-8-35" href="#__codelineno-8-35"></a>    min_cut = flow_state.compute_min_cut(S, node_mask, edge_mask)
</span><span id="__span-8-36"><a id="__codelineno-8-36" name="__codelineno-8-36" href="#__codelineno-8-36"></a>
</span><span id="__span-8-37"><a id="__codelineno-8-37" name="__codelineno-8-37" href="#__codelineno-8-37"></a>    return FlowSummary(
</span><span id="__span-8-38"><a id="__codelineno-8-38" name="__codelineno-8-38" href="#__codelineno-8-38"></a>        total_flow=total_flow,
</span><span id="__span-8-39"><a id="__codelineno-8-39" name="__codelineno-8-39" href="#__codelineno-8-39"></a>        cost_distribution=cost_distribution,
</span><span id="__span-8-40"><a id="__codelineno-8-40" name="__codelineno-8-40" href="#__codelineno-8-40"></a>        min_cut=min_cut,
</span><span id="__span-8-41"><a id="__codelineno-8-41" name="__codelineno-8-41" href="#__codelineno-8-41"></a>        edge_flows=...,  # optional
</span><span id="__span-8-42"><a id="__codelineno-8-42" name="__codelineno-8-42" href="#__codelineno-8-42"></a>        residual_capacity=...,  # optional
</span><span id="__span-8-43"><a id="__codelineno-8-43" name="__codelineno-8-43" href="#__codelineno-8-43"></a>        reachable_nodes=...  # optional
</span><span id="__span-8-44"><a id="__codelineno-8-44" name="__codelineno-8-44" href="#__codelineno-8-44"></a>    )
</span></code></pre></div>
<p>The flow tolerance constant <code>kMinFlow</code> (default 1/4096 ≈ 2.4e-4) determines when flow placement is considered negligible and iteration terminates.</p>
<p>Each augmentation phase performs one SPF (O((V+E) \log V)) and one blocking-flow computation (O(V+E)) over the predecessor DAG. With blocking flow augmentation, the shortest path distance (in hops) increases with each phase, bounding the number of phases by (O(V)). This yields an overall complexity of (O(V \cdot (V+E) \log V)) = (O(V^2 E \log V)) for sparse graphs where (E = O(V)).</p>
<p>Practical performance is significantly better than worst-case bounds due to early termination when residual capacity exhausts. For integer capacities, the bound becomes (O(F \cdot (V+E) \log V)) where (F) is the max-flow value, which dominates when (F \ll V).</p>
<h3 id="managers-and-workflow-orchestration">Managers and Workflow Orchestration<a class="headerlink" href="#managers-and-workflow-orchestration" title="Permanent link">&para;</a></h3>
<p>Managers handle scenario dynamics and prepare inputs for algorithmic steps.</p>
<p><strong>Demand Expansion</strong> (<code>ngraph.model.demand.builder</code>): Builds demand sets from DSL definitions, expanding source/target patterns into concrete node groups.</p>
<ul>
<li>Deterministic expansion: source/target node lists sorted alphabetically; no randomization</li>
<li>Supports <code>combine</code> mode (aggregate via pseudo nodes) and <code>pairwise</code> mode (individual (src,dst) pairs with volume split)</li>
<li>Demands sorted by ascending priority before placement (lower value = higher priority)</li>
<li>Placement uses SPF caching for simple policies (ECMP, WCMP, TE_WCMP_UNLIM), FlowPolicy for complex multi-flow policies</li>
<li>Non-mutating: operates on Core flow graphs with exclusions; Network remains unmodified</li>
</ul>
<p><strong>Failure Manager</strong> (<code>ngraph.analysis.failure_manager</code>): Applies a <code>FailurePolicy</code> to compute exclusion sets and runs analyses with those exclusions.</p>
<ul>
<li>Parallel execution via <code>ThreadPoolExecutor</code> with zero-copy network sharing across worker threads</li>
<li>Deterministic results when seed is provided (each iteration derives <code>seed + iteration_index</code>)</li>
<li>Optional baseline execution (no failures) for comparing degraded vs. intact capacity</li>
<li>Automatic parallelism adjustment: Forces serial execution when analysis function defined in <code>__main__</code> (notebook context) to avoid pickling failures</li>
<li>Thread-safe analysis: Network shared by reference; exclusion sets passed per-iteration</li>
<li>Automatic graph pre-building: Before parallel iterations, builds <code>AnalysisContext</code> to amortize graph construction cost; per-iteration exclusions applied via O(|excluded|) mask operations</li>
</ul>
<p>Both the demand expansion logic and failure manager separate policy (how to expand demands or pick failures) from core algorithms. They prepare concrete inputs (expanded demands or exclusion sets) for each workflow iteration.</p>
<h3 id="workflow-engine-and-steps">Workflow Engine and Steps<a class="headerlink" href="#workflow-engine-and-steps" title="Permanent link">&para;</a></h3>
<p>NetGraph workflows (see Workflow Reference) are essentially recipes of analysis steps to run in sequence. Each step is typically a pure function: it takes the current model and possibly prior results, performs an analysis, and stores its outputs. The workflow engine coordinates these steps, using a Results store to record data.</p>
<p>Common built-in steps:</p>
<ul>
<li>
<p>BuildGraph: validates network topology and stores node-link JSON representation via NetworkX <code>MultiDiGraph</code>. Stores graph structure under <code>data.graph</code> and parameters under <code>data.context</code>. Primarily for validation and export; Core graph building happens in analysis functions.</p>
</li>
<li>
<p>NetworkStats: computes node/link counts, capacity statistics, cost statistics, and degree statistics. Supports optional <code>excluded_nodes</code>/<code>excluded_links</code> and <code>include_disabled</code>.</p>
</li>
<li>
<p>TrafficMatrixPlacement: runs Monte Carlo placement using a named demand set and the Failure Manager. Supports <code>baseline</code>, <code>iterations</code>, <code>parallelism</code>, <code>placement_rounds</code>, <code>store_failure_patterns</code>, <code>include_flow_details</code>, <code>include_used_edges</code>, and <code>alpha</code> or <code>alpha_from_step</code> (default <code>data.alpha_star</code>). Produces <code>data.flow_results</code> per iteration.</p>
</li>
<li>
<p>MaxFlow: runs Monte Carlo maximum-flow analysis between node groups using the Failure Manager. Supports <code>mode</code> (combine/pairwise), <code>baseline</code>, <code>iterations</code>, <code>parallelism</code>, <code>shortest_path</code>, <code>flow_placement</code>, and optional <code>include_flow_details</code>/<code>include_min_cut</code>. Produces <code>data.flow_results</code> per iteration.</p>
</li>
<li>
<p>MaximumSupportedDemand (MSD): uses bracketing and bisection on alpha to find the maximum multiplier such that alpha * volume is feasible. Stores <code>data.alpha_star</code>, <code>data.context</code>, <code>data.base_demands</code>, and <code>data.probes</code>.</p>
</li>
<li>
<p>CostPower: aggregates platform and per-end optics capex/power by hierarchy level (0..N). Respects <code>include_disabled</code> and <code>aggregation_level</code>. Stores <code>data.levels</code> and <code>data.context</code>.</p>
</li>
</ul>
<p>Each step is implemented in the code (in ngraph.workflow module) and has a corresponding <code>type</code> name. Steps are pure functions that don't modify the Network. They take inputs, often including references to prior steps' results (the workflow engine allows one step to use another step's output). For instance, a placement step might need the value of alpha* from an MSD step; the workflow definition can specify that link.</p>
<h3 id="results-storage">Results storage<a class="headerlink" href="#results-storage" title="Permanent link">&para;</a></h3>
<p>The Results object is a container that the workflow passes through steps. When a step runs, it "enters" a scope in the Results (by step name) and writes any outputs to either metadata or data within that scope.</p>
<p>For example, the MaxFlow step named "maxflow_between_metros" will put the total flow and details under <code>results.steps["maxflow_between_metros"]["data"]</code> and perhaps record parameters in metadata. The Results store also captures each step's execution metadata (like step order, type, seeds) in a workflow registry. At the end of the workflow, a single nested dictionary can be exported via Results.to_dict() containing all step outputs in a structured way.</p>
<p>This design ensures consistency (every step has metadata and data keys) and JSON serialization (handles custom objects via to_dict() when available, converts keys to strings). The results often include artifacts like tables or lists of flows for reporting.</p>
<h3 id="design-elements-and-comparisons">Design Elements and Comparisons<a class="headerlink" href="#design-elements-and-comparisons" title="Permanent link">&para;</a></h3>
<p>NetGraph's design includes several features that differentiate it from traditional network analysis tools:</p>
<ul>
<li>
<p>Declarative Scenario DSL: A YAML DSL with blueprints and programmatic expansion allows abstract definitions (e.g., a fully meshed Clos) to be expanded into concrete nodes and links. Strict schema validation ensures that scenarios are well-formed and rejects unknown or invalid fields.</p>
</li>
<li>
<p>Runtime Exclusions vs graph copying: Analysis-time exclusions avoid copying large structures for each scenario. The design separates static topology from dynamic failure states.</p>
</li>
<li>
<p>Stable edge IDs: Links have auto-generated unique IDs (<code>source|target|&lt;base64_uuid&gt;</code>) that remain stable throughout analysis, simplifying correlation of results to original links.</p>
</li>
<li>
<p>Dual routing semantics: Models both IP/IGP (cost-only, fixed paths via <code>require_capacity=false</code> + <code>shortest_path=true</code>) and SDN/TE (capacity-aware, iterative via <code>require_capacity=true</code> + <code>shortest_path=false</code>)</p>
</li>
<li>
<p>Configurable flow placement: Proportional (WCMP-style, capacity-weighted) and Equal-Balanced (ECMP-style, uniform) splitting across parallel equal-cost edges</p>
</li>
<li>
<p>Cost-aware augmentation: Prefer cheapest capacity first via successive shortest paths. Does not re-route previously placed flow.</p>
</li>
<li>
<p>Deterministic simulation with seeding: Random aspects (e.g., failure sampling) are controlled by explicit seeds that propagate through steps. Runs are reproducible given the same scenario and seed.</p>
</li>
<li>
<p>Structured results store: Collects results with metadata in a consistent format for JSON export and downstream analysis.</p>
</li>
</ul>
<h3 id="performance-considerations">Performance Considerations<a class="headerlink" href="#performance-considerations" title="Permanent link">&para;</a></h3>
<p><strong>C++ Algorithm Implementation:</strong></p>
<ul>
<li>Native C++ execution with optimized data structures (CSR adjacency, flat arrays)</li>
<li>GIL released during algorithm execution, enabling concurrent analysis across Python threads</li>
<li>Zero-copy NumPy integration for array inputs/outputs (via buffer protocol)</li>
<li>Deterministic edge ordering for reproducible results</li>
<li>Cache-friendly CSR representation for efficient neighbor traversal</li>
</ul>
<p><strong>Graph Building and Reuse:</strong></p>
<p>For Monte Carlo analysis with many failure iterations, graph construction is amortized via <code>AnalysisContext</code>:</p>
<ul>
<li>Context built once before iterations begin (includes all nodes and augmentation edges)</li>
<li>Per-iteration exclusions applied via boolean masks rather than graph rebuilding</li>
<li>Mask building is O(|excluded|) using pre-computed <code>link_id_to_edge_indices</code> mapping</li>
<li>FailureManager automatically pre-builds the <code>AnalysisContext</code> before parallel execution</li>
</ul>
<p>This optimization is critical for performance: graph construction involves Python processing, NumPy array creation, and C++ object initialization. Building the graph once eliminates this overhead from the per-iteration critical path, enabling the GIL-releasing C++ algorithms to execute with minimal Python overhead.</p>
<p><strong>SPF Caching for Demand Placement:</strong></p>
<p>Both TrafficMatrixPlacement and MaximumSupportedDemand (MSD) use a unified placement function (<code>place_demands()</code> in <code>ngraph.analysis.placement</code>) with SPF caching for cacheable policies (ECMP, WCMP, TE_WCMP_UNLIM):</p>
<ul>
<li>Initial SPF computed once per unique source; subsequent demands from the same source reuse the cached DAG</li>
<li>For TE policies, DAG is recomputed when capacity constraints require alternate paths</li>
<li>Complex multi-flow policies (TE_ECMP_16_LSP, TE_ECMP_UP_TO_256_LSP) use FlowPolicy directly</li>
<li>MSD additionally pre-resolves node IDs once at cache build time and reuses them across all alpha probes</li>
</ul>
<p>This reduces SPF computations from O(demands) to O(unique_sources) for workloads where many demands share the same source nodes. For MSD, the optimization is particularly significant since it evaluates many alpha values during binary search.</p>
<p><strong>Monte Carlo Deduplication:</strong></p>
<p>FailureManager collapses identical failure patterns into single executions. Runtime
scales with unique patterns U rather than requested iterations I; often U &lt;&lt; I for
common failure policies.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>SPF: (O((V+E) \log V)) using binary heap</li>
<li>Max-flow: (O(V^2 E \log V)) worst-case for successive shortest paths with blocking flow</li>
<li>Practical performance dominated by (O(F \cdot (V+E) \log V)) for integer capacities where (F) is max-flow value</li>
<li>Early termination when residual capacity exhausts provides significant speedup in typical networks</li>
</ul>
<p><strong>Scalability:</strong></p>
<p>Benchmarks on structured topologies (Clos, grid) and realistic network graphs demonstrate scalability to networks with thousands of nodes and tens of thousands of edges. C++ execution with CSR adjacency and GIL release provides order-of-magnitude speedups over pure Python graph libraries for compute-intensive analysis.</p>
<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h2>
<p>NetGraph's hybrid architecture combines:</p>
<p><strong>Python Layer:</strong></p>
<ul>
<li>Declarative scenario DSL with schema validation</li>
<li>Domain model (Network, Node, Link, RiskGroup)</li>
<li>Runtime exclusions for non-destructive failure simulation</li>
<li>Workflow orchestration and result aggregation</li>
<li>Managers for demand expansion and failure enumeration</li>
</ul>
<p><strong>C++ Layer:</strong></p>
<ul>
<li>High-performance graph algorithms (SPF, K-shortest paths, max-flow)</li>
<li>Immutable StrictMultiDiGraph with CSR adjacency</li>
<li>Configurable flow placement policies (ECMP/WCMP simulation)</li>
<li>Runtime masking for efficient repeated analysis</li>
</ul>
<p><strong>Integration:</strong></p>
<ul>
<li><code>AnalysisContext</code> builds Core graphs, manages name/ID mapping, and bridges Python ↔ C++</li>
<li>Stable node/edge ID mapping for result traceability</li>
<li>NumPy array interface for efficient data transfer</li>
<li>GIL release during computation for concurrent thread execution</li>
</ul>
<p>This design adapts standard algorithms to network engineering use cases (flow splitting,
failure simulation, cost-aware routing) while achieving high performance through native
C++ execution and ergonomic interfaces through Python APIs.</p>
<h2 id="cross-references">Cross-references<a class="headerlink" href="#cross-references" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="../dsl/">DSL Reference</a></li>
<li><a href="../workflow/">Workflow Reference</a></li>
<li><a href="../cli/">CLI Reference</a></li>
<li><a href="../api/">API Reference</a></li>
<li><a href="../api-full/">Auto-Generated API Reference</a></li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.sections", "navigation.tabs", "navigation.top", "content.code.copy"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>