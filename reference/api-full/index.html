
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://networmix.github.io/NetGraph/reference/api-full/">
      
      
        <link rel="prev" href="../api/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>API Full - NetGraph</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7e37652d.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#netgraph-api-reference-auto-generated" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="NetGraph" class="md-header__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            NetGraph
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Full
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../getting-started/installation/" class="md-tabs__link">
          
  
  
  Getting Started

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../examples/bundled-scenarios/" class="md-tabs__link">
          
  
  
  Examples

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../design/" class="md-tabs__link">
          
  
  
  Reference

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="NetGraph" class="md-nav__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    NetGraph
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Getting Started
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Getting Started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/tutorial/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Quickstart
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/bundled-scenarios/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bundled Scenarios
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Example
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/clos-fabric/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Clos Fabric
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Design
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dsl/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    DSL
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../workflow/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Workflow
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CLI
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schemas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Schemas
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    API Full
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    API Full
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ngraphcli" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.cli
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.cli">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mainargv-optionalliststr-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      main(argv: 'Optional[List[str]]' = None) -&gt; 'None'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphcomponents" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.components
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.components">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#component" class="md-nav__link">
    <span class="md-ellipsis">
      Component
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#componentslibrary" class="md-nav__link">
    <span class="md-ellipsis">
      ComponentsLibrary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" class="md-nav__link">
    <span class="md-ellipsis">
      totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphconfig" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.config
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.config">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmanagerconfig" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficManagerConfig
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.explorer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.explorer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#externallinkbreakdown" class="md-nav__link">
    <span class="md-ellipsis">
      ExternalLinkBreakdown
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkcapacityissue" class="md-nav__link">
    <span class="md-ellipsis">
      LinkCapacityIssue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkExplorer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeutilization" class="md-nav__link">
    <span class="md-ellipsis">
      NodeUtilization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    <span class="md-ellipsis">
      TreeNode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treestats" class="md-nav__link">
    <span class="md-ellipsis">
      TreeStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlogging" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.logging
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.logging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#disable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      disable_debug_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      enable_debug_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_loggername-str-logginglogger" class="md-nav__link">
    <span class="md-ellipsis">
      get_logger(name: str) -&gt; logging.Logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      reset_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_global_log_levellevel-int-none" class="md-nav__link">
    <span class="md-ellipsis">
      set_global_log_level(level: int) -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphscenario" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.scenario
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.scenario">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario" class="md-nav__link">
    <span class="md-ellipsis">
      Scenario
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphseed_manager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.seed_manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.seed_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seedmanager" class="md-nav__link">
    <span class="md-ellipsis">
      SeedManager
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphyaml_utils" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.yaml_utils
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.yaml_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphconvert" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.convert
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.convert">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#from_digraphnx_graph-networkxclassesdigraphdigraph-ngraphgraphstrict_multidigraphstrictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      from_digraph(nx_graph: networkx.classes.digraph.DiGraph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#from_graphnx_graph-networkxclassesgraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      from_graph(nx_graph: networkx.classes.graph.Graph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_digraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesdigraphdigraph" class="md-nav__link">
    <span class="md-ellipsis">
      to_digraph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.digraph.DiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_graphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesgraphgraph" class="md-nav__link">
    <span class="md-ellipsis">
      to_graph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.graph.Graph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphio" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.io
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.io">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgelist_to_graphlines-iterablestr-columns-liststr-separator-str-graph-optionalstrictmultidigraph-none-source-str-src-target-str-dst-key-str-key-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      edgelist_to_graph(lines: 'Iterable[str]', columns: 'List[str]', separator: 'str' = ' ', graph: 'Optional[StrictMultiDiGraph]' = None, source: 'str' = 'src', target: 'str' = 'dst', key: 'str' = 'key') -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph_to_edgelistgraph-strictmultidigraph-columns-optionalliststr-none-separator-str-source_col-str-src-target_col-str-dst-key_col-str-key-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      graph_to_edgelist(graph: 'StrictMultiDiGraph', columns: 'Optional[List[str]]' = None, separator: 'str' = ' ', source_col: 'str' = 'src', target_col: 'str' = 'dst', key_col: 'str' = 'key') -&gt; 'List[str]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph_to_node_linkgraph-strictmultidigraph-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      graph_to_node_link(graph: 'StrictMultiDiGraph') -&gt; 'Dict[str, Any]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node_link_to_graphdata-dictstr-any-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      node_link_to_graph(data: 'Dict[str, Any]') -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphstrict_multidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.strict_multidigraph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.strict_multidigraph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelnetwork" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.model.network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      Link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      Node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      RiskGroup
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelview" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.model.view
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.view">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkview" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkView
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsbase" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.base
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeselect" class="md-nav__link">
    <span class="md-ellipsis">
      EdgeSelect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowplacement" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPlacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pathalg" class="md-nav__link">
    <span class="md-ellipsis">
      PathAlg
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmscapacity" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.capacity
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.capacity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#calc_graph_capacityflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-tuplefloat-dictnodeid-dictnodeid-float" class="md-nav__link">
    <span class="md-ellipsis">
      calc_graph_capacity(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow_placement: 'FlowPlacement' = , capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow') -&gt; 'Tuple[float, Dict[NodeID, Dict[NodeID, float]]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsedge_select" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.edge_select
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.edge_select">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edge_select_fabricedge_select-ngraphalgorithmsbaseedgeselect-select_value-optionalany-none-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable-none-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-cost_attr-str-cost-capacity_attr-str-capacity-flow_attr-str-flow-callablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      edge_select_fabric(edge_select: ngraph.algorithms.base.EdgeSelect, select_value: Optional[Any] = None, edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]] = None, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, cost_attr: str = 'cost', capacity_attr: str = 'capacity', flow_attr: str = 'flow') -&gt; Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsflow_init" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.flow_init
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.flow_init">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#init_flow_graphflow_graph-strictmultidigraph-flow_attr-str-flow-flows_attr-str-flows-reset_flow_graph-bool-true-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      init_flow_graph(flow_graph: 'StrictMultiDiGraph', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows', reset_flow_graph: 'bool' = True) -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsmax_flow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.max_flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.max_flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#calc_max_flowgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-return_summary-bool-false-return_graph-bool-false-flow_placement-ngraphalgorithmsbaseflowplacement-shortest_path-bool-false-reset_flow_graph-bool-false-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-copy_graph-bool-true-tolerance-float-1e-10-unionfloat-tuple" class="md-nav__link">
    <span class="md-ellipsis">
      calc_max_flow(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, *, return_summary: bool = False, return_graph: bool = False, flow_placement: ngraph.algorithms.base.FlowPlacement = , shortest_path: bool = False, reset_flow_graph: bool = False, capacity_attr: str = 'capacity', flow_attr: str = 'flow', flows_attr: str = 'flows', copy_graph: bool = True, tolerance: float = 1e-10) -&gt; Union[float, tuple]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#run_sensitivitygraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-change_amount-float-10-kwargs-dicttuple-float" class="md-nav__link">
    <span class="md-ellipsis">
      run_sensitivity(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, , capacity_attr: str = 'capacity', flow_attr: str = 'flow', change_amount: float = 1.0, *kwargs) -&gt; dict[tuple, float]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#saturated_edgesgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-tolerance-float-1e-10-kwargs-listtuple" class="md-nav__link">
    <span class="md-ellipsis">
      saturated_edges(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, , capacity_attr: str = 'capacity', flow_attr: str = 'flow', tolerance: float = 1e-10, *kwargs) -&gt; list[tuple]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmspaths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#resolve_to_pathssrc_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-split_parallel_edges-bool-false-iteratorpathtuple" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_to_paths(src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', split_parallel_edges: 'bool' = False) -&gt; 'Iterator[PathTuple]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsplacement" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.placement
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.placement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowplacementmeta" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPlacementMeta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#place_flow_on_graphflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow-float-inf-flow_index-optionalhashable-none-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-flowplacementmeta" class="md-nav__link">
    <span class="md-ellipsis">
      place_flow_on_graph(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow: 'float' = inf, flow_index: 'Optional[Hashable]' = None, flow_placement: 'FlowPlacement' = , capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'FlowPlacementMeta'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_flow_from_graphflow_graph-strictmultidigraph-flow_index-optionalhashable-none-flow_attr-str-flow-flows_attr-str-flows-none" class="md-nav__link">
    <span class="md-ellipsis">
      remove_flow_from_graph(flow_graph: 'StrictMultiDiGraph', flow_index: 'Optional[Hashable]' = None, flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'None'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsspf" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.spf
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.spf">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kspgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-max_k-optionalint-none-max_path_cost-unionint-float-inf-max_path_cost_factor-optionalfloat-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-iteratortupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      ksp(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = , edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, max_k: Optional[int] = None, max_path_cost: Union[int, float] = inf, max_path_cost_factor: Optional[float] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None) -&gt; Iterator[Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spfgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-dst_node-optionalhashable-none-tupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      spf(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = , edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, dst_node: Optional[Hashable] = None) -&gt; Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmstypes" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      FlowSummary
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphpathsbundle" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.paths.bundle
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.paths.bundle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pathbundle" class="md-nav__link">
    <span class="md-ellipsis">
      PathBundle
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphpathspath" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.paths.path
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.paths.path">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    <span class="md-ellipsis">
      Path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphflowsflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.flows.flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.flows.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flow" class="md-nav__link">
    <span class="md-ellipsis">
      Flow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowindex" class="md-nav__link">
    <span class="md-ellipsis">
      FlowIndex
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphflowspolicy" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.flows.policy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.flows.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPolicy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowpolicyconfig" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPolicyConfig
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flow_policyflow_policy_config-flowpolicyconfig-flowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      get_flow_policy(flow_policy_config: 'FlowPolicyConfig') -&gt; 'FlowPolicy'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolverhelpers" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.helpers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolvermaxflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.maxflow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.solver.maxflow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#max_flowcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_detailedcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_detailed(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; "Dict[Tuple[str, str], Tuple[float, FlowSummary, 'StrictMultiDiGraph']]"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_with_graphcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_with_graph(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; "Dict[Tuple[str, str], Tuple[float, 'StrictMultiDiGraph']]"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_with_summarycontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_with_summary(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], Tuple[float, FlowSummary]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#saturated_edgescontext-any-source_path-str-sink_path-str-mode-str-combine-tolerance-float-1e-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-listtuplestr-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      saturated_edges(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', tolerance: 'float' = 1e-10, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], List[Tuple[str, str, str]]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysiscontext-any-source_path-str-sink_path-str-mode-str-combine-change_amount-float-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-dicttuplestr-str-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      sensitivity_analysis(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', change_amount: 'float' = 1.0, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolverpaths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.solver.paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k_shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-pairwise-max_k-int-3-edge_select-edgeselect-max_path_cost-float-inf-max_path_cost_factor-optionalfloat-none-split_parallel_edges-bool-false-dicttuplestr-str-listpath" class="md-nav__link">
    <span class="md-ellipsis">
      k_shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'pairwise', max_k: 'int' = 3, edge_select: 'EdgeSelect' = , max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest_path_costscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-dicttuplestr-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      shortest_path_costs(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = ) -&gt; 'Dict[Tuple[str, str], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-split_parallel_edges-bool-false-dicttuplestr-str-listpath" class="md-nav__link">
    <span class="md-ellipsis">
      shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = , split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerbuilder" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.builder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.builder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_traffic_matrix_setraw-dictstr-listdict-trafficmatrixset" class="md-nav__link">
    <span class="md-ellipsis">
      build_traffic_matrix_set(raw: 'Dict[str, List[dict]]') -&gt; 'TrafficMatrixSet'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerexpand" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.expand
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_demandsnetwork-unionnetwork-networkview-graph-strictmultidigraph-none-traffic_demands-listtrafficdemand-default_flow_policy_config-flowpolicyconfig-tuplelistdemand-dictstr-listdemand" class="md-nav__link">
    <span class="md-ellipsis">
      expand_demands(network: "Union[Network, 'NetworkView']", graph: 'StrictMultiDiGraph | None', traffic_demands: 'List[TrafficDemand]', default_flow_policy_config: 'FlowPolicyConfig') -&gt; 'Tuple[List[Demand], Dict[str, List[Demand]]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagermanager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmanager" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficManager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trafficresult" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficResult
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerschedule" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.schedule
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.schedule">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#place_demands_round_robingraph-strictmultidigraph-demands-listdemand-placement_rounds-int-reoptimize_after_each_round-bool-false-float" class="md-nav__link">
    <span class="md-ellipsis">
      place_demands_round_robin(graph: 'StrictMultiDiGraph', demands: 'List[Demand]', placement_rounds: 'int', reoptimize_after_each_round: 'bool' = False) -&gt; 'float'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmatrix" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.matrix
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.matrix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixset" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficMatrixSet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandspec" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.spec
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.spec">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficdemand" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficDemand
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailureconditions" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.conditions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurecondition" class="md-nav__link">
    <span class="md-ellipsis">
      FailureCondition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionentity_attrs-dictstr-any-cond-failurecondition-bool" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_condition(entity_attrs: 'dict[str, Any]', cond: 'FailureCondition') -&gt; 'bool'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionsentity_attrs-dictstr-any-conditions-iterablefailurecondition-logic-str-bool" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_conditions(entity_attrs: 'dict[str, Any]', conditions: 'Iterable[FailureCondition]', logic: 'str') -&gt; 'bool'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanageraggregate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.aggregate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagerenumerate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.enumerate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagermanager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.manager.manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysisfunction" class="md-nav__link">
    <span class="md-ellipsis">
      AnalysisFunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremanager" class="md-nav__link">
    <span class="md-ellipsis">
      FailureManager
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagersimulate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.simulate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.policy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurecondition_1" class="md-nav__link">
    <span class="md-ellipsis">
      FailureCondition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremode" class="md-nav__link">
    <span class="md-ellipsis">
      FailureMode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePolicy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurerule" class="md-nav__link">
    <span class="md-ellipsis">
      FailureRule
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailurepolicy_set" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.policy_set
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.policy_set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePolicySet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbase" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.base
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#workflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      WorkflowStep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_workflow_stepstep_type-str" class="md-nav__link">
    <span class="md-ellipsis">
      register_workflow_step(step_type: 'str')
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbuild_graph" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.build_graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.build_graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buildgraph" class="md-nav__link">
    <span class="md-ellipsis">
      BuildGraph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowcost_power" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.cost_power
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.cost_power">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#costpower" class="md-nav__link">
    <span class="md-ellipsis">
      CostPower
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmax_flow_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.max_flow_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.max_flow_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxflow" class="md-nav__link">
    <span class="md-ellipsis">
      MaxFlow
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmaximum_supported_demand_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.maximum_supported_demand_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.maximum_supported_demand_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maximumsupporteddemand" class="md-nav__link">
    <span class="md-ellipsis">
      MaximumSupportedDemand
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflownetwork_stats" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.network_stats
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.network_stats">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkstats" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowtraffic_matrix_placement_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.traffic_matrix_placement_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.traffic_matrix_placement_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixplacement" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficMatrixPlacement
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsexpand" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.dsl.blueprints.expand
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    <span class="md-ellipsis">
      Blueprint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslexpansioncontext" class="md-nav__link">
    <span class="md-ellipsis">
      DSLExpansionContext
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_network_dsldata-dictstr-any-network" class="md-nav__link">
    <span class="md-ellipsis">
      expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsparse" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.dsl.blueprints.parse
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.parse">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check_adjacency_keysadj_def-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_adjacency_keys(adj_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_link_paramslink_params-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_link_params(link_params: 'Dict[str, Any]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_name_patternsname-str-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      expand_name_patterns(name: 'str') -&gt; 'List[str]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_pathsparent_path-str-rel_path-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsartifacts" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.artifacts
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.artifacts">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      CapacityEnvelope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepatternresult" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePatternResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      PlacementEnvelope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementresultset" class="md-nav__link">
    <span class="md-ellipsis">
      PlacementResultSet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowentry" class="md-nav__link">
    <span class="md-ellipsis">
      FlowEntry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      FlowIterationResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowsummary_1" class="md-nav__link">
    <span class="md-ellipsis">
      FlowSummary
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsstore" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.store
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.store">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      Results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflowstepmetadata" class="md-nav__link">
    <span class="md-ellipsis">
      WorkflowStepMetadata
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carlofunctions" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demand_placement_analysisnetwork_view-networkview-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-kwargs-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      demand_placement_analysis(network_view: "'NetworkView'", demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-kwargs-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-kwargs-dictstr-dictstr-float" class="md-nav__link">
    <span class="md-ellipsis">
      sensitivity_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , **kwargs) -&gt; 'dict[str, dict[str, float]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carloresults" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.results
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.results">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenveloperesults" class="md-nav__link">
    <span class="md-ellipsis">
      CapacityEnvelopeResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demandplacementresults" class="md-nav__link">
    <span class="md-ellipsis">
      DemandPlacementResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivityresults" class="md-nav__link">
    <span class="md-ellipsis">
      SensitivityResults
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carlotypes" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowresult" class="md-nav__link">
    <span class="md-ellipsis">
      FlowResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowstats" class="md-nav__link">
    <span class="md-ellipsis">
      FlowStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.profiling.profiler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.profiling.profiler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performanceprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      PerformanceProfiler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performancereporter" class="md-nav__link">
    <span class="md-ellipsis">
      PerformanceReporter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profileresults" class="md-nav__link">
    <span class="md-ellipsis">
      ProfileResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stepprofile" class="md-nav__link">
    <span class="md-ellipsis">
      StepProfile
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingreporter" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.profiling.reporter
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsids" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.utils.ids
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.ids">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#new_base64_uuid-str" class="md-nav__link">
    <span class="md-ellipsis">
      new_base64_uuid() -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsoutput_paths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.utils.output_paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.output_paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" class="md-nav__link">
    <span class="md-ellipsis">
      build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ensure_parent_dirpath-path-none" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_parent_dir(path: 'Path') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scenario_prefix_from_pathscenario_path-path-str" class="md-nav__link">
    <span class="md-ellipsis">
      scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#error-handling" class="md-nav__link">
    <span class="md-ellipsis">
      Error Handling
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ngraphcli" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.cli
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.cli">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mainargv-optionalliststr-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      main(argv: 'Optional[List[str]]' = None) -&gt; 'None'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphcomponents" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.components
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.components">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#component" class="md-nav__link">
    <span class="md-ellipsis">
      Component
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#componentslibrary" class="md-nav__link">
    <span class="md-ellipsis">
      ComponentsLibrary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" class="md-nav__link">
    <span class="md-ellipsis">
      totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphconfig" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.config
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.config">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmanagerconfig" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficManagerConfig
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.explorer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.explorer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#externallinkbreakdown" class="md-nav__link">
    <span class="md-ellipsis">
      ExternalLinkBreakdown
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkcapacityissue" class="md-nav__link">
    <span class="md-ellipsis">
      LinkCapacityIssue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkExplorer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeutilization" class="md-nav__link">
    <span class="md-ellipsis">
      NodeUtilization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    <span class="md-ellipsis">
      TreeNode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treestats" class="md-nav__link">
    <span class="md-ellipsis">
      TreeStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlogging" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.logging
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.logging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#disable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      disable_debug_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      enable_debug_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_loggername-str-logginglogger" class="md-nav__link">
    <span class="md-ellipsis">
      get_logger(name: str) -&gt; logging.Logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      reset_logging() -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_global_log_levellevel-int-none" class="md-nav__link">
    <span class="md-ellipsis">
      set_global_log_level(level: int) -&gt; None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphscenario" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.scenario
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.scenario">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario" class="md-nav__link">
    <span class="md-ellipsis">
      Scenario
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphseed_manager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.seed_manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.seed_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seedmanager" class="md-nav__link">
    <span class="md-ellipsis">
      SeedManager
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphyaml_utils" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.yaml_utils
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.yaml_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" class="md-nav__link">
    <span class="md-ellipsis">
      normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphconvert" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.convert
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.convert">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#from_digraphnx_graph-networkxclassesdigraphdigraph-ngraphgraphstrict_multidigraphstrictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      from_digraph(nx_graph: networkx.classes.digraph.DiGraph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#from_graphnx_graph-networkxclassesgraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      from_graph(nx_graph: networkx.classes.graph.Graph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_digraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesdigraphdigraph" class="md-nav__link">
    <span class="md-ellipsis">
      to_digraph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.digraph.DiGraph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_graphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesgraphgraph" class="md-nav__link">
    <span class="md-ellipsis">
      to_graph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.graph.Graph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphio" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.io
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.io">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgelist_to_graphlines-iterablestr-columns-liststr-separator-str-graph-optionalstrictmultidigraph-none-source-str-src-target-str-dst-key-str-key-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      edgelist_to_graph(lines: 'Iterable[str]', columns: 'List[str]', separator: 'str' = ' ', graph: 'Optional[StrictMultiDiGraph]' = None, source: 'str' = 'src', target: 'str' = 'dst', key: 'str' = 'key') -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph_to_edgelistgraph-strictmultidigraph-columns-optionalliststr-none-separator-str-source_col-str-src-target_col-str-dst-key_col-str-key-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      graph_to_edgelist(graph: 'StrictMultiDiGraph', columns: 'Optional[List[str]]' = None, separator: 'str' = ' ', source_col: 'str' = 'src', target_col: 'str' = 'dst', key_col: 'str' = 'key') -&gt; 'List[str]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graph_to_node_linkgraph-strictmultidigraph-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      graph_to_node_link(graph: 'StrictMultiDiGraph') -&gt; 'Dict[str, Any]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node_link_to_graphdata-dictstr-any-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      node_link_to_graph(data: 'Dict[str, Any]') -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphgraphstrict_multidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.graph.strict_multidigraph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.graph.strict_multidigraph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      StrictMultiDiGraph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelnetwork" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.model.network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      Link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      Node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      RiskGroup
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelview" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.model.view
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.view">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkview" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkView
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsbase" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.base
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeselect" class="md-nav__link">
    <span class="md-ellipsis">
      EdgeSelect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowplacement" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPlacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pathalg" class="md-nav__link">
    <span class="md-ellipsis">
      PathAlg
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmscapacity" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.capacity
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.capacity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#calc_graph_capacityflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-tuplefloat-dictnodeid-dictnodeid-float" class="md-nav__link">
    <span class="md-ellipsis">
      calc_graph_capacity(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow_placement: 'FlowPlacement' = , capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow') -&gt; 'Tuple[float, Dict[NodeID, Dict[NodeID, float]]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsedge_select" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.edge_select
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.edge_select">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edge_select_fabricedge_select-ngraphalgorithmsbaseedgeselect-select_value-optionalany-none-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable-none-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-cost_attr-str-cost-capacity_attr-str-capacity-flow_attr-str-flow-callablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      edge_select_fabric(edge_select: ngraph.algorithms.base.EdgeSelect, select_value: Optional[Any] = None, edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]] = None, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, cost_attr: str = 'cost', capacity_attr: str = 'capacity', flow_attr: str = 'flow') -&gt; Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsflow_init" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.flow_init
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.flow_init">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#init_flow_graphflow_graph-strictmultidigraph-flow_attr-str-flow-flows_attr-str-flows-reset_flow_graph-bool-true-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      init_flow_graph(flow_graph: 'StrictMultiDiGraph', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows', reset_flow_graph: 'bool' = True) -&gt; 'StrictMultiDiGraph'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsmax_flow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.max_flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.max_flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#calc_max_flowgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-return_summary-bool-false-return_graph-bool-false-flow_placement-ngraphalgorithmsbaseflowplacement-shortest_path-bool-false-reset_flow_graph-bool-false-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-copy_graph-bool-true-tolerance-float-1e-10-unionfloat-tuple" class="md-nav__link">
    <span class="md-ellipsis">
      calc_max_flow(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, *, return_summary: bool = False, return_graph: bool = False, flow_placement: ngraph.algorithms.base.FlowPlacement = , shortest_path: bool = False, reset_flow_graph: bool = False, capacity_attr: str = 'capacity', flow_attr: str = 'flow', flows_attr: str = 'flows', copy_graph: bool = True, tolerance: float = 1e-10) -&gt; Union[float, tuple]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#run_sensitivitygraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-change_amount-float-10-kwargs-dicttuple-float" class="md-nav__link">
    <span class="md-ellipsis">
      run_sensitivity(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, , capacity_attr: str = 'capacity', flow_attr: str = 'flow', change_amount: float = 1.0, *kwargs) -&gt; dict[tuple, float]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#saturated_edgesgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-tolerance-float-1e-10-kwargs-listtuple" class="md-nav__link">
    <span class="md-ellipsis">
      saturated_edges(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, , capacity_attr: str = 'capacity', flow_attr: str = 'flow', tolerance: float = 1e-10, *kwargs) -&gt; list[tuple]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmspaths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#resolve_to_pathssrc_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-split_parallel_edges-bool-false-iteratorpathtuple" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_to_paths(src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', split_parallel_edges: 'bool' = False) -&gt; 'Iterator[PathTuple]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsplacement" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.placement
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.placement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowplacementmeta" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPlacementMeta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#place_flow_on_graphflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow-float-inf-flow_index-optionalhashable-none-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-flowplacementmeta" class="md-nav__link">
    <span class="md-ellipsis">
      place_flow_on_graph(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow: 'float' = inf, flow_index: 'Optional[Hashable]' = None, flow_placement: 'FlowPlacement' = , capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'FlowPlacementMeta'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_flow_from_graphflow_graph-strictmultidigraph-flow_index-optionalhashable-none-flow_attr-str-flow-flows_attr-str-flows-none" class="md-nav__link">
    <span class="md-ellipsis">
      remove_flow_from_graph(flow_graph: 'StrictMultiDiGraph', flow_index: 'Optional[Hashable]' = None, flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'None'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmsspf" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.spf
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.spf">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kspgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-max_k-optionalint-none-max_path_cost-unionint-float-inf-max_path_cost_factor-optionalfloat-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-iteratortupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      ksp(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = , edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, max_k: Optional[int] = None, max_path_cost: Union[int, float] = inf, max_path_cost_factor: Optional[float] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None) -&gt; Iterator[Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spfgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-dst_node-optionalhashable-none-tupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" class="md-nav__link">
    <span class="md-ellipsis">
      spf(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = , edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, dst_node: Optional[Hashable] = None) -&gt; Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphalgorithmstypes" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.algorithms.types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.algorithms.types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      FlowSummary
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphpathsbundle" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.paths.bundle
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.paths.bundle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pathbundle" class="md-nav__link">
    <span class="md-ellipsis">
      PathBundle
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphpathspath" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.paths.path
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.paths.path">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    <span class="md-ellipsis">
      Path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphflowsflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.flows.flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.flows.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flow" class="md-nav__link">
    <span class="md-ellipsis">
      Flow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowindex" class="md-nav__link">
    <span class="md-ellipsis">
      FlowIndex
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphflowspolicy" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.flows.policy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.flows.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPolicy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowpolicyconfig" class="md-nav__link">
    <span class="md-ellipsis">
      FlowPolicyConfig
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flow_policyflow_policy_config-flowpolicyconfig-flowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      get_flow_policy(flow_policy_config: 'FlowPolicyConfig') -&gt; 'FlowPolicy'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolverhelpers" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.helpers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolvermaxflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.maxflow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.solver.maxflow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#max_flowcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_detailedcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_detailed(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; "Dict[Tuple[str, str], Tuple[float, FlowSummary, 'StrictMultiDiGraph']]"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_with_graphcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-strictmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_with_graph(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; "Dict[Tuple[str, str], Tuple[float, 'StrictMultiDiGraph']]"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_with_summarycontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_with_summary(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], Tuple[float, FlowSummary]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#saturated_edgescontext-any-source_path-str-sink_path-str-mode-str-combine-tolerance-float-1e-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-listtuplestr-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      saturated_edges(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', tolerance: 'float' = 1e-10, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], List[Tuple[str, str, str]]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysiscontext-any-source_path-str-sink_path-str-mode-str-combine-change_amount-float-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-dicttuplestr-str-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      sensitivity_analysis(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', change_amount: 'float' = 1.0, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = ) -&gt; 'Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphsolverpaths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.solver.paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.solver.paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k_shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-pairwise-max_k-int-3-edge_select-edgeselect-max_path_cost-float-inf-max_path_cost_factor-optionalfloat-none-split_parallel_edges-bool-false-dicttuplestr-str-listpath" class="md-nav__link">
    <span class="md-ellipsis">
      k_shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'pairwise', max_k: 'int' = 3, edge_select: 'EdgeSelect' = , max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest_path_costscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-dicttuplestr-str-float" class="md-nav__link">
    <span class="md-ellipsis">
      shortest_path_costs(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = ) -&gt; 'Dict[Tuple[str, str], float]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-split_parallel_edges-bool-false-dicttuplestr-str-listpath" class="md-nav__link">
    <span class="md-ellipsis">
      shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = , split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerbuilder" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.builder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.builder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_traffic_matrix_setraw-dictstr-listdict-trafficmatrixset" class="md-nav__link">
    <span class="md-ellipsis">
      build_traffic_matrix_set(raw: 'Dict[str, List[dict]]') -&gt; 'TrafficMatrixSet'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerexpand" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.expand
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_demandsnetwork-unionnetwork-networkview-graph-strictmultidigraph-none-traffic_demands-listtrafficdemand-default_flow_policy_config-flowpolicyconfig-tuplelistdemand-dictstr-listdemand" class="md-nav__link">
    <span class="md-ellipsis">
      expand_demands(network: "Union[Network, 'NetworkView']", graph: 'StrictMultiDiGraph | None', traffic_demands: 'List[TrafficDemand]', default_flow_policy_config: 'FlowPolicyConfig') -&gt; 'Tuple[List[Demand], Dict[str, List[Demand]]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagermanager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmanager" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficManager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trafficresult" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficResult
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmanagerschedule" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.manager.schedule
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.manager.schedule">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#place_demands_round_robingraph-strictmultidigraph-demands-listdemand-placement_rounds-int-reoptimize_after_each_round-bool-false-float" class="md-nav__link">
    <span class="md-ellipsis">
      place_demands_round_robin(graph: 'StrictMultiDiGraph', demands: 'List[Demand]', placement_rounds: 'int', reoptimize_after_each_round: 'bool' = False) -&gt; 'float'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandmatrix" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.matrix
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.matrix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixset" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficMatrixSet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdemandspec" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.demand.spec
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.demand.spec">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficdemand" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficDemand
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailureconditions" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.conditions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurecondition" class="md-nav__link">
    <span class="md-ellipsis">
      FailureCondition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionentity_attrs-dictstr-any-cond-failurecondition-bool" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_condition(entity_attrs: 'dict[str, Any]', cond: 'FailureCondition') -&gt; 'bool'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionsentity_attrs-dictstr-any-conditions-iterablefailurecondition-logic-str-bool" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_conditions(entity_attrs: 'dict[str, Any]', conditions: 'Iterable[FailureCondition]', logic: 'str') -&gt; 'bool'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanageraggregate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.aggregate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagerenumerate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.enumerate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagermanager" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.manager
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.manager.manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysisfunction" class="md-nav__link">
    <span class="md-ellipsis">
      AnalysisFunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremanager" class="md-nav__link">
    <span class="md-ellipsis">
      FailureManager
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailuremanagersimulate" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.manager.simulate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.policy
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurecondition_1" class="md-nav__link">
    <span class="md-ellipsis">
      FailureCondition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremode" class="md-nav__link">
    <span class="md-ellipsis">
      FailureMode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePolicy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurerule" class="md-nav__link">
    <span class="md-ellipsis">
      FailureRule
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphfailurepolicy_set" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.failure.policy_set
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.failure.policy_set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePolicySet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbase" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.base
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#workflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      WorkflowStep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_workflow_stepstep_type-str" class="md-nav__link">
    <span class="md-ellipsis">
      register_workflow_step(step_type: 'str')
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbuild_graph" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.build_graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.build_graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buildgraph" class="md-nav__link">
    <span class="md-ellipsis">
      BuildGraph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowcost_power" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.cost_power
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.cost_power">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#costpower" class="md-nav__link">
    <span class="md-ellipsis">
      CostPower
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmax_flow_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.max_flow_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.max_flow_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxflow" class="md-nav__link">
    <span class="md-ellipsis">
      MaxFlow
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmaximum_supported_demand_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.maximum_supported_demand_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.maximum_supported_demand_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maximumsupporteddemand" class="md-nav__link">
    <span class="md-ellipsis">
      MaximumSupportedDemand
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflownetwork_stats" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.network_stats
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.network_stats">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkstats" class="md-nav__link">
    <span class="md-ellipsis">
      NetworkStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowtraffic_matrix_placement_step" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.workflow.traffic_matrix_placement_step
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.traffic_matrix_placement_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixplacement" class="md-nav__link">
    <span class="md-ellipsis">
      TrafficMatrixPlacement
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsexpand" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.dsl.blueprints.expand
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    <span class="md-ellipsis">
      Blueprint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslexpansioncontext" class="md-nav__link">
    <span class="md-ellipsis">
      DSLExpansionContext
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_network_dsldata-dictstr-any-network" class="md-nav__link">
    <span class="md-ellipsis">
      expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsparse" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.dsl.blueprints.parse
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.parse">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check_adjacency_keysadj_def-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_adjacency_keys(adj_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_link_paramslink_params-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_link_params(link_params: 'Dict[str, Any]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_name_patternsname-str-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      expand_name_patterns(name: 'str') -&gt; 'List[str]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_pathsparent_path-str-rel_path-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsartifacts" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.artifacts
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.artifacts">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      CapacityEnvelope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepatternresult" class="md-nav__link">
    <span class="md-ellipsis">
      FailurePatternResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      PlacementEnvelope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementresultset" class="md-nav__link">
    <span class="md-ellipsis">
      PlacementResultSet
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsflow" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.flow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowentry" class="md-nav__link">
    <span class="md-ellipsis">
      FlowEntry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      FlowIterationResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowsummary_1" class="md-nav__link">
    <span class="md-ellipsis">
      FlowSummary
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsstore" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.results.store
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.store">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      Results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflowstepmetadata" class="md-nav__link">
    <span class="md-ellipsis">
      WorkflowStepMetadata
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carlofunctions" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demand_placement_analysisnetwork_view-networkview-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-kwargs-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      demand_placement_analysis(network_view: "'NetworkView'", demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-kwargs-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      max_flow_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-kwargs-dictstr-dictstr-float" class="md-nav__link">
    <span class="md-ellipsis">
      sensitivity_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , **kwargs) -&gt; 'dict[str, dict[str, float]]'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carloresults" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.results
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.results">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenveloperesults" class="md-nav__link">
    <span class="md-ellipsis">
      CapacityEnvelopeResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demandplacementresults" class="md-nav__link">
    <span class="md-ellipsis">
      DemandPlacementResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivityresults" class="md-nav__link">
    <span class="md-ellipsis">
      SensitivityResults
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmonte_carlotypes" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.monte_carlo.types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.monte_carlo.types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowresult" class="md-nav__link">
    <span class="md-ellipsis">
      FlowResult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowstats" class="md-nav__link">
    <span class="md-ellipsis">
      FlowStats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.profiling.profiler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.profiling.profiler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performanceprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      PerformanceProfiler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performancereporter" class="md-nav__link">
    <span class="md-ellipsis">
      PerformanceReporter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profileresults" class="md-nav__link">
    <span class="md-ellipsis">
      ProfileResults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stepprofile" class="md-nav__link">
    <span class="md-ellipsis">
      StepProfile
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingreporter" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.profiling.reporter
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsids" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.utils.ids
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.ids">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#new_base64_uuid-str" class="md-nav__link">
    <span class="md-ellipsis">
      new_base64_uuid() -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsoutput_paths" class="md-nav__link">
    <span class="md-ellipsis">
      ngraph.utils.output_paths
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.output_paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" class="md-nav__link">
    <span class="md-ellipsis">
      build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ensure_parent_dirpath-path-none" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_parent_dir(path: 'Path') -&gt; 'None'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" class="md-nav__link">
    <span class="md-ellipsis">
      resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scenario_prefix_from_pathscenario_path-path-str" class="md-nav__link">
    <span class="md-ellipsis">
      scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#error-handling" class="md-nav__link">
    <span class="md-ellipsis">
      Error Handling
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<!-- markdownlint-disable MD007 MD032 MD029 MD050 MD004 MD052 MD012 -->

<h1 id="netgraph-api-reference-auto-generated">NetGraph API Reference (Auto-Generated)<a class="headerlink" href="#netgraph-api-reference-auto-generated" title="Permanent link">&para;</a></h1>
<p>This is the complete auto-generated API documentation for NetGraph.
For a curated, example-driven API guide, see <a href="../api/">api.md</a>.</p>
<p>Quick links:</p>
<ul>
<li><a href="../api/">Main API Guide (api.md)</a></li>
<li><a href="./">This Document (api-full.md)</a></li>
<li><a href="../cli/">CLI Reference</a></li>
<li><a href="../dsl/">DSL Reference</a></li>
</ul>
<p>Generated from source code on: September 06, 2025 at 23:54 UTC</p>
<p>Modules auto-discovered: 61</p>
<hr />
<h2 id="ngraphcli">ngraph.cli<a class="headerlink" href="#ngraphcli" title="Permanent link">&para;</a></h2>
<p>Command-line interface for NetGraph.</p>
<h3 id="mainargv-optionalliststr-none-none">main(argv: 'Optional[List[str]]' = None) -&gt; 'None'<a class="headerlink" href="#mainargv-optionalliststr-none-none" title="Permanent link">&para;</a></h3>
<p>Entry point for the <code>ngraph</code> command.</p>
<p>Args:
    argv: Optional list of command-line arguments. If <code>None</code>, <code>sys.argv</code>
        is used.</p>
<hr />
<h2 id="ngraphcomponents">ngraph.components<a class="headerlink" href="#ngraphcomponents" title="Permanent link">&para;</a></h2>
<p>Component and ComponentsLibrary classes for hardware capex/power modeling.</p>
<h3 id="component">Component<a class="headerlink" href="#component" title="Permanent link">&para;</a></h3>
<p>A generic component that can represent chassis, line cards, optics, etc.
Components can have nested children, each with their own capex, power, etc.</p>
<p>Attributes:
    name (str): Name of the component (e.g., "SpineChassis" or "400G-LR4").
    component_type (str): A string label (e.g., "chassis", "linecard", "optic").
    description (str): A human-readable description of this component.
    capex (float): Monetary capex of a single instance of this component.
    power_watts (float): Typical/nominal power usage (watts) for one instance.
    power_watts_max (float): Maximum/peak power usage (watts) for one instance.
    capacity (float): A generic capacity measure (e.g., platform capacity).
    ports (int): Number of ports if relevant for this component.
    count (int): How many identical copies of this component are present.
    attrs (Dict[str, Any]): Arbitrary key-value attributes for extra metadata.
    children (Dict[str, Component]): Nested child components (e.g., line cards
        inside a chassis), keyed by child name.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>component_type</code> (str) = generic</li>
<li><code>description</code> (str)</li>
<li><code>capex</code> (float) = 0.0</li>
<li><code>power_watts</code> (float) = 0.0</li>
<li><code>power_watts_max</code> (float) = 0.0</li>
<li><code>capacity</code> (float) = 0.0</li>
<li><code>ports</code> (int) = 0</li>
<li><code>count</code> (int) = 1</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>children</code> (Dict[str, Component]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>as_dict(self, include_children: 'bool' = True) -&gt; 'Dict[str, Any]'</code> - Returns a dictionary containing all properties of this component.</li>
<li><code>total_capacity(self) -&gt; 'float'</code> - Computes the total (recursive) capacity of this component,</li>
<li><code>total_capex(self) -&gt; 'float'</code> - Computes total capex including children, multiplied by count.</li>
<li><code>total_power(self) -&gt; 'float'</code> - Computes the total <em>typical</em> (recursive) power usage of this component,</li>
<li><code>total_power_max(self) -&gt; 'float'</code> - Computes the total <em>peak</em> (recursive) power usage of this component,</li>
</ul>
<h3 id="componentslibrary">ComponentsLibrary<a class="headerlink" href="#componentslibrary" title="Permanent link">&para;</a></h3>
<p>Holds a collection of named Components. Each entry is a top-level "template"
that can be referenced for cost/power/capacity lookups, possibly with nested children.</p>
<p>Example (YAML-like):
    components:
      BigSwitch:
        component_type: chassis
        cost: 20000
        power_watts: 1750
        capacity: 25600
        children:
          PIM16Q-16x200G:
            component_type: linecard
            cost: 1000
            power_watts: 10
            ports: 16
            count: 8
      200G-FR4:
        component_type: optic
        cost: 2000
        power_watts: 6
        power_watts_max: 6.5</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>components</code> (Dict[str, Component]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>clone(self) -&gt; 'ComponentsLibrary'</code> - Creates a deep copy of this ComponentsLibrary.</li>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; 'ComponentsLibrary'</code> - Constructs a ComponentsLibrary from a dictionary of raw component definitions.</li>
<li><code>from_yaml(yaml_str: 'str') -&gt; 'ComponentsLibrary'</code> - Constructs a ComponentsLibrary from a YAML string. If the YAML contains</li>
<li><code>get(self, name: 'str') -&gt; 'Optional[Component]'</code> - Retrieves a Component by its name from the library.</li>
<li><code>merge(self, other: 'ComponentsLibrary', override: 'bool' = True) -&gt; 'ComponentsLibrary'</code> - Merges another ComponentsLibrary into this one. By default (override=True),</li>
</ul>
<h3 id="resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool">resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'<a class="headerlink" href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" title="Permanent link">&para;</a></h3>
<p>Resolve per-end hardware components for a link.</p>
<p>Input format inside <code>link.attrs</code>:</p>
<p>Structured mapping under <code>hardware</code> key only:
  <code>{"hardware": {"source": {"component": NAME, "count": N},
                   "target": {"component": NAME, "count": N}}}</code></p>
<p>Args:
    attrs: Link attributes mapping.
    library: Components library for lookups.</p>
<p>Exclusive usage:</p>
<ul>
<li>
<p>Optional <code>exclusive: true</code> per end indicates unsharable usage.</p>
<p>For exclusive ends, validation and BOM counting should round-up counts
to integers.</p>
</li>
</ul>
<p>Returns:
    ((src_comp, src_count, src_exclusive), (dst_comp, dst_count, dst_exclusive), per_end_specified)
    where components may be <code>None</code> if name is absent/unknown. <code>per_end_specified</code>
    is True when a structured per-end mapping is present.</p>
<h3 id="resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float">resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'<a class="headerlink" href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" title="Permanent link">&para;</a></h3>
<p>Resolve node hardware from <code>attrs['hardware']</code>.</p>
<p>Expects the mapping: <code>{"hardware": {"component": NAME, "count": N}}</code>.
<code>count</code> defaults to 1 if missing or invalid. If <code>component</code> is missing
or unknown, returns <code>(None, 1.0)</code>.</p>
<p>Args:
    attrs: Node attributes mapping.
    library: Component library used for lookups.</p>
<p>Returns:
    Tuple of (component or None, positive multiplier).</p>
<h3 id="totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float">totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'<a class="headerlink" href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" title="Permanent link">&para;</a></h3>
<p>Return (capex, power_watts, capacity) totals multiplied by <code>hw_count</code>.</p>
<p>Args:
    comp: Component definition (may include nested children and internal <code>count</code>).
    hw_count: External multiplier (e.g., number of modules used for a link or node).</p>
<p>Returns:
    Tuple of total capex, total power (typical), and total capacity as floats.</p>
<hr />
<h2 id="ngraphconfig">ngraph.config<a class="headerlink" href="#ngraphconfig" title="Permanent link">&para;</a></h2>
<p>Configuration classes for NetGraph components.</p>
<h3 id="trafficmanagerconfig">TrafficManagerConfig<a class="headerlink" href="#trafficmanagerconfig" title="Permanent link">&para;</a></h3>
<p>Configuration for traffic demand placement estimation.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>default_rounds</code> (int) = 5</li>
<li><code>min_rounds</code> (int) = 5</li>
<li><code>max_rounds</code> (int) = 100</li>
<li><code>ratio_base</code> (int) = 5</li>
<li><code>ratio_multiplier</code> (int) = 5</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>estimate_rounds(self, demand_capacity_ratio: float) -&gt; int</code> - Calculate placement rounds based on demand to capacity ratio.</li>
</ul>
<hr />
<h2 id="ngraphexplorer">ngraph.explorer<a class="headerlink" href="#ngraphexplorer" title="Permanent link">&para;</a></h2>
<p>NetworkExplorer class for analyzing network hierarchy and structure.</p>
<h3 id="externallinkbreakdown">ExternalLinkBreakdown<a class="headerlink" href="#externallinkbreakdown" title="Permanent link">&para;</a></h3>
<p>Holds stats for external links to a particular other subtree.</p>
<p>Attributes:
    link_count (int): Number of links to that other subtree.
    link_capacity (float): Sum of capacities for those links.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>link_count</code> (int) = 0</li>
<li><code>link_capacity</code> (float) = 0.0</li>
</ul>
<h3 id="linkcapacityissue">LinkCapacityIssue<a class="headerlink" href="#linkcapacityissue" title="Permanent link">&para;</a></h3>
<p>Represents a link capacity constraint violation in active topology.</p>
<p>Attributes:
    source: Source node name.
    target: Target node name.
    capacity: Configured link capacity.
    limit: Effective capacity limit from per-end hardware (min of ends).
    reason: Brief reason tag.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>target</code> (str)</li>
<li><code>capacity</code> (float)</li>
<li><code>limit</code> (float)</li>
<li><code>reason</code> (str)</li>
</ul>
<h3 id="networkexplorer">NetworkExplorer<a class="headerlink" href="#networkexplorer" title="Permanent link">&para;</a></h3>
<p>Provides hierarchical exploration of a Network, computing statistics in two modes:
'all' (ignores disabled) and 'active' (only enabled).</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>explore_network(network: 'Network', components_library: 'Optional[ComponentsLibrary]' = None, strict_validation: 'bool' = True) -&gt; 'NetworkExplorer'</code> - Build a NetworkExplorer, constructing a tree plus 'all' and 'active' stats.</li>
<li><code>get_bom(self, include_disabled: 'bool' = True) -&gt; 'Dict[str, float]'</code> - Return aggregated hardware BOM for the whole network.</li>
<li><code>get_bom_by_path(self, path: 'str', include_disabled: 'bool' = True) -&gt; 'Dict[str, float]'</code> - Return the hardware BOM for a specific hierarchy path.</li>
<li><code>get_bom_map(self, include_disabled: 'bool' = True, include_root: 'bool' = True, root_label: 'str' = '') -&gt; 'Dict[str, Dict[str, float]]'</code> - Return a mapping from hierarchy path to BOM for each subtree.</li>
<li><code>get_link_issues(self) -&gt; 'List[LinkCapacityIssue]'</code> - Return recorded link capacity issues discovered in non-strict mode.</li>
<li><code>get_node_utilization(self, include_disabled: 'bool' = True) -&gt; 'List[NodeUtilization]'</code> - Return hardware utilization per node based on active topology.</li>
<li><code>print_tree(self, node: 'Optional[TreeNode]' = None, indent: 'int' = 0, max_depth: 'Optional[int]' = None, skip_leaves: 'bool' = False, detailed: 'bool' = False, include_disabled: 'bool' = True, max_external_lines: 'Optional[int]' = None, line_prefix: 'str' = '') -&gt; 'None'</code> - Print the hierarchy from 'node' down (default: root).</li>
</ul>
<h3 id="nodeutilization">NodeUtilization<a class="headerlink" href="#nodeutilization" title="Permanent link">&para;</a></h3>
<p>Per-node hardware utilization snapshot based on active topology.</p>
<p>Attributes:
    node_name: Fully qualified node name.
    component_name: Hardware component name if present.
    hw_count: Hardware multiplicity used for capacity/power scaling.
    capacity_supported: Total capacity supported by node hardware.
    attached_capacity_active: Sum of capacities of enabled adjacent links where the
        opposite endpoint is also enabled.
    capacity_utilization: Ratio of attached to supported capacity (0.0 when N/A).
    ports_available: Total port equivalents available on the node (0.0 when N/A).
    ports_used: Sum of port equivalents used by per-end link optics attached to this
        node on active links.
    ports_utilization: Ratio of used to available ports (0.0 when N/A).
    capacity_violation: True if attached capacity exceeds supported capacity.
    ports_violation: True if used ports exceed available ports.
    disabled: True if the node itself is disabled.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>node_name</code> (str)</li>
<li><code>component_name</code> (Optional[str])</li>
<li><code>hw_count</code> (float)</li>
<li><code>capacity_supported</code> (float)</li>
<li><code>attached_capacity_active</code> (float)</li>
<li><code>capacity_utilization</code> (float)</li>
<li><code>ports_available</code> (float)</li>
<li><code>ports_used</code> (float)</li>
<li><code>ports_utilization</code> (float)</li>
<li><code>capacity_violation</code> (bool)</li>
<li><code>ports_violation</code> (bool)</li>
<li><code>disabled</code> (bool)</li>
</ul>
<h3 id="treenode">TreeNode<a class="headerlink" href="#treenode" title="Permanent link">&para;</a></h3>
<p>Represents a node in the hierarchical tree.</p>
<p>Attributes:
    name (str): Name/label of this node.
    parent (Optional[TreeNode]): Pointer to the parent tree node.
    children (Dict[str, TreeNode]): Mapping of child name -&gt; child TreeNode.
    subtree_nodes (Set[str]): Node names in the subtree (all nodes, ignoring disabled).
    active_subtree_nodes (Set[str]): Node names in the subtree (only enabled).
    stats (TreeStats): Aggregated stats for "all" view.
    active_stats (TreeStats): Aggregated stats for "active" (only enabled) view.
    raw_nodes (List[Node]): Direct Node objects at this hierarchy level.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>parent</code> (Optional[TreeNode])</li>
<li><code>children</code> (Dict[str, TreeNode]) = {}</li>
<li><code>subtree_nodes</code> (Set[str]) = set()</li>
<li><code>active_subtree_nodes</code> (Set[str]) = set()</li>
<li><code>stats</code> (TreeStats) = TreeStats(node_count=0, internal_link_count=0, internal_link_capacity=0.0, external_link_count=0, external_link_capacity=0.0, external_link_details={}, total_capex=0.0, total_power=0.0, bom={}, active_bom={})</li>
<li><code>active_stats</code> (TreeStats) = TreeStats(node_count=0, internal_link_count=0, internal_link_capacity=0.0, external_link_count=0, external_link_capacity=0.0, external_link_details={}, total_capex=0.0, total_power=0.0, bom={}, active_bom={})</li>
<li><code>raw_nodes</code> (List[Node]) = []</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add_child(self, child_name: 'str') -&gt; 'TreeNode'</code> - Ensure a child node named 'child_name' exists and return it.</li>
<li><code>is_leaf(self) -&gt; 'bool'</code> - Return True if this node has no children.</li>
</ul>
<h3 id="treestats">TreeStats<a class="headerlink" href="#treestats" title="Permanent link">&para;</a></h3>
<p>Aggregated statistics for a single tree node (subtree).</p>
<p>Attributes:
    node_count (int): Total number of nodes in this subtree.
    internal_link_count (int): Number of internal links in this subtree.
    internal_link_capacity (float): Sum of capacities for those internal links.
    external_link_count (int): Number of external links from this subtree to another.
    external_link_capacity (float): Sum of capacities for those external links.
    external_link_details (Dict[str, ExternalLinkBreakdown]): Breakdown by other subtree path.
    total_capex (float): Cumulative capex (nodes + links).
    total_power (float): Cumulative power (nodes + links).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>node_count</code> (int) = 0</li>
<li><code>internal_link_count</code> (int) = 0</li>
<li><code>internal_link_capacity</code> (float) = 0.0</li>
<li><code>external_link_count</code> (int) = 0</li>
<li><code>external_link_capacity</code> (float) = 0.0</li>
<li><code>external_link_details</code> (Dict[str, ExternalLinkBreakdown]) = {}</li>
<li><code>total_capex</code> (float) = 0.0</li>
<li><code>total_power</code> (float) = 0.0</li>
<li><code>bom</code> (Dict[str, float]) = {}</li>
<li><code>active_bom</code> (Dict[str, float]) = {}</li>
</ul>
<hr />
<h2 id="ngraphlogging">ngraph.logging<a class="headerlink" href="#ngraphlogging" title="Permanent link">&para;</a></h2>
<p>Centralized logging configuration for NetGraph.</p>
<h3 id="disable_debug_logging-none">disable_debug_logging() -&gt; None<a class="headerlink" href="#disable_debug_logging-none" title="Permanent link">&para;</a></h3>
<p>Disable debug logging, set to INFO level.</p>
<h3 id="enable_debug_logging-none">enable_debug_logging() -&gt; None<a class="headerlink" href="#enable_debug_logging-none" title="Permanent link">&para;</a></h3>
<p>Enable debug logging for the entire package.</p>
<h3 id="get_loggername-str-logginglogger">get_logger(name: str) -&gt; logging.Logger<a class="headerlink" href="#get_loggername-str-logginglogger" title="Permanent link">&para;</a></h3>
<p>Get a logger with NetGraph's standard configuration.</p>
<p>This is the main function that should be used throughout the package.
All loggers will inherit from the root 'ngraph' logger configuration.</p>
<p>Args:
    name: Logger name (typically <strong>name</strong> from calling module).</p>
<p>Returns:
    Configured logger instance.</p>
<h3 id="reset_logging-none">reset_logging() -&gt; None<a class="headerlink" href="#reset_logging-none" title="Permanent link">&para;</a></h3>
<p>Reset logging configuration (mainly for testing).</p>
<h3 id="set_global_log_levellevel-int-none">set_global_log_level(level: int) -&gt; None<a class="headerlink" href="#set_global_log_levellevel-int-none" title="Permanent link">&para;</a></h3>
<p>Set the log level for all NetGraph loggers.</p>
<p>Args:
    level: Logging level (e.g., logging.DEBUG, logging.INFO).</p>
<h3 id="setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none">setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None<a class="headerlink" href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" title="Permanent link">&para;</a></h3>
<p>Set up the root NetGraph logger with a single handler.</p>
<p>This should only be called once to avoid duplicate handlers.</p>
<p>Args:
    level: Logging level (default: INFO).
    format_string: Custom format string (optional).
    handler: Custom handler (optional, defaults to StreamHandler).</p>
<hr />
<h2 id="ngraphscenario">ngraph.scenario<a class="headerlink" href="#ngraphscenario" title="Permanent link">&para;</a></h2>
<p>Scenario class for defining network analysis workflows from YAML.</p>
<h3 id="scenario">Scenario<a class="headerlink" href="#scenario" title="Permanent link">&para;</a></h3>
<p>Represents a complete scenario for building and executing network workflows.</p>
<p>This scenario includes:</p>
<ul>
<li>A network (nodes/links), constructed via blueprint expansion.</li>
<li>A failure policy set (one or more named failure policies).</li>
<li>A traffic matrix set containing one or more named traffic matrices.</li>
<li>A list of workflow steps to execute.</li>
<li>A results container for storing outputs.</li>
<li>A components_library for hardware/optics definitions.</li>
<li>A seed for reproducible random operations (optional).</li>
</ul>
<p>Typical usage example:</p>
<div class="language-text highlight"><pre><span></span><code>scenario = Scenario.from_yaml(yaml_str, default_components=default_lib)
scenario.run()
# Inspect scenario.results
</code></pre></div>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>network</code> (Network)</li>
<li><code>workflow</code> (List[WorkflowStep])</li>
<li><code>failure_policy_set</code> (FailurePolicySet) = FailurePolicySet(policies={})</li>
<li><code>traffic_matrix_set</code> (TrafficMatrixSet) = TrafficMatrixSet(matrices={})</li>
<li><code>results</code> (Results) = Results(_store={}, _metadata={}, _active_step=None, _scenario={})</li>
<li><code>components_library</code> (ComponentsLibrary) = ComponentsLibrary(components={})</li>
<li><code>seed</code> (Optional[int])</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_yaml(yaml_str: 'str', default_components: 'Optional[ComponentsLibrary]' = None) -&gt; 'Scenario'</code> - Constructs a Scenario from a YAML string, optionally merging</li>
<li><code>run(self) -&gt; 'None'</code> - Executes the scenario's workflow steps in order.</li>
</ul>
<hr />
<h2 id="ngraphseed_manager">ngraph.seed_manager<a class="headerlink" href="#ngraphseed_manager" title="Permanent link">&para;</a></h2>
<p>Deterministic seed derivation to avoid global random.seed() order dependencies.</p>
<h3 id="seedmanager">SeedManager<a class="headerlink" href="#seedmanager" title="Permanent link">&para;</a></h3>
<p>Manages deterministic seed derivation for isolated component reproducibility.</p>
<p>Global random.seed() creates order dependencies and component interference.
SeedManager derives unique seeds per component from a master seed using SHA-256,
ensuring reproducible results regardless of execution order or parallelism.</p>
<p>Usage:
    seed_mgr = SeedManager(42)
    failure_seed = seed_mgr.derive_seed("failure_policy", "default")</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>create_random_state(self, *components: 'Any') -&gt; 'random.Random'</code> - Create a new Random instance with derived seed.</li>
<li><code>derive_seed(self, *components: 'Any') -&gt; 'Optional[int]'</code> - Derive a deterministic seed from master seed and component identifiers.</li>
<li><code>seed_global_random(self, *components: 'Any') -&gt; 'None'</code> - Seed the global random module with derived seed.</li>
</ul>
<hr />
<h2 id="ngraphyaml_utils">ngraph.yaml_utils<a class="headerlink" href="#ngraphyaml_utils" title="Permanent link">&para;</a></h2>
<p>Utilities for handling YAML parsing quirks and common operations.</p>
<h3 id="normalize_yaml_dict_keysdata-dictany-v-dictstr-v">normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]<a class="headerlink" href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" title="Permanent link">&para;</a></h3>
<p>Normalize dictionary keys from YAML parsing to ensure consistent string keys.</p>
<p>YAML 1.1 boolean keys (e.g., true, false, yes, no, on, off) get converted to
Python True/False boolean values. This function converts them to predictable
string representations ("True"/"False") and ensures all keys are strings.</p>
<p>Args:
    data: Dictionary that may contain boolean or other non-string keys from YAML parsing</p>
<p>Returns:
    Dictionary with all keys converted to strings, boolean keys converted to "True"/"False"</p>
<p>Examples:
    &gt;&gt;&gt; normalize_yaml_dict_keys({True: "value1", False: "value2", "normal": "value3"})
    {"True": "value1", "False": "value2", "normal": "value3"}</p>
<div class="language-text highlight"><pre><span></span><code>&gt;&gt;&gt; # In YAML: true:, yes:, on: all become Python True
&gt;&gt;&gt; # In YAML: false:, no:, off: all become Python False
</code></pre></div>
<hr />
<h2 id="ngraphgraphconvert">ngraph.graph.convert<a class="headerlink" href="#ngraphgraphconvert" title="Permanent link">&para;</a></h2>
<p>Graph conversion utilities between StrictMultiDiGraph and NetworkX graphs.</p>
<p>Functions in this module consolidate or expand multi-edges and can preserve
original edge data for reversion through a special <code>_uv_edges</code> attribute.</p>
<h3 id="from_digraphnx_graph-networkxclassesdigraphdigraph-ngraphgraphstrict_multidigraphstrictmultidigraph">from_digraph(nx_graph: networkx.classes.digraph.DiGraph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph<a class="headerlink" href="#from_digraphnx_graph-networkxclassesdigraphdigraph-ngraphgraphstrict_multidigraphstrictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Convert a revertible NetworkX DiGraph to a StrictMultiDiGraph.</p>
<p>This function reconstructs the original StrictMultiDiGraph by restoring
multi-edge information from the '_uv_edges' attribute of each edge.</p>
<p>Args:
    nx_graph: A revertible NetworkX DiGraph with <code>_uv_edges</code> attributes.</p>
<p>Returns:
    A StrictMultiDiGraph reconstructed from the input DiGraph.</p>
<h3 id="from_graphnx_graph-networkxclassesgraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph">from_graph(nx_graph: networkx.classes.graph.Graph) -&gt; ngraph.graph.strict_multidigraph.StrictMultiDiGraph<a class="headerlink" href="#from_graphnx_graph-networkxclassesgraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Convert a revertible NetworkX Graph to a StrictMultiDiGraph.</p>
<p>Restores the original multi-edge structure from the '_uv_edges' attribute stored
in each consolidated edge.</p>
<p>Args:
    nx_graph: A revertible NetworkX Graph with <code>_uv_edges</code> attributes.</p>
<p>Returns:
    A StrictMultiDiGraph reconstructed from the input Graph.</p>
<h3 id="to_digraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesdigraphdigraph">to_digraph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.digraph.DiGraph<a class="headerlink" href="#to_digraphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesdigraphdigraph" title="Permanent link">&para;</a></h3>
<p>Convert a StrictMultiDiGraph to a NetworkX DiGraph.</p>
<p>This function consolidates multi-edges between nodes into a single edge.
Optionally, a custom edge function can be provided to compute edge attributes.
If <code>revertible</code> is True, the original multi-edge data is stored in the '_uv_edges'
attribute of each consolidated edge, allowing for later reversion.</p>
<p>Args:
    graph: The StrictMultiDiGraph to convert.
    edge_func: Optional function to compute consolidated edge attributes.
        The callable receives <code>(graph, u, v, edges)</code> and returns a dict.
    revertible: If True, store the original multi-edge data for reversion.</p>
<p>Returns:
    A NetworkX DiGraph representing the input graph.</p>
<h3 id="to_graphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesgraphgraph">to_graph(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, edge_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, dict], dict]] = None, revertible: bool = True) -&gt; networkx.classes.graph.Graph<a class="headerlink" href="#to_graphgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-edge_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dict-dict-none-revertible-bool-true-networkxclassesgraphgraph" title="Permanent link">&para;</a></h3>
<p>Convert a StrictMultiDiGraph to a NetworkX Graph.</p>
<p>This function works similarly to <code>to_digraph</code> but returns an undirected graph.</p>
<p>Args:
    graph: The StrictMultiDiGraph to convert.
    edge_func: Optional function to compute consolidated edge attributes.
    revertible: If True, store the original multi-edge data for reversion.</p>
<p>Returns:
    A NetworkX Graph representing the input graph.</p>
<hr />
<h2 id="ngraphgraphio">ngraph.graph.io<a class="headerlink" href="#ngraphgraphio" title="Permanent link">&para;</a></h2>
<p>Graph serialization functions for node-link and edge-list formats.</p>
<h3 id="edgelist_to_graphlines-iterablestr-columns-liststr-separator-str-graph-optionalstrictmultidigraph-none-source-str-src-target-str-dst-key-str-key-strictmultidigraph">edgelist_to_graph(lines: 'Iterable[str]', columns: 'List[str]', separator: 'str' = ' ', graph: 'Optional[StrictMultiDiGraph]' = None, source: 'str' = 'src', target: 'str' = 'dst', key: 'str' = 'key') -&gt; 'StrictMultiDiGraph'<a class="headerlink" href="#edgelist_to_graphlines-iterablestr-columns-liststr-separator-str-graph-optionalstrictmultidigraph-none-source-str-src-target-str-dst-key-str-key-strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Build or update a StrictMultiDiGraph from an edge list.</p>
<p>Each line in the input is split by the specified separator into tokens. These tokens
are mapped to column names provided in <code>columns</code>. The tokens corresponding to <code>source</code>
and <code>target</code> become the node IDs. If a <code>key</code> column exists, its token is used as the edge
ID; remaining tokens are added as edge attributes.</p>
<p>Args:
    lines: An iterable of strings, each representing one edge.
    columns: A list of column names, e.g. ["src", "dst", "cost"].
    separator: The separator used to split each line (default is a space).
    graph: An existing StrictMultiDiGraph to update; if None, a new graph is created.
    source: The column name for the source node ID.
    target: The column name for the target node ID.
    key: The column name for a custom edge ID (if present).</p>
<p>Returns:
    The updated (or newly created) StrictMultiDiGraph.</p>
<p>Raises:
    RuntimeError: If a line does not match the expected number of columns.</p>
<h3 id="graph_to_edgelistgraph-strictmultidigraph-columns-optionalliststr-none-separator-str-source_col-str-src-target_col-str-dst-key_col-str-key-liststr">graph_to_edgelist(graph: 'StrictMultiDiGraph', columns: 'Optional[List[str]]' = None, separator: 'str' = ' ', source_col: 'str' = 'src', target_col: 'str' = 'dst', key_col: 'str' = 'key') -&gt; 'List[str]'<a class="headerlink" href="#graph_to_edgelistgraph-strictmultidigraph-columns-optionalliststr-none-separator-str-source_col-str-src-target_col-str-dst-key_col-str-key-liststr" title="Permanent link">&para;</a></h3>
<p>Convert a StrictMultiDiGraph into an edge-list text representation.</p>
<p>Each line in the output represents one edge with tokens joined by the given separator.
By default, the output columns are:
    [source_col, target_col, key_col] + sorted(edge_attribute_names)</p>
<p>If an explicit list of columns is provided, those columns (in that order) are used,
and any missing values are output as an empty string.</p>
<p>Args:
    graph: The StrictMultiDiGraph to export.
    columns: Optional list of column names. If None, they are auto-generated.
    separator: The string used to join tokens (default is a space).
    source_col: The column name for the source node (default "src").
    target_col: The column name for the target node (default "dst").
    key_col: The column name for the edge key (default "key").</p>
<p>Returns:
    A list of strings, each representing one edge in the specified column format.</p>
<h3 id="graph_to_node_linkgraph-strictmultidigraph-dictstr-any">graph_to_node_link(graph: 'StrictMultiDiGraph') -&gt; 'Dict[str, Any]'<a class="headerlink" href="#graph_to_node_linkgraph-strictmultidigraph-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Convert a StrictMultiDiGraph into a node-link dict representation.</p>
<p>This representation is suitable for JSON serialization (e.g., for D3.js or Nx formats).</p>
<p>The returned dict has the following structure:
    {
        "graph": { ... top-level graph attributes ... },
        "nodes": [
            {"id": node_id, "attr": { ... node attributes ... }},
            ...
        ],
        "links": [
            {
                "source": <indexed_node>,
                "target": <indexed_node>,
                "key": <edge_id>,
                "attr": { ... edge attributes ... }
            },
            ...
        ]
    }</p>
<p>Args:
    graph: The StrictMultiDiGraph to convert.</p>
<p>Returns:
    A dict containing the 'graph' attributes, list of 'nodes', and list of 'links'.</p>
<h3 id="node_link_to_graphdata-dictstr-any-strictmultidigraph">node_link_to_graph(data: 'Dict[str, Any]') -&gt; 'StrictMultiDiGraph'<a class="headerlink" href="#node_link_to_graphdata-dictstr-any-strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Reconstruct a StrictMultiDiGraph from its node-link dict representation.</p>
<p>Expected input format:
    {
        "graph": { ... graph attributes ... },
        "nodes": [
            {"id": <node_id>, "attr": { ... node attributes ... }},
            ...
        ],
        "links": [
            {
                "source": <indexed_node>,
                "target": <indexed_node>,
                "key": <edge_id>,
                "attr": { ... edge attributes ... }
            },
            ...
        ]
    }</p>
<p>Args:
    data: A dict representing the node-link structure.</p>
<p>Returns:
    A StrictMultiDiGraph reconstructed from the provided data.</p>
<p>Raises:
    KeyError: If required keys (e.g., "id" or "attr" on nodes) are missing.</p>
<hr />
<h2 id="ngraphgraphstrict_multidigraph">ngraph.graph.strict_multidigraph<a class="headerlink" href="#ngraphgraphstrict_multidigraph" title="Permanent link">&para;</a></h2>
<p>Strict multi-directed graph with validation and convenience APIs.</p>
<p><code>StrictMultiDiGraph</code> extends <code>networkx.MultiDiGraph</code> to enforce explicit node
management, unique edge identifiers, and predictable error handling. It exposes
helpers to access nodes/edges as dictionaries and to serialize in node-link
format via <code>to_dict()</code>.</p>
<h3 id="strictmultidigraph">StrictMultiDiGraph<a class="headerlink" href="#strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>A custom multi-directed graph with strict rules and unique edge IDs.</p>
<p>This class enforces:</p>
<ul>
<li>No automatic creation of missing nodes when adding an edge.</li>
<li>No duplicate nodes (raises ValueError on duplicates).</li>
<li>No duplicate edges by key (raises ValueError on duplicates).</li>
<li>Removing non-existent nodes or edges raises ValueError.</li>
<li>
<p>Each edge key must be unique; by default, a Base64-UUID is generated</p>
<p>if none is provided.</p>
</li>
<li>
<p><code>copy()</code> can perform a pickle-based deep copy that may be faster</p>
<p>than the NetworkX default.</p>
</li>
</ul>
<p>Inherits from:
    networkx.MultiDiGraph</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add_edge(self, u_for_edge: 'NodeID', v_for_edge: 'NodeID', key: 'Optional[EdgeID]' = None, **attr: 'Any') -&gt; 'EdgeID'</code> - Add a directed edge from u_for_edge to v_for_edge.</li>
<li><code>add_edges_from(self, ebunch_to_add, **attr)</code> - Add all the edges in ebunch_to_add.</li>
<li><code>add_node(self, node_for_adding: 'NodeID', **attr: 'Any') -&gt; 'None'</code> - Add a single node, disallowing duplicates.</li>
<li><code>add_nodes_from(self, nodes_for_adding, **attr)</code> - Add multiple nodes.</li>
<li><code>add_weighted_edges_from(self, ebunch_to_add, weight='weight', **attr)</code> - Add weighted edges in <code>ebunch_to_add</code> with specified weight attr</li>
<li><code>adjacency(self)</code> - Returns an iterator over (node, adjacency dict) tuples for all nodes.</li>
<li><code>clear(self)</code> - Remove all nodes and edges from the graph.</li>
<li><code>clear_edges(self)</code> - Remove all edges from the graph without altering nodes.</li>
<li><code>copy(self, as_view: 'bool' = False, pickle: 'bool' = True) -&gt; 'StrictMultiDiGraph'</code> - Create a copy of this graph.</li>
<li><code>edge_subgraph(self, edges)</code> - Returns the subgraph induced by the specified edges.</li>
<li><code>edges_between(self, u: 'NodeID', v: 'NodeID') -&gt; 'List[EdgeID]'</code> - List all edge keys from node u to node v.</li>
<li><code>get_edge_attr(self, key: 'EdgeID') -&gt; 'AttrDict'</code> - Retrieve the attribute dictionary of a specific edge.</li>
<li><code>get_edge_data(self, u, v, key=None, default=None)</code> - Returns the attribute dictionary associated with edge (u, v,</li>
<li><code>get_edges(self) -&gt; 'Dict[EdgeID, EdgeTuple]'</code> - Retrieve a dictionary of all edges by their keys.</li>
<li><code>get_nodes(self) -&gt; 'Dict[NodeID, AttrDict]'</code> - Retrieve all nodes and their attributes as a dictionary.</li>
<li><code>has_edge(self, u, v, key=None)</code> - Returns True if the graph has an edge between nodes u and v.</li>
<li><code>has_edge_by_id(self, key: 'EdgeID') -&gt; 'bool'</code> - Check whether an edge with the given key exists.</li>
<li><code>has_node(self, n)</code> - Returns True if the graph contains the node n.</li>
<li><code>has_predecessor(self, u, v)</code> - Returns True if node u has predecessor v.</li>
<li><code>has_successor(self, u, v)</code> - Returns True if node u has successor v.</li>
<li><code>is_directed(self)</code> - Returns True if graph is directed, False otherwise.</li>
<li><code>is_multigraph(self)</code> - Returns True if graph is a multigraph, False otherwise.</li>
<li><code>nbunch_iter(self, nbunch=None)</code> - Returns an iterator over nodes contained in nbunch that are</li>
<li><code>neighbors(self, n)</code> - Returns an iterator over successor nodes of n.</li>
<li><code>new_edge_key(self, u: 'NodeID', v: 'NodeID', key: 'Optional[int]' = None) -&gt; 'int'</code> - Return a new unique integer edge ID.</li>
<li><code>number_of_edges(self, u=None, v=None)</code> - Returns the number of edges between two nodes.</li>
<li><code>number_of_nodes(self)</code> - Returns the number of nodes in the graph.</li>
<li><code>order(self)</code> - Returns the number of nodes in the graph.</li>
<li><code>predecessors(self, n)</code> - Returns an iterator over predecessor nodes of n.</li>
<li><code>remove_edge(self, u: 'NodeID', v: 'NodeID', key: 'Optional[EdgeID]' = None) -&gt; 'None'</code> - Remove an edge (or edges) between nodes u and v.</li>
<li><code>remove_edge_by_id(self, key: 'EdgeID') -&gt; 'None'</code> - Remove a directed edge by its unique key.</li>
<li><code>remove_edges_from(self, ebunch)</code> - Remove all edges specified in ebunch.</li>
<li><code>remove_node(self, n: 'NodeID') -&gt; 'None'</code> - Remove a single node and all incident edges.</li>
<li><code>remove_nodes_from(self, nodes)</code> - Remove multiple nodes.</li>
<li><code>reverse(self, copy=True)</code> - Returns the reverse of the graph.</li>
<li><code>size(self, weight=None)</code> - Returns the number of edges or total of all edge weights.</li>
<li><code>subgraph(self, nodes)</code> - Returns a SubGraph view of the subgraph induced on <code>nodes</code>.</li>
<li><code>successors(self, n)</code> - Returns an iterator over successor nodes of n.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert the graph to a dictionary representation suitable for JSON serialization.</li>
<li><code>to_directed(self, as_view=False)</code> - Returns a directed representation of the graph.</li>
<li><code>to_directed_class(self)</code> - Returns the class to use for empty directed copies.</li>
<li><code>to_undirected(self, reciprocal=False, as_view=False)</code> - Returns an undirected representation of the digraph.</li>
<li><code>to_undirected_class(self)</code> - Returns the class to use for empty undirected copies.</li>
<li><code>update(self, edges=None, nodes=None)</code> - Update the graph using nodes/edges/graphs as input.</li>
<li><code>update_edge_attr(self, key: 'EdgeID', **attr: 'Any') -&gt; 'None'</code> - Update attributes on an existing edge by key.</li>
</ul>
<hr />
<h2 id="ngraphmodelnetwork">ngraph.model.network<a class="headerlink" href="#ngraphmodelnetwork" title="Permanent link">&para;</a></h2>
<p>Network topology modeling with Node, Link, RiskGroup, and Network classes.</p>
<h3 id="link">Link<a class="headerlink" href="#link" title="Permanent link">&para;</a></h3>
<p>Represents one directed link between two nodes.</p>
<p>The model stores a single direction (<code>source</code> -&gt; <code>target</code>). When building
the working graph for analysis, a reverse edge is added by default to provide
bidirectional connectivity. Disable with <code>add_reverse=False</code> in
<code>Network.to_strict_multidigraph</code>.</p>
<p>Attributes:
    source (str): Name of the source node.
    target (str): Name of the target node.
    capacity (float): Link capacity (default 1.0).
    cost (float): Link cost (default 1.0).
    disabled (bool): Whether the link is disabled.
    risk_groups (Set[str]): Set of risk group names this link belongs to.
    attrs (Dict[str, Any]): Additional metadata (e.g., distance).
    id (str): Auto-generated unique identifier: "{source}|{target}|<base64_uuid>".</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>target</code> (str)</li>
<li><code>capacity</code> (float) = 1.0</li>
<li><code>cost</code> (float) = 1.0</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>risk_groups</code> (Set[str]) = set()</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>id</code> (str)</li>
</ul>
<h3 id="network">Network<a class="headerlink" href="#network" title="Permanent link">&para;</a></h3>
<p>A container for network nodes and links.</p>
<p>Network represents the scenario-level topology with persistent state (nodes/links
that are disabled in the scenario configuration). For temporary exclusion of
nodes/links during analysis (e.g., failure simulation), use NetworkView instead
of modifying the Network's disabled states.</p>
<p>Attributes:
    nodes (Dict[str, Node]): Mapping from node name -&gt; Node object.
    links (Dict[str, Link]): Mapping from link ID -&gt; Link object.
    risk_groups (Dict[str, RiskGroup]): Top-level risk groups by name.
    attrs (Dict[str, Any]): Optional metadata about the network.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>nodes</code> (Dict[str, Node]) = {}</li>
<li><code>links</code> (Dict[str, Link]) = {}</li>
<li><code>risk_groups</code> (Dict[str, RiskGroup]) = {}</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add_link(self, link: 'Link') -&gt; 'None'</code> - Add a link to the network (keyed by the link's auto-generated ID).</li>
<li><code>add_node(self, node: 'Node') -&gt; 'None'</code> - Add a node to the network (keyed by node.name).</li>
<li><code>disable_all(self) -&gt; 'None'</code> - Mark all nodes and links as disabled.</li>
<li><code>disable_link(self, link_id: 'str') -&gt; 'None'</code> - Mark a link as disabled.</li>
<li><code>disable_node(self, node_name: 'str') -&gt; 'None'</code> - Mark a node as disabled.</li>
<li><code>disable_risk_group(self, name: 'str', recursive: 'bool' = True) -&gt; 'None'</code> - Disable all nodes/links that have 'name' in their risk_groups.</li>
<li><code>enable_all(self) -&gt; 'None'</code> - Mark all nodes and links as enabled.</li>
<li><code>enable_link(self, link_id: 'str') -&gt; 'None'</code> - Mark a link as enabled.</li>
<li><code>enable_node(self, node_name: 'str') -&gt; 'None'</code> - Mark a node as enabled.</li>
<li><code>enable_risk_group(self, name: 'str', recursive: 'bool' = True) -&gt; 'None'</code> - Enable all nodes/links that have 'name' in their risk_groups.</li>
<li><code>find_links(self, source_regex: 'Optional[str]' = None, target_regex: 'Optional[str]' = None, any_direction: 'bool' = False) -&gt; 'List[Link]'</code> - Search for links using optional regex patterns for source or target node names.</li>
<li><code>get_links_between(self, source: 'str', target: 'str') -&gt; 'List[str]'</code> - Retrieve all link IDs that connect the specified source node</li>
<li><code>k_shortest_paths(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'pairwise', *, max_k: 'int' = 3, max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[_NGPath]]'</code> - Return up to K shortest paths per group pair.</li>
<li><code>max_flow(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], float]'</code> - Compute maximum flow between node groups in this network.</li>
<li><code>max_flow_detailed(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], Tuple[float, FlowSummary, StrictMultiDiGraph]]'</code> - Compute maximum flow with both analytics summary and graph.</li>
<li><code>max_flow_with_graph(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], Tuple[float, StrictMultiDiGraph]]'</code> - Compute maximum flow and return flow-assigned graphs.</li>
<li><code>max_flow_with_summary(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], Tuple[float, FlowSummary]]'</code> - Compute maximum flow and return per-pair analytics summary.</li>
<li><code>saturated_edges(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', tolerance: 'float' = 1e-10, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], List[Tuple[str, str, str]]]'</code> - Identify saturated edges in max flow solutions.</li>
<li><code>select_node_groups_by_path(self, path: 'str') -&gt; 'Dict[str, List[Node]]'</code> - Select and group nodes by regex on name or by attribute directive.</li>
<li><code>sensitivity_analysis(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', change_amount: 'float' = 1.0, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;) -&gt; 'Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]'</code> - Perform sensitivity analysis for capacity changes.</li>
<li><code>shortest_path_costs(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine') -&gt; 'Dict[Tuple[str, str], float]'</code> - Return minimal path costs between node groups in this network.</li>
<li><code>shortest_paths(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', *, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[_NGPath]]'</code> - Return concrete shortest path(s) between selected node groups.</li>
<li><code>to_strict_multidigraph(self, add_reverse: 'bool' = True, *, compact: 'bool' = False) -&gt; 'StrictMultiDiGraph'</code> - Create a StrictMultiDiGraph representation of this Network.</li>
</ul>
<h3 id="node">Node<a class="headerlink" href="#node" title="Permanent link">&para;</a></h3>
<p>Represents a node in the network.</p>
<p>Each node is uniquely identified by its name, which is used as
the key in the Network's node dictionary.</p>
<p>Attributes:
    name (str): Unique identifier for the node.
    disabled (bool): Whether the node is disabled in the scenario configuration.
    risk_groups (Set[str]): Set of risk group names this node belongs to.
    attrs (Dict[str, Any]): Additional metadata (e.g., coordinates, region).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>risk_groups</code> (Set[str]) = set()</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="riskgroup">RiskGroup<a class="headerlink" href="#riskgroup" title="Permanent link">&para;</a></h3>
<p>Represents a shared-risk or failure domain, which may have nested children.</p>
<p>Attributes:
    name (str): Unique name of this risk group.
    children (List[RiskGroup]): Subdomains in a nested structure.
    disabled (bool): Whether this group was declared disabled on load.
    attrs (Dict[str, Any]): Additional metadata for the risk group.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>children</code> (List[RiskGroup]) = []</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<hr />
<h2 id="ngraphmodelview">ngraph.model.view<a class="headerlink" href="#ngraphmodelview" title="Permanent link">&para;</a></h2>
<p>Read-only view of a <code>Network</code> with temporary exclusions.</p>
<p>This module defines a view over <code>Network</code> objects that can exclude nodes and
links for analysis without mutating the base network. It supports what-if
analysis, including failure simulations.</p>
<h3 id="networkview">NetworkView<a class="headerlink" href="#networkview" title="Permanent link">&para;</a></h3>
<p>Read-only overlay that hides selected nodes/links from a base Network.</p>
<p>NetworkView provides filtered access to a Network where both scenario-disabled
elements (Node.disabled, Link.disabled) and analysis-excluded elements are
hidden from algorithms. This enables failure simulation and what-if analysis
without mutating the base Network.</p>
<p>Multiple NetworkView instances can safely operate on the same base Network
concurrently, each with different exclusion sets.</p>
<p>Example:
    <div class="language-python highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="c1"># Create view excluding specific nodes for failure analysis</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="n">view</span> <span class="o">=</span> <span class="n">NetworkView</span><span class="o">.</span><span class="n">from_excluded_sets</span><span class="p">(</span>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>    <span class="n">base_network</span><span class="p">,</span>
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>    <span class="n">excluded_nodes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;node1&quot;</span><span class="p">,</span> <span class="s2">&quot;node2&quot;</span><span class="p">],</span>
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>    <span class="n">excluded_links</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;link1&quot;</span><span class="p">]</span>
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span class="p">)</span>
</span><span id="__span-0-7"><a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>
</span><span id="__span-0-8"><a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a><span class="c1"># Run analysis on filtered topology</span>
</span><span id="__span-0-9"><a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a><span class="n">flows</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">max_flow</span><span class="p">(</span><span class="s2">&quot;source.*&quot;</span><span class="p">,</span> <span class="s2">&quot;sink.*&quot;</span><span class="p">)</span>
</span></code></pre></div></p>
<p>Attributes:
    _base: The underlying Network object.
    _excluded_nodes: Frozen set of node names to exclude from analysis.
    _excluded_links: Frozen set of link IDs to exclude from analysis.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>_base</code> ('Network')</li>
<li><code>_excluded_nodes</code> (frozenset[str]) = frozenset()</li>
<li><code>_excluded_links</code> (frozenset[str]) = frozenset()</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_excluded_sets(base: "'Network'", excluded_nodes: 'Iterable[str]' = (), excluded_links: 'Iterable[str]' = ()) -&gt; "'NetworkView'"</code> - Create a NetworkView with specified exclusions.</li>
<li><code>is_link_hidden(self, link_id: 'str') -&gt; 'bool'</code> - Check if a link is hidden in this view.</li>
<li><code>is_node_hidden(self, name: 'str') -&gt; 'bool'</code> - Check if a node is hidden in this view.</li>
<li><code>k_shortest_paths(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'pairwise', *, max_k: 'int' = 3, max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[_NGPath]]'</code> - Return up to K shortest paths per group pair.</li>
<li><code>max_flow(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; 'Dict[Tuple[str, str], float]'</code> - Compute maximum flow between node groups in this view.</li>
<li><code>max_flow_detailed(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; "Dict[Tuple[str, str], Tuple[float, 'FlowSummary', 'StrictMultiDiGraph']]"</code> - Compute maximum flow with complete analytics and graph.</li>
<li><code>max_flow_with_graph(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; "Dict[Tuple[str, str], Tuple[float, 'StrictMultiDiGraph']]"</code> - Compute maximum flow and return flow-assigned graph.</li>
<li><code>max_flow_with_summary(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; "Dict[Tuple[str, str], Tuple[float, 'FlowSummary']]"</code> - Compute maximum flow with detailed analytics summary.</li>
<li><code>saturated_edges(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', tolerance: 'float' = 1e-10, shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; 'Dict[Tuple[str, str], List[Tuple[str, str, str]]]'</code> - Identify saturated edges in max flow solutions.</li>
<li><code>select_node_groups_by_path(self, path: 'str') -&gt; "Dict[str, List['Node']]"</code> - Select and group visible nodes by regex or attribute directive.</li>
<li><code>sensitivity_analysis(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', change_amount: 'float' = 1.0, shortest_path: 'bool' = False, flow_placement: "Optional['FlowPlacement']" = None) -&gt; 'Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]'</code> - Perform sensitivity analysis on capacity changes.</li>
<li><code>shortest_path_costs(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine') -&gt; 'Dict[Tuple[str, str], float]'</code> - Return minimal path costs between node groups in this view.</li>
<li><code>shortest_paths(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', *, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[_NGPath]]'</code> - Return concrete shortest path(s) between selected node groups.</li>
<li><code>to_strict_multidigraph(self, add_reverse: 'bool' = True, *, compact: 'bool' = False) -&gt; "'StrictMultiDiGraph'"</code> - Create a StrictMultiDiGraph representation of this view.</li>
</ul>
<hr />
<h2 id="ngraphalgorithmsbase">ngraph.algorithms.base<a class="headerlink" href="#ngraphalgorithmsbase" title="Permanent link">&para;</a></h2>
<p>Base classes and enums for network analysis algorithms.</p>
<h3 id="edgeselect">EdgeSelect<a class="headerlink" href="#edgeselect" title="Permanent link">&para;</a></h3>
<p>Edge selection criteria.</p>
<p>Determines which edges are considered for path-finding between a node and
its neighbor(s).</p>
<h3 id="flowplacement">FlowPlacement<a class="headerlink" href="#flowplacement" title="Permanent link">&para;</a></h3>
<p>Strategies to distribute flow across parallel equal-cost paths.</p>
<h3 id="pathalg">PathAlg<a class="headerlink" href="#pathalg" title="Permanent link">&para;</a></h3>
<p>Path-finding algorithm types.</p>
<hr />
<h2 id="ngraphalgorithmscapacity">ngraph.algorithms.capacity<a class="headerlink" href="#ngraphalgorithmscapacity" title="Permanent link">&para;</a></h2>
<p>Capacity calculation algorithms for network analysis.</p>
<p>This module computes feasible flow given a predecessor DAG from a shortest-path
routine and supports two placement strategies: proportional and equal-balanced
in reversed orientation. Functions follow a Dinic-like blocking-flow approach
for proportional placement.</p>
<h3 id="calc_graph_capacityflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-tuplefloat-dictnodeid-dictnodeid-float">calc_graph_capacity(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow') -&gt; 'Tuple[float, Dict[NodeID, Dict[NodeID, float]]]'<a class="headerlink" href="#calc_graph_capacityflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-tuplefloat-dictnodeid-dictnodeid-float" title="Permanent link">&para;</a></h3>
<p>Calculate feasible flow and flow fractions between two nodes.</p>
<p>In PROPORTIONAL mode (similar to Dinic in reversed orientation):</p>
<ol>
<li>Build the reversed residual graph from dst_node (via <code>_init_graph_data</code>).</li>
<li>
<p>Use BFS (in <code>_set_levels_bfs</code>) to build a level graph and DFS (<code>_push_flow_dfs</code>)</p>
<p>to push blocking flows, repeating until no more flow can be pushed.</p>
</li>
<li>
<p>The net flow found is stored in reversed orientation. Convert final flows</p>
<p>to forward orientation by negating and normalizing by the total.</p>
</li>
</ol>
<p>In EQUAL_BALANCED mode:</p>
<ol>
<li>
<p>Build reversed adjacency from dst_node (also via <code>_init_graph_data</code>),</p>
<p>ignoring capacity checks in that BFS.</p>
</li>
<li>
<p>Perform a BFS pass from src_node (<code>_equal_balance_bfs</code>) to distribute a</p>
<p>nominal flow of 1.0 equally among parallel edges.</p>
</li>
<li>
<p>Determine the scaling ratio so that no edge capacity is exceeded.</p>
<p>Scale the flow assignments accordingly, then normalize to the forward sense.</p>
</li>
</ol>
<p>Args:
    flow_graph: The multigraph with capacity and flow attributes.
    src_node: The source node in the forward graph.
    dst_node: The destination node in the forward graph.
    pred: Forward adjacency mapping (node -&gt; (adjacent node -&gt; list of EdgeIDs)),
          typically produced by <code>spf(..., multipath=True)</code>. Must be a DAG.
    flow_placement: The flow distribution strategy (PROPORTIONAL or EQUAL_BALANCED).
    capacity_attr: Name of the capacity attribute on edges.
    flow_attr: Name of the flow attribute on edges.</p>
<p>Returns:
    tuple[float, dict[NodeID, dict[NodeID, float]]]:</p>
<ul>
<li>Total feasible flow from <code>src_node</code> to <code>dst_node</code>.</li>
<li>Normalized flow fractions in forward orientation (<code>[u][v]</code> &gt;= 0).</li>
</ul>
<p>Raises:
    ValueError: If src_node or dst_node is not in the graph, or the flow_placement
                is unsupported.</p>
<hr />
<h2 id="ngraphalgorithmsedge_select">ngraph.algorithms.edge_select<a class="headerlink" href="#ngraphalgorithmsedge_select" title="Permanent link">&para;</a></h2>
<p>Edge selection algorithms for routing.</p>
<p>Provides selection routines used by SPF to choose candidate edges between
neighbors according to cost and capacity constraints.</p>
<h3 id="edge_select_fabricedge_select-ngraphalgorithmsbaseedgeselect-select_value-optionalany-none-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable-none-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-cost_attr-str-cost-capacity_attr-str-capacity-flow_attr-str-flow-callablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable">edge_select_fabric(edge_select: ngraph.algorithms.base.EdgeSelect, select_value: Optional[Any] = None, edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]] = None, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, cost_attr: str = 'cost', capacity_attr: str = 'capacity', flow_attr: str = 'flow') -&gt; Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Optional[Set[Hashable]], Optional[Set[Hashable]]], Tuple[Union[int, float], List[Hashable]]]<a class="headerlink" href="#edge_select_fabricedge_select-ngraphalgorithmsbaseedgeselect-select_value-optionalany-none-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable-none-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-cost_attr-str-cost-capacity_attr-str-capacity-flow_attr-str-flow-callablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-optionalsethashable-optionalsethashable-tupleunionint-float-listhashable" title="Permanent link">&para;</a></h3>
<p>Create an edge-selection callable for SPF.</p>
<p>Args:
    edge_select: An EdgeSelect enum specifying the selection strategy.
    select_value: An optional numeric threshold or scaling factor for capacity checks.
    edge_select_func: A user-supplied function if edge_select=USER_DEFINED.
    excluded_edges: A set of edges to ignore entirely.
    excluded_nodes: A set of nodes to skip (if the destination node is in this set).
    cost_attr: The edge attribute name representing cost.
    capacity_attr: The edge attribute name representing capacity.
    flow_attr: The edge attribute name representing current flow.</p>
<p>Returns:
    Callable: Function with signature
        <code>(graph, src, dst, edges_dict, excluded_edges, excluded_nodes) -&gt;
        (selected_cost, [edge_ids])</code>.</p>
<hr />
<h2 id="ngraphalgorithmsflow_init">ngraph.algorithms.flow_init<a class="headerlink" href="#ngraphalgorithmsflow_init" title="Permanent link">&para;</a></h2>
<p>Flow graph initialization utilities.</p>
<p>Ensures nodes and edges carry aggregate (<code>flow_attr</code>) and per-flow
(<code>flows_attr</code>) attributes, optionally resetting existing values.</p>
<h3 id="init_flow_graphflow_graph-strictmultidigraph-flow_attr-str-flow-flows_attr-str-flows-reset_flow_graph-bool-true-strictmultidigraph">init_flow_graph(flow_graph: 'StrictMultiDiGraph', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows', reset_flow_graph: 'bool' = True) -&gt; 'StrictMultiDiGraph'<a class="headerlink" href="#init_flow_graphflow_graph-strictmultidigraph-flow_attr-str-flow-flows_attr-str-flows-reset_flow_graph-bool-true-strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Ensure that nodes and edges expose flow-related attributes.</p>
<p>For each node and edge:</p>
<ul>
<li>The attribute named <code>flow_attr</code> (default: "flow") is set to 0.</li>
<li>The attribute named <code>flows_attr</code> (default: "flows") is set to an empty dict.</li>
</ul>
<p>If <code>reset_flow_graph</code> is True, any existing flow values in these attributes
are overwritten; otherwise they are only created if missing.</p>
<p>Args:
    flow_graph: The StrictMultiDiGraph whose nodes and edges should be
        prepared for flow assignment.
    flow_attr: The attribute name to track a numeric flow value per node/edge.
    flows_attr: The attribute name to track multiple flow identifiers (and flows).
    reset_flow_graph: If True, reset existing flows (set to 0). If False, do not overwrite.</p>
<p>Returns:
    StrictMultiDiGraph: The same graph instance after attribute checks.</p>
<hr />
<h2 id="ngraphalgorithmsmax_flow">ngraph.algorithms.max_flow<a class="headerlink" href="#ngraphalgorithmsmax_flow" title="Permanent link">&para;</a></h2>
<p>Maximum-flow computation via iterative shortest-path augmentation.</p>
<p>Implements a practical Edmonds-Karp-like procedure using SPF with capacity
constraints and configurable flow-splitting across equal-cost parallel edges.
Provides helpers for saturated-edge detection and simple sensitivity analysis.</p>
<h3 id="calc_max_flowgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-return_summary-bool-false-return_graph-bool-false-flow_placement-ngraphalgorithmsbaseflowplacement-shortest_path-bool-false-reset_flow_graph-bool-false-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-copy_graph-bool-true-tolerance-float-1e-10-unionfloat-tuple">calc_max_flow(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, *, return_summary: bool = False, return_graph: bool = False, flow_placement: ngraph.algorithms.base.FlowPlacement = <FlowPlacement.PROPORTIONAL: 1>, shortest_path: bool = False, reset_flow_graph: bool = False, capacity_attr: str = 'capacity', flow_attr: str = 'flow', flows_attr: str = 'flows', copy_graph: bool = True, tolerance: float = 1e-10) -&gt; Union[float, tuple]<a class="headerlink" href="#calc_max_flowgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-return_summary-bool-false-return_graph-bool-false-flow_placement-ngraphalgorithmsbaseflowplacement-shortest_path-bool-false-reset_flow_graph-bool-false-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-copy_graph-bool-true-tolerance-float-1e-10-unionfloat-tuple" title="Permanent link">&para;</a></h3>
<p>Compute max flow between two nodes in a directed multi-graph.</p>
<p>Uses iterative shortest-path augmentation with capacity-aware SPF and
configurable flow placement.</p>
<p>By default, this function:</p>
<ol>
<li>Creates or re-initializes a flow-aware copy of the graph (via <code>init_flow_graph</code>).</li>
<li>
<p>Repeatedly finds a path from <code>src_node</code> to <code>dst_node</code> using <code>spf</code> with</p>
<p>capacity constraints (<code>EdgeSelect.ALL_MIN_COST_WITH_CAP_REMAINING</code>).</p>
</li>
<li>
<p>Places flow along that path (via <code>place_flow_on_graph</code>) until no augmenting path</p>
<p>remains or the capacities are exhausted.</p>
</li>
</ol>
<p>If <code>shortest_path=True</code>, the function performs only one iteration (single augmentation)
and returns the flow placed along that single path (not the true max flow).</p>
<p>Args:
    graph (StrictMultiDiGraph):
        The original graph containing capacity/flow attributes on each edge.
    src_node (NodeID):
        The source node for flow.
    dst_node (NodeID):
        The destination node for flow.
    return_summary (bool):
        If True, return a FlowSummary with detailed flow analytics.
        Defaults to False.
    return_graph (bool):
        If True, return the mutated flow graph along with other results.
        Defaults to False.
    flow_placement (FlowPlacement):
        Determines how flow is split among parallel edges of equal cost.
        Defaults to <code>FlowPlacement.PROPORTIONAL</code>.
    shortest_path (bool):
        If True, place flow only once along the first shortest path found and return
        immediately, rather than iterating for the true max flow.
    reset_flow_graph (bool):
        If True, reset any existing flow data (e.g., <code>flow_attr</code>, <code>flows_attr</code>).
        Defaults to False.
    capacity_attr (str):
        The name of the capacity attribute on edges. Defaults to "capacity".
    flow_attr (str):
        The name of the aggregated flow attribute on edges. Defaults to "flow".
    flows_attr (str):
        The name of the per-flow dictionary attribute on edges. Defaults to "flows".
    copy_graph (bool):
        If True, work on a copy of the original graph so it remains unmodified.
        Defaults to True.
    tolerance (float):
        Tolerance for floating-point comparisons when determining saturated edges
        and residual capacity. Defaults to 1e-10.</p>
<p>Returns:
    Union[float, tuple]:</p>
<ul>
<li>If neither flag: <code>float</code> total flow.</li>
<li>If return_summary only: <code>tuple[float, FlowSummary]</code>.</li>
<li>If both flags: <code>tuple[float, FlowSummary, StrictMultiDiGraph]</code>.</li>
</ul>
<p>Notes:</p>
<ul>
<li>When using return_summary or return_graph, the return value is a tuple.</li>
</ul>
<p>Examples:
    &gt;&gt;&gt; g = StrictMultiDiGraph()
    &gt;&gt;&gt; g.add_node('A')
    &gt;&gt;&gt; g.add_node('B')
    &gt;&gt;&gt; g.add_node('C')
    &gt;&gt;&gt; g.add_edge('A', 'B', capacity=10.0, flow=0.0, flows={}, cost=1)
    &gt;&gt;&gt; g.add_edge('B', 'C', capacity=5.0, flow=0.0, flows={}, cost=1)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Basic usage (scalar return)
    &gt;&gt;&gt; max_flow_value = calc_max_flow(g, 'A', 'C')
    &gt;&gt;&gt; print(max_flow_value)
    5.0
    &gt;&gt;&gt;
    &gt;&gt;&gt; # With flow summary analytics
    &gt;&gt;&gt; flow, summary = calc_max_flow(g, 'A', 'C', return_summary=True)
    &gt;&gt;&gt; print(f"Min-cut edges: {summary.min_cut}")
    &gt;&gt;&gt;
    &gt;&gt;&gt; # With both summary and mutated graph
    &gt;&gt;&gt; flow, summary, flow_graph = calc_max_flow(
    ...     g, 'A', 'C', return_summary=True, return_graph=True
    ... )
    &gt;&gt;&gt; # flow_graph contains the flow assignments</p>
<h3 id="run_sensitivitygraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-change_amount-float-10-kwargs-dicttuple-float">run_sensitivity(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, <em>, capacity_attr: str = 'capacity', flow_attr: str = 'flow', change_amount: float = 1.0, </em>*kwargs) -&gt; dict[tuple, float]<a class="headerlink" href="#run_sensitivitygraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-change_amount-float-10-kwargs-dicttuple-float" title="Permanent link">&para;</a></h3>
<p>Simple sensitivity analysis for per-edge capacity changes.</p>
<p>Tests changing each saturated edge capacity by change_amount and measures
the resulting change in total flow. Positive values increase capacity,
negative values decrease capacity (with validation to prevent negative capacities).</p>
<p>Args:
    graph: The graph to analyze
    src_node: Source node
    dst_node: Destination node
    capacity_attr: Name of capacity attribute
    flow_attr: Name of flow attribute
    change_amount: Amount to change capacity for testing (positive=increase, negative=decrease)
    **kwargs: Additional arguments passed to calc_max_flow</p>
<p>Returns:
    dict[tuple, float]: Flow delta per modified edge.</p>
<h3 id="saturated_edgesgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-tolerance-float-1e-10-kwargs-listtuple">saturated_edges(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, <em>, capacity_attr: str = 'capacity', flow_attr: str = 'flow', tolerance: float = 1e-10, </em>*kwargs) -&gt; list[tuple]<a class="headerlink" href="#saturated_edgesgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-capacity_attr-str-capacity-flow_attr-str-flow-tolerance-float-1e-10-kwargs-listtuple" title="Permanent link">&para;</a></h3>
<p>Identify saturated edges in the max-flow solution.</p>
<p>Args:
    graph: The graph to analyze
    src_node: Source node
    dst_node: Destination node
    capacity_attr: Name of capacity attribute
    flow_attr: Name of flow attribute
    tolerance: Tolerance for considering an edge saturated
    **kwargs: Additional arguments passed to calc_max_flow</p>
<p>Returns:
    list[tuple]: Edges <code>(u, v, k)</code> with residual capacity &lt;= <code>tolerance</code>.</p>
<hr />
<h2 id="ngraphalgorithmspaths">ngraph.algorithms.paths<a class="headerlink" href="#ngraphalgorithmspaths" title="Permanent link">&para;</a></h2>
<p>Path manipulation utilities.</p>
<p>Provides helpers to enumerate realized paths from a predecessor map produced by
SPF/KSP, with optional expansion of parallel edges into distinct paths.</p>
<h3 id="resolve_to_pathssrc_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-split_parallel_edges-bool-false-iteratorpathtuple">resolve_to_paths(src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', split_parallel_edges: 'bool' = False) -&gt; 'Iterator[PathTuple]'<a class="headerlink" href="#resolve_to_pathssrc_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-split_parallel_edges-bool-false-iteratorpathtuple" title="Permanent link">&para;</a></h3>
<p>Enumerate all paths from a predecessor map.</p>
<p>Args:
    src_node: Source node ID.
    dst_node: Destination node ID.
    pred: Predecessor map from SPF or KSP.
    split_parallel_edges: If True, expand parallel edges into distinct paths.</p>
<p>Yields:
    PathTuple: Sequence of <code>(node_id, (edge_ids,))</code> pairs from source to dest.</p>
<hr />
<h2 id="ngraphalgorithmsplacement">ngraph.algorithms.placement<a class="headerlink" href="#ngraphalgorithmsplacement" title="Permanent link">&para;</a></h2>
<p>Flow placement for routing over equal-cost predecessor DAGs.</p>
<p>Places feasible flow on a graph given predecessor relations and a placement
strategy, updating aggregate and per-flow attributes.</p>
<h3 id="flowplacementmeta">FlowPlacementMeta<a class="headerlink" href="#flowplacementmeta" title="Permanent link">&para;</a></h3>
<p>Metadata describing how flow was placed on the graph.</p>
<p>Attributes:
    placed_flow: The amount of flow actually placed.
    remaining_flow: The portion of flow that could not be placed due to capacity limits.
    nodes: Set of node IDs that participated in the flow.
    edges: Set of edge IDs that carried some portion of this flow.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>placed_flow</code> (float)</li>
<li><code>remaining_flow</code> (float)</li>
<li><code>nodes</code> (Set[NodeID]) = set()</li>
<li><code>edges</code> (Set[EdgeID]) = set()</li>
</ul>
<h3 id="place_flow_on_graphflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow-float-inf-flow_index-optionalhashable-none-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-flowplacementmeta">place_flow_on_graph(flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', pred: 'Dict[NodeID, Dict[NodeID, List[EdgeID]]]', flow: 'float' = inf, flow_index: 'Optional[Hashable]' = None, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, capacity_attr: 'str' = 'capacity', flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'FlowPlacementMeta'<a class="headerlink" href="#place_flow_on_graphflow_graph-strictmultidigraph-src_node-nodeid-dst_node-nodeid-pred-dictnodeid-dictnodeid-listedgeid-flow-float-inf-flow_index-optionalhashable-none-flow_placement-flowplacement-capacity_attr-str-capacity-flow_attr-str-flow-flows_attr-str-flows-flowplacementmeta" title="Permanent link">&para;</a></h3>
<p>Place flow from <code>src_node</code> to <code>dst_node</code> on <code>flow_graph</code>.</p>
<p>Uses a precomputed <code>flow_dict</code> from <code>calc_graph_capacity</code> to figure out how
much flow can be placed. Updates the graph's edges and nodes with the placed flow.</p>
<p>Args:
    flow_graph: The graph on which flow will be placed.
    src_node: The source node.
    dst_node: The destination node.
    pred: A dictionary of node-&gt;(adj_node-&gt;list_of_edge_IDs) giving path adjacency.
    flow: Requested flow amount; can be infinite.
    flow_index: Identifier for this flow (used to track multiple flows).
    flow_placement: Strategy for distributing flow among parallel equal cost paths.
    capacity_attr: Attribute name on edges for capacity.
    flow_attr: Attribute name on edges/nodes for aggregated flow.
    flows_attr: Attribute name on edges/nodes for per-flow tracking.</p>
<p>Returns:
    FlowPlacementMeta: Amount placed, remaining amount, and touched nodes/edges.</p>
<h3 id="remove_flow_from_graphflow_graph-strictmultidigraph-flow_index-optionalhashable-none-flow_attr-str-flow-flows_attr-str-flows-none">remove_flow_from_graph(flow_graph: 'StrictMultiDiGraph', flow_index: 'Optional[Hashable]' = None, flow_attr: 'str' = 'flow', flows_attr: 'str' = 'flows') -&gt; 'None'<a class="headerlink" href="#remove_flow_from_graphflow_graph-strictmultidigraph-flow_index-optionalhashable-none-flow_attr-str-flow-flows_attr-str-flows-none" title="Permanent link">&para;</a></h3>
<p>Remove one or all flows from the graph.</p>
<p>Args:
    flow_graph: Graph whose edge flow attributes will be modified.
    flow_index: If provided, remove only the specified flow; otherwise remove all.
    flow_attr: Aggregate flow attribute name on edges.
    flows_attr: Per-flow attribute name on edges.</p>
<hr />
<h2 id="ngraphalgorithmsspf">ngraph.algorithms.spf<a class="headerlink" href="#ngraphalgorithmsspf" title="Permanent link">&para;</a></h2>
<p>Shortest-path-first (SPF) algorithms.</p>
<p>Implements Dijkstra-like SPF with pluggable edge-selection policies and a
Yen-like KSP generator. Specialized fast paths exist for common selection
strategies without exclusions.</p>
<p>Notes:
    When a destination node is known, SPF supports an optimized mode that
    terminates once the destination's minimal distance is settled. In this mode:</p>
<ul>
<li>The destination node is not expanded (no neighbor relaxation from <code>dst</code>).</li>
<li>
<p>The algorithm continues processing any nodes with equal distance to capture</p>
<p>equal-cost predecessors (needed by proportional flow placement).</p>
</li>
</ul>
<h3 id="kspgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-max_k-optionalint-none-max_path_cost-unionint-float-inf-max_path_cost_factor-optionalfloat-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-iteratortupledicthashable-unionint-float-dicthashable-dicthashable-listhashable">ksp(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, dst_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = <EdgeSelect.ALL_MIN_COST: 1>, edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, max_k: Optional[int] = None, max_path_cost: Union[int, float] = inf, max_path_cost_factor: Optional[float] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None) -&gt; Iterator[Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]]<a class="headerlink" href="#kspgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-dst_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-max_k-optionalint-none-max_path_cost-unionint-float-inf-max_path_cost_factor-optionalfloat-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-iteratortupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" title="Permanent link">&para;</a></h3>
<p>Yield up to k shortest paths using a Yen-like algorithm.</p>
<p>The initial SPF (shortest path) is computed; subsequent paths are found by systematically
excluding edges/nodes used by previously generated paths. Each iteration yields a
(costs, pred) describing one path. Stops if there are no more valid paths or if max_k
is reached.</p>
<p>Args:
    graph: The directed graph (StrictMultiDiGraph).
    src_node: The source node.
    dst_node: The destination node.
    edge_select: The edge selection strategy. Defaults to ALL_MIN_COST.
    edge_select_func: Optional override of the default edge selection function.
    max_k: If set, yields at most k distinct paths.
    max_path_cost: If set, do not yield any path whose total cost &gt; max_path_cost.
    max_path_cost_factor: If set, updates max_path_cost to:
        min(max_path_cost, best_path_cost * max_path_cost_factor).
    multipath: Whether to consider multiple same-cost expansions in SPF.
    excluded_edges: Set of edge IDs to exclude globally.
    excluded_nodes: Set of node IDs to exclude globally.</p>
<p>Yields:
    Tuple of <code>(costs, pred)</code> per discovered path in ascending cost order.</p>
<h3 id="spfgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-dst_node-optionalhashable-none-tupledicthashable-unionint-float-dicthashable-dicthashable-listhashable">spf(graph: ngraph.graph.strict_multidigraph.StrictMultiDiGraph, src_node: Hashable, edge_select: ngraph.algorithms.base.EdgeSelect = <EdgeSelect.ALL_MIN_COST: 1>, edge_select_func: Optional[Callable[[ngraph.graph.strict_multidigraph.StrictMultiDiGraph, Hashable, Hashable, Dict[Hashable, Dict[str, Any]], Set[Hashable], Set[Hashable]], Tuple[Union[int, float], List[Hashable]]]] = None, multipath: bool = True, excluded_edges: Optional[Set[Hashable]] = None, excluded_nodes: Optional[Set[Hashable]] = None, dst_node: Optional[Hashable] = None) -&gt; Tuple[Dict[Hashable, Union[int, float]], Dict[Hashable, Dict[Hashable, List[Hashable]]]]<a class="headerlink" href="#spfgraph-ngraphgraphstrict_multidigraphstrictmultidigraph-src_node-hashable-edge_select-ngraphalgorithmsbaseedgeselect-edge_select_func-optionalcallablengraphgraphstrict_multidigraphstrictmultidigraph-hashable-hashable-dicthashable-dictstr-any-sethashable-sethashable-tupleunionint-float-listhashable-none-multipath-bool-true-excluded_edges-optionalsethashable-none-excluded_nodes-optionalsethashable-none-dst_node-optionalhashable-none-tupledicthashable-unionint-float-dicthashable-dicthashable-listhashable" title="Permanent link">&para;</a></h3>
<p>Compute shortest paths from a source node.</p>
<p>By default, uses EdgeSelect.ALL_MIN_COST. If multipath=True, multiple equal-cost
paths to the same node will be recorded in the predecessor structure. If no
excluded edges/nodes are given and edge_select is one of the specialized
(ALL_MIN_COST or ALL_MIN_COST_WITH_CAP_REMAINING), it uses a fast specialized
routine.</p>
<p>Args:
    graph: The directed graph (StrictMultiDiGraph).
    src_node: The source node from which to compute shortest paths.
    edge_select: The edge selection strategy. Defaults to ALL_MIN_COST.
    edge_select_func: If provided, overrides the default edge selection function.
        Must return (cost, list_of_edges) for the given node-&gt;neighbor adjacency.
    multipath: Whether to record multiple same-cost paths.
    excluded_edges: A set of edge IDs to ignore in the graph.
    excluded_nodes: A set of node IDs to ignore in the graph.
    dst_node: Optional destination node. If provided, SPF avoids expanding
        from the destination and performs early termination once the next
        candidate in the heap would exceed the settled distance for
        <code>dst_node</code>. This preserves equal-cost predecessors while avoiding
        unnecessary relaxations beyond the destination.</p>
<p>Returns:
    tuple[dict[NodeID, Cost], dict[NodeID, dict[NodeID, list[EdgeID]]]]:
        Costs and predecessor mapping.</p>
<p>Raises:
    KeyError: If src_node does not exist in graph.</p>
<hr />
<h2 id="ngraphalgorithmstypes">ngraph.algorithms.types<a class="headerlink" href="#ngraphalgorithmstypes" title="Permanent link">&para;</a></h2>
<p>Types and data structures for algorithm analytics.</p>
<p>Defines immutable summary containers and aliases for algorithm outputs.</p>
<h3 id="flowsummary">FlowSummary<a class="headerlink" href="#flowsummary" title="Permanent link">&para;</a></h3>
<p>Summary of max-flow computation results.</p>
<p>Captures edge flows, residual capacities, reachable set, and min-cut.</p>
<p>Attributes:
    total_flow: Maximum flow value achieved.
    edge_flow: Flow amount per edge, indexed by <code>(src, dst, key)</code>.
    residual_cap: Remaining capacity per edge after placement.
    reachable: Nodes reachable from source in residual graph.
    min_cut: Saturated edges crossing the s-t cut.
    cost_distribution: Mapping of path cost to flow volume placed at that cost.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>total_flow</code> (float)</li>
<li><code>edge_flow</code> (Dict[Edge, float])</li>
<li><code>residual_cap</code> (Dict[Edge, float])</li>
<li><code>reachable</code> (Set[str])</li>
<li><code>min_cut</code> (List[Edge])</li>
<li><code>cost_distribution</code> (Dict[Cost, float])</li>
</ul>
<hr />
<h2 id="ngraphpathsbundle">ngraph.paths.bundle<a class="headerlink" href="#ngraphpathsbundle" title="Permanent link">&para;</a></h2>
<p>Utilities for compact representation of equal-cost path sets.</p>
<p>This module defines <code>PathBundle</code>, a structure that represents one or more
equal-cost paths between two nodes using a predecessor map. It supports
concatenation, containment checks, sub-bundle extraction with cost
recalculation, and enumeration into concrete <code>Path</code> instances.</p>
<h3 id="pathbundle">PathBundle<a class="headerlink" href="#pathbundle" title="Permanent link">&para;</a></h3>
<p>A collection of equal-cost paths between two nodes.</p>
<p>This class encapsulates one or more parallel paths (all of the same cost)
between <code>src_node</code> and <code>dst_node</code>. The predecessor map <code>pred</code> associates
each node with the node(s) from which it can be reached, along with a list
of edge IDs used in that step. The constructor performs a reverse traversal
from <code>dst_node</code> to <code>src_node</code> to collect all edges, nodes, and store them
in this bundle.</p>
<p>The constructor assumes the predecessor relation forms a DAG between
<code>src_node</code> and <code>dst_node</code>. No cycle detection is performed. If cycles
are present, traversal may not terminate.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add(self, other: 'PathBundle') -&gt; 'PathBundle'</code> - Concatenate this bundle with another bundle (end-to-start).</li>
<li><code>contains(self, other: 'PathBundle') -&gt; 'bool'</code> - Check if this bundle's edge set contains all edges of <code>other</code>.</li>
<li><code>from_path(path: 'Path', resolve_edges: 'bool' = False, graph: 'Optional[StrictMultiDiGraph]' = None, edge_select: 'Optional[EdgeSelect]' = None, cost_attr: 'str' = 'cost', capacity_attr: 'str' = 'capacity') -&gt; 'PathBundle'</code> - Construct a PathBundle from a single <code>Path</code> object.</li>
<li><code>get_sub_path_bundle(self, new_dst_node: 'NodeID', graph: 'StrictMultiDiGraph', cost_attr: 'str' = 'cost') -&gt; 'PathBundle'</code> - Create a sub-bundle ending at <code>new_dst_node</code> with correct minimal cost.</li>
<li><code>is_disjoint_from(self, other: 'PathBundle') -&gt; 'bool'</code> - Check if this bundle shares no edges with <code>other</code>.</li>
<li><code>is_subset_of(self, other: 'PathBundle') -&gt; 'bool'</code> - Check if this bundle's edge set is contained in <code>other</code>'s edge set.</li>
<li><code>resolve_to_paths(self, split_parallel_edges: 'bool' = False) -&gt; 'Iterator[Path]'</code> - Generate all concrete <code>Path</code> objects contained in this PathBundle.</li>
</ul>
<hr />
<h2 id="ngraphpathspath">ngraph.paths.path<a class="headerlink" href="#ngraphpathspath" title="Permanent link">&para;</a></h2>
<p>Lightweight representation of a single routing path.</p>
<p>The <code>Path</code> dataclass stores a node-and-parallel-edges sequence and a numeric
cost. Cached properties expose derived sequences for nodes and edges, and
helpers provide equality, ordering by cost, and sub-path extraction with cost
recalculation.</p>
<h3 id="path">Path<a class="headerlink" href="#path" title="Permanent link">&para;</a></h3>
<p>Represents a single path in the network.</p>
<p>Attributes:
    path_tuple (PathTuple):
        A sequence of path elements. Each element is a tuple of the form
        (node_id, (edge_id_1, edge_id_2, ...)), where the final element typically has an empty tuple.
    cost (Cost):
        The total numeric cost (e.g., distance or metric) of the path.
    edges (Set[EdgeID]):
        A set of all edge IDs encountered in the path.
    nodes (Set[NodeID]):
        A set of all node IDs encountered in the path.
    edge_tuples (Set[Tuple[EdgeID, ...]]):
        A set of all tuples of parallel edges from each path element (including the final empty tuple).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>path_tuple</code> (PathTuple)</li>
<li><code>cost</code> (Cost)</li>
<li><code>edges</code> (Set[EdgeID]) = set()</li>
<li><code>nodes</code> (Set[NodeID]) = set()</li>
<li><code>edge_tuples</code> (Set[Tuple[EdgeID, ...]]) = set()</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>get_sub_path(self, dst_node: 'NodeID', graph: 'StrictMultiDiGraph', cost_attr: 'str' = 'cost') -&gt; 'Path'</code> - Create a sub-path ending at the specified destination node, recalculating the cost.</li>
</ul>
<hr />
<h2 id="ngraphflowsflow">ngraph.flows.flow<a class="headerlink" href="#ngraphflowsflow" title="Permanent link">&para;</a></h2>
<p>Flow and FlowIndex classes for traffic flow representation.</p>
<h3 id="flow">Flow<a class="headerlink" href="#flow" title="Permanent link">&para;</a></h3>
<p>Represents a fraction of demand routed along a given PathBundle.</p>
<p>In traffic-engineering scenarios, a <code>Flow</code> object can model:</p>
<ul>
<li>MPLS LSPs/tunnels with explicit paths,</li>
<li>IP forwarding behavior (with ECMP or WCMP),</li>
<li>Or anything that follows a specific set of paths.</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>place_flow(self, flow_graph: 'StrictMultiDiGraph', to_place: 'float', flow_placement: 'FlowPlacement') -&gt; 'Tuple[float, float]'</code> - Place or update this flow on the graph.</li>
<li><code>remove_flow(self, flow_graph: 'StrictMultiDiGraph') -&gt; 'None'</code> - Remove this flow from the graph.</li>
</ul>
<h3 id="flowindex">FlowIndex<a class="headerlink" href="#flowindex" title="Permanent link">&para;</a></h3>
<p>Unique identifier for a flow.</p>
<p>Attributes:
    src_node: Source node.
    dst_node: Destination node.
    flow_class: Flow class label (hashable).
    flow_id: Monotonic integer id for this flow.</p>
<hr />
<h2 id="ngraphflowspolicy">ngraph.flows.policy<a class="headerlink" href="#ngraphflowspolicy" title="Permanent link">&para;</a></h2>
<p>FlowPolicy and FlowPolicyConfig classes for traffic routing algorithms.</p>
<h3 id="flowpolicy">FlowPolicy<a class="headerlink" href="#flowpolicy" title="Permanent link">&para;</a></h3>
<p>Create, place, rebalance, and remove flows on a network graph.</p>
<p>Converts a demand into one or more <code>Flow</code> objects subject to capacity
constraints and configuration: path selection, edge selection, and flow
placement method.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>deep_copy(self) -&gt; 'FlowPolicy'</code> - Return a deep copy of this policy including flows.</li>
<li><code>get_metrics(self) -&gt; 'Dict[str, float]'</code> - Return cumulative placement metrics for this policy instance.</li>
<li><code>place_demand(self, flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', flow_class: 'Hashable', volume: 'float', target_flow_volume: 'Optional[float]' = None, min_flow: 'Optional[float]' = None) -&gt; 'Tuple[float, float]'</code> - Place demand volume on the graph by splitting or creating flows as needed.</li>
<li><code>rebalance_demand(self, flow_graph: 'StrictMultiDiGraph', src_node: 'NodeID', dst_node: 'NodeID', flow_class: 'Hashable', target_flow_volume: 'float') -&gt; 'Tuple[float, float]'</code> - Rebalance demand across existing flows towards the target volume per flow.</li>
<li><code>remove_demand(self, flow_graph: 'StrictMultiDiGraph') -&gt; 'None'</code> - Removes all flows from the network graph without clearing internal state.</li>
</ul>
<h3 id="flowpolicyconfig">FlowPolicyConfig<a class="headerlink" href="#flowpolicyconfig" title="Permanent link">&para;</a></h3>
<p>Enumerates supported flow policy configurations.</p>
<h3 id="get_flow_policyflow_policy_config-flowpolicyconfig-flowpolicy">get_flow_policy(flow_policy_config: 'FlowPolicyConfig') -&gt; 'FlowPolicy'<a class="headerlink" href="#get_flow_policyflow_policy_config-flowpolicyconfig-flowpolicy" title="Permanent link">&para;</a></h3>
<p>Create a policy instance from a configuration preset.</p>
<p>Args:
    flow_policy_config: A FlowPolicyConfig enum value specifying the desired policy.</p>
<p>Returns:
    FlowPolicy: Pre-configured policy instance.</p>
<p>Raises:
    ValueError: If an unknown FlowPolicyConfig value is provided.</p>
<hr />
<h2 id="ngraphsolverhelpers">ngraph.solver.helpers<a class="headerlink" href="#ngraphsolverhelpers" title="Permanent link">&para;</a></h2>
<hr />
<h2 id="ngraphsolvermaxflow">ngraph.solver.maxflow<a class="headerlink" href="#ngraphsolvermaxflow" title="Permanent link">&para;</a></h2>
<p>Problem-level max-flow API bound to the model layer.</p>
<p>Functions here operate on a model context that provides:</p>
<ul>
<li>to_strict_multidigraph(add_reverse: bool = True) -&gt; StrictMultiDiGraph</li>
<li>select_node_groups_by_path(path: str) -&gt; dict[str, list[Node]]</li>
</ul>
<p>They accept either a <code>Network</code> or a <code>NetworkView</code>. The input context is not
mutated. Pseudo source and sink nodes are attached on a working graph when
computing flows between groups.</p>
<h3 id="max_flowcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-float">max_flow(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; 'Dict[Tuple[str, str], float]'<a class="headerlink" href="#max_flowcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-float" title="Permanent link">&para;</a></h3>
<p>Compute max flow between groups selected from the context.</p>
<p>Creates a working graph from the context, adds a pseudo source attached to
the selected source nodes and a pseudo sink attached to the selected sink
nodes, then runs the max-flow routine.</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: Aggregation strategy. "combine" considers all sources as one
        group and all sinks as one group. "pairwise" evaluates each
        source-label and sink-label pair separately.
    shortest_path: If True, perform a single augmentation along the first
        shortest path instead of the full max-flow.
    flow_placement: Strategy for splitting flow among equal-cost parallel
        edges.</p>
<p>Returns:
    Dict[Tuple[str, str], float]: Total flow per (source_label, sink_label).</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is not one of {"combine", "pairwise"}.</p>
<h3 id="max_flow_detailedcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary-strictmultidigraph">max_flow_detailed(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; "Dict[Tuple[str, str], Tuple[float, FlowSummary, 'StrictMultiDiGraph']]"<a class="headerlink" href="#max_flow_detailedcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary-strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Compute max flow, return summary and flow graph for each pair.</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise". See <code>max_flow</code>.
    shortest_path: If True, perform only one augmentation step.
    flow_placement: Strategy for splitting among equal-cost parallel edges.</p>
<p>Returns:
    Dict[Tuple[str, str], Tuple[float, FlowSummary, StrictMultiDiGraph]]:
    For each (source_label, sink_label), the total flow, a summary, and the
    flow-assigned graph.</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is invalid.</p>
<h3 id="max_flow_with_graphcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-strictmultidigraph">max_flow_with_graph(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; "Dict[Tuple[str, str], Tuple[float, 'StrictMultiDiGraph']]"<a class="headerlink" href="#max_flow_with_graphcontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-strictmultidigraph" title="Permanent link">&para;</a></h3>
<p>Compute max flow and return the mutated flow graph for each pair.</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise". See <code>max_flow</code>.
    shortest_path: If True, perform only one augmentation step.
    flow_placement: Strategy for splitting among equal-cost parallel edges.</p>
<p>Returns:
    Dict[Tuple[str, str], Tuple[float, StrictMultiDiGraph]]: For each
    (source_label, sink_label), the total flow and the flow-assigned graph.</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is invalid.</p>
<h3 id="max_flow_with_summarycontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary">max_flow_with_summary(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; 'Dict[Tuple[str, str], Tuple[float, FlowSummary]]'<a class="headerlink" href="#max_flow_with_summarycontext-any-source_path-str-sink_path-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-tuplefloat-flowsummary" title="Permanent link">&para;</a></h3>
<p>Compute max flow and return a summary for each group pair.</p>
<p>The summary includes total flow, per-edge flow, residual capacity,
reachable set from the source in the residual graph, min-cut edges, and a
cost distribution over augmentation steps.</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise". See <code>max_flow</code>.
    shortest_path: If True, perform only one augmentation step.
    flow_placement: Strategy for splitting among equal-cost parallel edges.</p>
<p>Returns:
    Dict[Tuple[str, str], Tuple[float, FlowSummary]]: For each
    (source_label, sink_label), the total flow and the associated summary.</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is invalid.</p>
<h3 id="saturated_edgescontext-any-source_path-str-sink_path-str-mode-str-combine-tolerance-float-1e-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-listtuplestr-str-str">saturated_edges(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', tolerance: 'float' = 1e-10, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; 'Dict[Tuple[str, str], List[Tuple[str, str, str]]]'<a class="headerlink" href="#saturated_edgescontext-any-source_path-str-sink_path-str-mode-str-combine-tolerance-float-1e-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-listtuplestr-str-str" title="Permanent link">&para;</a></h3>
<p>Identify saturated edges for each selected group pair.</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise". See <code>max_flow</code>.
    tolerance: Residual capacity threshold to consider an edge saturated.
    shortest_path: If True, perform only one augmentation step.
    flow_placement: Strategy for splitting among equal-cost parallel edges.</p>
<p>Returns:
    Dict[Tuple[str, str], list[tuple[str, str, str]]]: For each
    (source_label, sink_label), a list of saturated edges <code>(u, v, k)</code>.</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is invalid.</p>
<h3 id="sensitivity_analysiscontext-any-source_path-str-sink_path-str-mode-str-combine-change_amount-float-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-dicttuplestr-str-str-float">sensitivity_analysis(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', change_amount: 'float' = 1.0, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>) -&gt; 'Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]'<a class="headerlink" href="#sensitivity_analysiscontext-any-source_path-str-sink_path-str-mode-str-combine-change_amount-float-10-shortest_path-bool-false-flow_placement-flowplacement-dicttuplestr-str-dicttuplestr-str-str-float" title="Permanent link">&para;</a></h3>
<p>Perform a simple sensitivity analysis per saturated edge.</p>
<p>For each saturated edge, test a capacity change of <code>change_amount</code> and
report the change in total flow. Positive amounts increase capacity; negative
amounts decrease capacity (with lower bound at zero).</p>
<p>Args:
    context: <code>Network</code> or <code>NetworkView</code> providing selection and graph APIs.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise". See <code>max_flow</code>.
    change_amount: Capacity delta to apply when testing each saturated edge.
    shortest_path: If True, perform only one augmentation step.
    flow_placement: Strategy for splitting among equal-cost parallel edges.</p>
<p>Returns:
    Dict[Tuple[str, str], Dict[Tuple[str, str, str], float]]: For each
    (source_label, sink_label), a mapping from saturated edge <code>(u, v, k)</code>
    to the change in total flow after applying the capacity delta.</p>
<p>Raises:
    ValueError: If no matching sources or sinks are found, or if <code>mode</code>
        is invalid.</p>
<hr />
<h2 id="ngraphsolverpaths">ngraph.solver.paths<a class="headerlink" href="#ngraphsolverpaths" title="Permanent link">&para;</a></h2>
<p>Shortest-path solver wrappers bound to the model layer.</p>
<p>Expose convenience functions for computing shortest paths between node groups
selected from a <code>Network</code> or <code>NetworkView</code> context. Selection semantics
mirror the max-flow wrappers with <code>mode</code> in {"combine", "pairwise"}.</p>
<p>Functions return minimal costs or concrete <code>Path</code> objects built from SPF
predecessor maps. Parallel equal-cost edges can be expanded into distinct
paths.</p>
<p>All functions fail fast on invalid selection inputs and do not mutate the
input context.</p>
<p>Note:
    For path queries, overlapping source/sink membership is treated as
    unreachable.</p>
<h3 id="k_shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-pairwise-max_k-int-3-edge_select-edgeselect-max_path_cost-float-inf-max_path_cost_factor-optionalfloat-none-split_parallel_edges-bool-false-dicttuplestr-str-listpath">k_shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'pairwise', max_k: 'int' = 3, edge_select: 'EdgeSelect' = <EdgeSelect.ALL_MIN_COST: 1>, max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'<a class="headerlink" href="#k_shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-pairwise-max_k-int-3-edge_select-edgeselect-max_path_cost-float-inf-max_path_cost_factor-optionalfloat-none-split_parallel_edges-bool-false-dicttuplestr-str-listpath" title="Permanent link">&para;</a></h3>
<p>Return up to K shortest paths per group pair.</p>
<p>Args:
    context: Network or NetworkView.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "pairwise" (default) or "combine".
    max_k: Max paths per pair.
    edge_select: SPF/KSP edge selection strategy.
    max_path_cost: Absolute cost threshold.
    max_path_cost_factor: Relative threshold versus best path.
    split_parallel_edges: Expand parallel edges into distinct paths when True.</p>
<p>Returns:
    Mapping from (source_label, sink_label) to list of Path (&lt;= max_k).</p>
<p>Raises:
    ValueError: If no source nodes match <code>source_path</code>.
    ValueError: If no sink nodes match <code>sink_path</code>.
    ValueError: If <code>mode</code> is not "combine" or "pairwise".</p>
<h3 id="shortest_path_costscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-dicttuplestr-str-float">shortest_path_costs(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = <EdgeSelect.ALL_MIN_COST: 1>) -&gt; 'Dict[Tuple[str, str], float]'<a class="headerlink" href="#shortest_path_costscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-dicttuplestr-str-float" title="Permanent link">&para;</a></h3>
<p>Return minimal path cost(s) between selected node groups.</p>
<p>Args:
    context: Network or NetworkView.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise".
    edge_select: SPF edge selection strategy.</p>
<p>Returns:
    Mapping from (source_label, sink_label) to minimal cost; <code>inf</code> if no
    path.</p>
<p>Raises:
    ValueError: If no source nodes match <code>source_path</code>.
    ValueError: If no sink nodes match <code>sink_path</code>.
    ValueError: If <code>mode</code> is not "combine" or "pairwise".</p>
<h3 id="shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-split_parallel_edges-bool-false-dicttuplestr-str-listpath">shortest_paths(context: 'Any', source_path: 'str', sink_path: 'str', *, mode: 'str' = 'combine', edge_select: 'EdgeSelect' = <EdgeSelect.ALL_MIN_COST: 1>, split_parallel_edges: 'bool' = False) -&gt; 'Dict[Tuple[str, str], List[Path]]'<a class="headerlink" href="#shortest_pathscontext-any-source_path-str-sink_path-str-mode-str-combine-edge_select-edgeselect-split_parallel_edges-bool-false-dicttuplestr-str-listpath" title="Permanent link">&para;</a></h3>
<p>Return concrete shortest path(s) between selected node groups.</p>
<p>Args:
    context: Network or NetworkView.
    source_path: Selection expression for source groups.
    sink_path: Selection expression for sink groups.
    mode: "combine" or "pairwise".
    edge_select: SPF edge selection strategy.
    split_parallel_edges: Expand parallel edges into distinct paths when True.</p>
<p>Returns:
    Mapping from (source_label, sink_label) to list of Path. Empty if
    unreachable.</p>
<p>Raises:
    ValueError: If no source nodes match <code>source_path</code>.
    ValueError: If no sink nodes match <code>sink_path</code>.
    ValueError: If <code>mode</code> is not "combine" or "pairwise".</p>
<hr />
<h2 id="ngraphdemandmanagerbuilder">ngraph.demand.manager.builder<a class="headerlink" href="#ngraphdemandmanagerbuilder" title="Permanent link">&para;</a></h2>
<p>Builders for traffic matrices.</p>
<p>Construct <code>TrafficMatrixSet</code> from raw dictionaries (e.g. parsed YAML).
This logic was previously embedded in <code>Scenario.from_yaml</code>.</p>
<h3 id="build_traffic_matrix_setraw-dictstr-listdict-trafficmatrixset">build_traffic_matrix_set(raw: 'Dict[str, List[dict]]') -&gt; 'TrafficMatrixSet'<a class="headerlink" href="#build_traffic_matrix_setraw-dictstr-listdict-trafficmatrixset" title="Permanent link">&para;</a></h3>
<p>Build a <code>TrafficMatrixSet</code> from a mapping of name -&gt; list of dicts.</p>
<p>Args:
    raw: Mapping where each key is a matrix name and each value is a list of
        dictionaries with <code>TrafficDemand</code> constructor fields.</p>
<p>Returns:
    Initialized <code>TrafficMatrixSet</code> with constructed <code>TrafficDemand</code> objects.</p>
<p>Raises:
    ValueError: If <code>raw</code> is not a mapping of name -&gt; list[dict].</p>
<hr />
<h2 id="ngraphdemandmanagerexpand">ngraph.demand.manager.expand<a class="headerlink" href="#ngraphdemandmanagerexpand" title="Permanent link">&para;</a></h2>
<p>Expansion helpers for traffic demand specifications.</p>
<p>Public functions here convert user-facing <code>TrafficDemand</code> specifications into
concrete <code>Demand</code> objects that can be placed on a <code>StrictMultiDiGraph</code>.</p>
<p>This module provides the pure expansion logic that was previously embedded in
<code>TrafficManager</code>.</p>
<h3 id="expand_demandsnetwork-unionnetwork-networkview-graph-strictmultidigraph-none-traffic_demands-listtrafficdemand-default_flow_policy_config-flowpolicyconfig-tuplelistdemand-dictstr-listdemand">expand_demands(network: "Union[Network, 'NetworkView']", graph: 'StrictMultiDiGraph | None', traffic_demands: 'List[TrafficDemand]', default_flow_policy_config: 'FlowPolicyConfig') -&gt; 'Tuple[List[Demand], Dict[str, List[Demand]]]'<a class="headerlink" href="#expand_demandsnetwork-unionnetwork-networkview-graph-strictmultidigraph-none-traffic_demands-listtrafficdemand-default_flow_policy_config-flowpolicyconfig-tuplelistdemand-dictstr-listdemand" title="Permanent link">&para;</a></h3>
<p>Expand traffic demands into concrete <code>Demand</code> objects.</p>
<p>The result is a flat list of <code>Demand</code> plus a mapping from
<code>TrafficDemand.id</code> to the list of expanded demands for that entry.</p>
<p>Args:
    network: Network or NetworkView used for node group selection.
    graph: Flow graph to operate on. If <code>None</code>, expansion that requires
        graph mutation (pseudo nodes/edges) is skipped.
    traffic_demands: List of high-level traffic demand specifications.
    default_flow_policy_config: Default policy to apply when a demand does
        not specify an explicit <code>flow_policy</code>.</p>
<p>Returns:
    A tuple <code>(expanded, td_map)</code> where:</p>
<ul>
<li>
<p><code>expanded</code> is the flattened, sorted list of all expanded demands</p>
<p>(sorted by ascending <code>demand_class</code>).</p>
</li>
<li>
<p><code>td_map</code> maps <code>TrafficDemand.id</code> to its expanded demands.</p>
</li>
</ul>
<hr />
<h2 id="ngraphdemandmanagermanager">ngraph.demand.manager.manager<a class="headerlink" href="#ngraphdemandmanagermanager" title="Permanent link">&para;</a></h2>
<p>Traffic demand management and placement.</p>
<p><code>TrafficManager</code> expands <code>TrafficDemand</code> specs into concrete <code>Demand</code> objects,
builds a working <code>StrictMultiDiGraph</code> from a <code>Network</code>, and places flows via
per-demand <code>FlowPolicy</code> instances.</p>
<h3 id="trafficmanager">TrafficManager<a class="headerlink" href="#trafficmanager" title="Permanent link">&para;</a></h3>
<p>Manage expansion and placement of traffic demands on a <code>Network</code>.</p>
<p>This class:</p>
<p>1) Builds (or rebuilds) a StrictMultiDiGraph from the given Network.
   2) Expands each TrafficDemand into one or more Demand objects based
      on a configurable 'mode' ("combine" or "pairwise").
  3) Each Demand is associated with a FlowPolicy, which handles how flows
     are placed (split across paths, balancing, etc.).
     4) Provides methods to place all demands incrementally with optional
      re-optimization, reset usage, and retrieve flow/usage summaries.</p>
<p>Auto rounds semantics:</p>
<ul>
<li>
<p>placement_rounds="auto" performs up to a small number of fairness passes</p>
<p>(at most 3), with early stop when diminishing returns are detected. Each
 pass asks the scheduler to place full leftovers without step splitting.</p>
</li>
</ul>
<p>In particular:</p>
<ul>
<li>'combine' mode:</li>
<li>
<p>Combine all matched sources into a single pseudo-source node, and all</p>
<p>matched sinks into a single pseudo-sink node (named using the traffic
  demand's <code>source_path</code> and <code>sink_path</code>). A single Demand is created
  from the pseudo-source to the pseudo-sink, with the full volume.</p>
</li>
<li>
<p>'pairwise' mode:</p>
</li>
<li>
<p>All matched sources form one group, all matched sinks form another group.</p>
<p>A separate Demand is created for each (src_node, dst_node) pair,
  skipping self-pairs. The total volume is split evenly across the pairs.</p>
</li>
</ul>
<p>The sum of volumes of all expanded Demands for a given TrafficDemand matches
that TrafficDemand's <code>demand</code> value (unless no valid node pairs exist, in which
case no demands are created).</p>
<p>Attributes:
    network (Union[Network, NetworkView]): The underlying network or view object.
    traffic_matrix_set (TrafficMatrixSet): Traffic matrices containing demands.
    matrix_name (Optional[str]): Name of specific matrix to use, or None for default.
    default_flow_policy_config (FlowPolicyConfig): Default FlowPolicy if
        a TrafficDemand does not specify one.
    graph (StrictMultiDiGraph): Active graph built from the network.
    demands (List[Demand]): All expanded demands from the active matrix.
    _td_to_demands (Dict[str, List[Demand]]): Internal mapping from
        TrafficDemand.id to its expanded Demand objects.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>network</code> (Union[Network, 'NetworkView'])</li>
<li><code>traffic_matrix_set</code> ('TrafficMatrixSet')</li>
<li><code>matrix_name</code> (Optional[str])</li>
<li><code>default_flow_policy_config</code> (FlowPolicyConfig) = 1</li>
<li><code>graph</code> (Optional[StrictMultiDiGraph])</li>
<li><code>demands</code> (List[Demand]) = []</li>
<li><code>_td_to_demands</code> (Dict[str, List[Demand]]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>build_graph(self, add_reverse: 'bool' = True) -&gt; 'None'</code> - Build or rebuild the internal <code>StrictMultiDiGraph</code> from <code>network</code>.</li>
<li><code>expand_demands(self) -&gt; 'None'</code> - Expand each <code>TrafficDemand</code> into one or more <code>Demand</code> objects.</li>
<li><code>get_flow_details(self) -&gt; 'Dict[Tuple[int, int], Dict[str, object]]'</code> - Summarize flows from each demand's policy.</li>
<li><code>get_traffic_results(self, detailed: 'bool' = False) -&gt; 'List[TrafficResult]'</code> - Return traffic demand summaries.</li>
<li><code>place_all_demands(self, placement_rounds: 'Union[int, str]' = 'auto', reoptimize_after_each_round: 'bool' = False) -&gt; 'float'</code> - Place all expanded demands in ascending priority order.</li>
<li><code>reset_all_flow_usages(self) -&gt; 'None'</code> - Remove flow usage for each demand and reset placements to 0.</li>
<li><code>summarize_link_usage(self) -&gt; 'Dict[str, float]'</code> - Return total flow usage per edge in the graph.</li>
</ul>
<h3 id="trafficresult">TrafficResult<a class="headerlink" href="#trafficresult" title="Permanent link">&para;</a></h3>
<p>Traffic demand result entry.</p>
<p>Attributes:
    priority: Demand priority class (lower value is more critical).
    total_volume: Total traffic volume for this entry.
    placed_volume: Volume actually placed in the flow graph.
    unplaced_volume: Volume not placed (<code>total_volume - placed_volume</code>).
    src: Source node or path.
    dst: Destination node or path.</p>
<hr />
<h2 id="ngraphdemandmanagerschedule">ngraph.demand.manager.schedule<a class="headerlink" href="#ngraphdemandmanagerschedule" title="Permanent link">&para;</a></h2>
<p>Scheduling utilities for demand placement rounds.</p>
<p>Provides the simple priority-aware round-robin scheduler that was previously
implemented in <code>TrafficManager</code>.</p>
<h3 id="place_demands_round_robingraph-strictmultidigraph-demands-listdemand-placement_rounds-int-reoptimize_after_each_round-bool-false-float">place_demands_round_robin(graph: 'StrictMultiDiGraph', demands: 'List[Demand]', placement_rounds: 'int', reoptimize_after_each_round: 'bool' = False) -&gt; 'float'<a class="headerlink" href="#place_demands_round_robingraph-strictmultidigraph-demands-listdemand-placement_rounds-int-reoptimize_after_each_round-bool-false-float" title="Permanent link">&para;</a></h3>
<p>Place demands using priority buckets and round-robin within each bucket.</p>
<p>Args:
    graph: Active flow graph.
    demands: Expanded demands to place.
    placement_rounds: Number of passes per priority class.
    reoptimize_after_each_round: Whether to re-run placement for each demand
        after a round to better share capacity.</p>
<p>Returns:
    Total volume successfully placed across all demands.</p>
<hr />
<h2 id="ngraphdemandmatrix">ngraph.demand.matrix<a class="headerlink" href="#ngraphdemandmatrix" title="Permanent link">&para;</a></h2>
<p>Traffic matrix containers.</p>
<p>Provides <code>TrafficMatrixSet</code>, a named collection of <code>TrafficDemand</code> lists
used as input to demand expansion and placement. This module contains input
containers, not analysis results.</p>
<h3 id="trafficmatrixset">TrafficMatrixSet<a class="headerlink" href="#trafficmatrixset" title="Permanent link">&para;</a></h3>
<p>Named collection of TrafficDemand lists.</p>
<p>This mutable container maps scenario names to lists of TrafficDemand objects,
allowing management of multiple traffic matrices for analysis.</p>
<p>Attributes:
    matrices: Dictionary mapping scenario names to TrafficDemand lists.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>matrices</code> (dict[str, list[TrafficDemand]]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add(self, name: 'str', demands: 'list[TrafficDemand]') -&gt; 'None'</code> - Add a traffic matrix to the collection.</li>
<li><code>get_all_demands(self) -&gt; 'list[TrafficDemand]'</code> - Get all traffic demands from all matrices combined.</li>
<li><code>get_default_matrix(self) -&gt; 'list[TrafficDemand]'</code> - Get default traffic matrix.</li>
<li><code>get_matrix(self, name: 'str') -&gt; 'list[TrafficDemand]'</code> - Get a specific traffic matrix by name.</li>
<li><code>to_dict(self) -&gt; 'dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphdemandspec">ngraph.demand.spec<a class="headerlink" href="#ngraphdemandspec" title="Permanent link">&para;</a></h2>
<p>Traffic demand specification.</p>
<p>Defines <code>TrafficDemand</code>, a user-facing specification used by demand expansion
and placement. It can carry either a concrete <code>FlowPolicy</code> instance or a
<code>FlowPolicyConfig</code> enum to construct one.</p>
<h3 id="trafficdemand">TrafficDemand<a class="headerlink" href="#trafficdemand" title="Permanent link">&para;</a></h3>
<p>Single traffic demand input.</p>
<p>Attributes:
    source_path: Regex string selecting source nodes.
    sink_path: Regex string selecting sink nodes.
    priority: Priority class for this demand (lower value = higher priority).
    demand: Total demand volume.
    demand_placed: Portion of this demand placed so far.
    flow_policy_config: Policy configuration used to build a <code>FlowPolicy</code> if
        <code>flow_policy</code> is not provided.
    flow_policy: Concrete policy instance. If set, it overrides
        <code>flow_policy_config</code>.
    mode: Expansion mode, <code>"combine"</code> or <code>"pairwise"</code>.
    attrs: Arbitrary user metadata.
    id: Unique identifier assigned at initialization.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source_path</code> (str)</li>
<li><code>sink_path</code> (str)</li>
<li><code>priority</code> (int) = 0</li>
<li><code>demand</code> (float) = 0.0</li>
<li><code>demand_placed</code> (float) = 0.0</li>
<li><code>flow_policy_config</code> (Optional)</li>
<li><code>flow_policy</code> (Optional)</li>
<li><code>mode</code> (str) = combine</li>
<li><code>attrs</code> (Dict) = {}</li>
<li><code>id</code> (str)</li>
</ul>
<hr />
<h2 id="ngraphfailureconditions">ngraph.failure.conditions<a class="headerlink" href="#ngraphfailureconditions" title="Permanent link">&para;</a></h2>
<p>Shared condition primitives and evaluators.</p>
<p>This module provides a small, dependency-free condition evaluation utility
that can be reused by failure policies and DSL selection filters.</p>
<p>Operators supported:</p>
<ul>
<li>==, !=, &lt;, &lt;=, &gt;, &gt;=</li>
<li>contains, not_contains</li>
<li>any_value, no_value</li>
</ul>
<p>The evaluator operates on a flat attribute mapping for an entity. Callers are
responsible for constructing that mapping (e.g. merging top-level fields with
<code>attrs</code> and ensuring appropriate precedence rules).</p>
<h3 id="failurecondition">FailureCondition<a class="headerlink" href="#failurecondition" title="Permanent link">&para;</a></h3>
<p>A single condition for matching an entity attribute.</p>
<p>Args:
    attr: Attribute name to inspect in the entity mapping.
    operator: Comparison operator. See module docstring for the list.
    value: Right-hand operand for the comparison (unused for any_value/no_value).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>attr</code> (str)</li>
<li><code>operator</code> (str)</li>
<li><code>value</code> (Any | None)</li>
</ul>
<h3 id="evaluate_conditionentity_attrs-dictstr-any-cond-failurecondition-bool">evaluate_condition(entity_attrs: 'dict[str, Any]', cond: 'FailureCondition') -&gt; 'bool'<a class="headerlink" href="#evaluate_conditionentity_attrs-dictstr-any-cond-failurecondition-bool" title="Permanent link">&para;</a></h3>
<p>Evaluate a single condition against an entity attribute mapping.</p>
<p>Args:
    entity_attrs: Flat mapping of attributes for the entity.
    cond: Condition to evaluate.</p>
<p>Returns:
    True if the condition passes, False otherwise.</p>
<h3 id="evaluate_conditionsentity_attrs-dictstr-any-conditions-iterablefailurecondition-logic-str-bool">evaluate_conditions(entity_attrs: 'dict[str, Any]', conditions: 'Iterable[FailureCondition]', logic: 'str') -&gt; 'bool'<a class="headerlink" href="#evaluate_conditionsentity_attrs-dictstr-any-conditions-iterablefailurecondition-logic-str-bool" title="Permanent link">&para;</a></h3>
<p>Evaluate multiple conditions with AND/OR logic.</p>
<p>Args:
    entity_attrs: Flat mapping of attributes for the entity.
    conditions: Iterable of conditions to evaluate.
    logic: "and" or "or".</p>
<p>Returns:
    True if the combined predicate passes, False otherwise.</p>
<hr />
<h2 id="ngraphfailuremanageraggregate">ngraph.failure.manager.aggregate<a class="headerlink" href="#ngraphfailuremanageraggregate" title="Permanent link">&para;</a></h2>
<p>Aggregation helpers for failure analysis results.</p>
<p>Utilities in this module group and summarize outputs produced by
<code>FailureManager</code> runs. Functions are factored here to keep <code>manager.py</code>
focused on orchestration. This module intentionally avoids importing heavy
dependencies to keep import cost low in the common path.</p>
<hr />
<h2 id="ngraphfailuremanagerenumerate">ngraph.failure.manager.enumerate<a class="headerlink" href="#ngraphfailuremanagerenumerate" title="Permanent link">&para;</a></h2>
<p>Failure pattern enumeration helpers.</p>
<p>Hosts utilities for generating or iterating over failure patterns for testing
and analysis workflows. These helpers are separate from the Monte Carlo engine
to keep the main manager small and focused.</p>
<hr />
<h2 id="ngraphfailuremanagermanager">ngraph.failure.manager.manager<a class="headerlink" href="#ngraphfailuremanagermanager" title="Permanent link">&para;</a></h2>
<p>FailureManager for Monte Carlo failure analysis.</p>
<p>Provides the failure analysis engine for NetGraph. Supports parallel
processing, per-worker caching, and failure policy handling for workflow steps
and direct programmatic use.</p>
<p>Performance characteristics:
Time complexity: O(I × A / P), where I is iteration count, A is analysis cost,
and P is parallelism. Worker-local caching reduces repeated work when exclusion
sets repeat across iterations. Network serialization happens once per worker,
not per iteration.</p>
<p>Space complexity: O(V + E + I × R + C), where V and E are node and link counts,
R is result size per iteration, and C is cache size. The per-worker cache is
bounded and evicts in FIFO order after 1000 unique patterns.</p>
<p>Parallelism: For small iteration counts, serial execution avoids IPC overhead.
For larger workloads, parallel execution benefits from worker caching and CPU
utilization. Optimal parallelism is the number of CPU cores for analysis-bound
workloads.</p>
<h3 id="analysisfunction">AnalysisFunction<a class="headerlink" href="#analysisfunction" title="Permanent link">&para;</a></h3>
<p>Protocol for analysis functions used with FailureManager.</p>
<p>Analysis functions should take a NetworkView and any additional
keyword arguments, returning analysis results of any type.</p>
<h3 id="failuremanager">FailureManager<a class="headerlink" href="#failuremanager" title="Permanent link">&para;</a></h3>
<p>Failure analysis engine with Monte Carlo capabilities.</p>
<p>This is the component for failure analysis in NetGraph.
Provides parallel processing, worker caching, and failure
policy handling for workflow steps and direct notebook usage.</p>
<p>The FailureManager can execute any analysis function that takes a NetworkView
and returns results, making it generic for different types of
failure analysis (capacity, traffic, connectivity, etc.).</p>
<p>Attributes:
    network: The underlying network (not modified during analysis).
    failure_policy_set: Set of named failure policies.
    policy_name: Name of specific failure policy to use.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>compute_exclusions(self, policy: "'FailurePolicy | None'" = None, seed_offset: 'int | None' = None) -&gt; 'tuple[set[str], set[str]]'</code> - Compute set of nodes and links to exclude for a failure iteration.</li>
<li><code>create_network_view(self, excluded_nodes: 'set[str] | None' = None, excluded_links: 'set[str] | None' = None) -&gt; 'NetworkView'</code> - Create NetworkView with specified exclusions.</li>
<li><code>get_failure_policy(self) -&gt; "'FailurePolicy | None'"</code> - Get failure policy for analysis.</li>
<li><code>run_demand_placement_monte_carlo(self, demands_config: 'list[dict[str, Any]] | Any', iterations: 'int' = 100, parallelism: 'int' = 1, placement_rounds: 'int | str' = 'auto', baseline: 'bool' = False, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, **kwargs) -&gt; 'Any'</code> - Analyze traffic demand placement success under failures.</li>
<li><code>run_max_flow_monte_carlo(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', iterations: 'int' = 100, parallelism: 'int' = 1, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement | str' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, baseline: 'bool' = False, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, include_flow_summary: 'bool' = False, **kwargs) -&gt; 'Any'</code> - Analyze maximum flow capacity envelopes between node groups under failures.</li>
<li><code>run_monte_carlo_analysis(self, analysis_func: 'AnalysisFunction', iterations: 'int' = 1, parallelism: 'int' = 1, baseline: 'bool' = False, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, **analysis_kwargs) -&gt; 'dict[str, Any]'</code> - Run Monte Carlo failure analysis with any analysis function.</li>
<li><code>run_sensitivity_monte_carlo(self, source_path: 'str', sink_path: 'str', mode: 'str' = 'combine', iterations: 'int' = 100, parallelism: 'int' = 1, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement | str' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, baseline: 'bool' = False, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, **kwargs) -&gt; 'Any'</code> - Analyze component criticality for flow capacity under failures.</li>
<li><code>run_single_failure_scenario(self, analysis_func: 'AnalysisFunction', **kwargs) -&gt; 'Any'</code> - Run a single failure scenario for convenience.</li>
</ul>
<hr />
<h2 id="ngraphfailuremanagersimulate">ngraph.failure.manager.simulate<a class="headerlink" href="#ngraphfailuremanagersimulate" title="Permanent link">&para;</a></h2>
<p>Simulation helpers for failure analyses.</p>
<p>Contains small helpers used to drive simulations in tests and examples. The
main orchestration lives in <code>manager.py</code>.</p>
<hr />
<h2 id="ngraphfailurepolicy">ngraph.failure.policy<a class="headerlink" href="#ngraphfailurepolicy" title="Permanent link">&para;</a></h2>
<p>Failure policy primitives.</p>
<p>Defines <code>FailureCondition</code>, <code>FailureRule</code>, and <code>FailurePolicy</code> for expressing
how nodes, links, and risk groups fail in analyses. Conditions match on
top-level attributes with simple operators; rules select matches using
"all", probabilistic "random" (with <code>probability</code>), or fixed-size "choice"
(with <code>count</code>). Policies can optionally expand failures by shared risk groups
or by risk-group children.</p>
<h3 id="failurecondition_1">FailureCondition<a class="headerlink" href="#failurecondition_1" title="Permanent link">&para;</a></h3>
<p>Alias to the shared condition dataclass.</p>
<p>This maintains a consistent import path within the failure policy module.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>attr</code> (str)</li>
<li><code>operator</code> (str)</li>
<li><code>value</code> (Any | None)</li>
</ul>
<h3 id="failuremode">FailureMode<a class="headerlink" href="#failuremode" title="Permanent link">&para;</a></h3>
<p>A weighted mode that encapsulates a set of rules applied together.</p>
<p>Exactly one mode is selected per failure iteration according to the
mode weights. Within a mode, all contained rules are applied and their
selections are unioned into the failure set.</p>
<p>Attributes:
    weight: Non-negative weight used for mode selection. All weights are
        normalized internally. Modes with zero weight are never selected.
    rules: A list of <code>FailureRule</code> applied together when this mode is chosen.
    attrs: Optional metadata.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>weight</code> (float)</li>
<li><code>rules</code> (List[FailureRule]) = []</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="failurepolicy">FailurePolicy<a class="headerlink" href="#failurepolicy" title="Permanent link">&para;</a></h3>
<p>A container for multiple FailureRules plus optional metadata in <code>attrs</code>.</p>
<p>The main entry point is <code>apply_failures</code>, which:
  1) For each rule, gather the relevant entities (node, link, or risk_group).
          2) Match them based on rule conditions using 'and' or 'or' logic.
  3) Apply the selection strategy (all, random, or choice).
  4) Collect the union of all failed entities across all rules.
  5) Optionally expand failures by shared-risk groups or sub-risks.</p>
<p>Example YAML configuration:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="nt">failure_policy</span><span class="p">:</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="w">  </span><span class="nt">attrs</span><span class="p">:</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Regional</span><span class="nv"> </span><span class="s">power</span><span class="nv"> </span><span class="s">grid</span><span class="nv"> </span><span class="s">failure</span><span class="nv"> </span><span class="s">affecting</span><span class="nv"> </span><span class="s">telecom</span><span class="nv"> </span><span class="s">infrastructure&quot;</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">  </span><span class="nt">fail_risk_groups</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">  </span><span class="nt">rules</span><span class="p">:</span>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="w">    </span><span class="c1"># Fail all nodes in Texas electrical grid</span>
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">entity_scope</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;node&quot;</span>
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="w">      </span><span class="nt">conditions</span><span class="p">:</span>
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">attr</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;electric_grid&quot;</span>
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a>
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="w">          </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;==&quot;</span>
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="w">          </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;texas&quot;</span>
</span><span id="__span-1-14"><a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a><span class="w">      </span><span class="nt">logic</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;and&quot;</span>
</span><span id="__span-1-15"><a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a><span class="w">      </span><span class="nt">rule_type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;all&quot;</span>
</span><span id="__span-1-16"><a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a>
</span><span id="__span-1-17"><a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a><span class="w">    </span><span class="c1"># Randomly fail 40% of underground fiber links in affected region</span>
</span><span id="__span-1-18"><a id="__codelineno-1-18" name="__codelineno-1-18" href="#__codelineno-1-18"></a><span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">entity_scope</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;link&quot;</span>
</span><span id="__span-1-19"><a id="__codelineno-1-19" name="__codelineno-1-19" href="#__codelineno-1-19"></a>
</span><span id="__span-1-20"><a id="__codelineno-1-20" name="__codelineno-1-20" href="#__codelineno-1-20"></a><span class="w">      </span><span class="nt">conditions</span><span class="p">:</span>
</span><span id="__span-1-21"><a id="__codelineno-1-21" name="__codelineno-1-21" href="#__codelineno-1-21"></a><span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">attr</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;region&quot;</span>
</span><span id="__span-1-22"><a id="__codelineno-1-22" name="__codelineno-1-22" href="#__codelineno-1-22"></a>
</span><span id="__span-1-23"><a id="__codelineno-1-23" name="__codelineno-1-23" href="#__codelineno-1-23"></a><span class="w">          </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;==&quot;</span>
</span><span id="__span-1-24"><a id="__codelineno-1-24" name="__codelineno-1-24" href="#__codelineno-1-24"></a><span class="w">          </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;southwest&quot;</span>
</span><span id="__span-1-25"><a id="__codelineno-1-25" name="__codelineno-1-25" href="#__codelineno-1-25"></a><span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">attr</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;installation&quot;</span>
</span><span id="__span-1-26"><a id="__codelineno-1-26" name="__codelineno-1-26" href="#__codelineno-1-26"></a>
</span><span id="__span-1-27"><a id="__codelineno-1-27" name="__codelineno-1-27" href="#__codelineno-1-27"></a><span class="w">          </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;==&quot;</span>
</span><span id="__span-1-28"><a id="__codelineno-1-28" name="__codelineno-1-28" href="#__codelineno-1-28"></a><span class="w">          </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;underground&quot;</span>
</span><span id="__span-1-29"><a id="__codelineno-1-29" name="__codelineno-1-29" href="#__codelineno-1-29"></a><span class="w">      </span><span class="nt">logic</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;and&quot;</span>
</span><span id="__span-1-30"><a id="__codelineno-1-30" name="__codelineno-1-30" href="#__codelineno-1-30"></a><span class="w">      </span><span class="nt">rule_type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;random&quot;</span>
</span><span id="__span-1-31"><a id="__codelineno-1-31" name="__codelineno-1-31" href="#__codelineno-1-31"></a><span class="w">      </span><span class="nt">probability</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0.4</span>
</span><span id="__span-1-32"><a id="__codelineno-1-32" name="__codelineno-1-32" href="#__codelineno-1-32"></a>
</span><span id="__span-1-33"><a id="__codelineno-1-33" name="__codelineno-1-33" href="#__codelineno-1-33"></a><span class="w">    </span><span class="c1"># Choose exactly 2 risk groups to fail (e.g., data centers)</span>
</span><span id="__span-1-34"><a id="__codelineno-1-34" name="__codelineno-1-34" href="#__codelineno-1-34"></a><span class="w">    </span><span class="c1"># Note: logic defaults to &quot;or&quot; when not specified</span>
</span><span id="__span-1-35"><a id="__codelineno-1-35" name="__codelineno-1-35" href="#__codelineno-1-35"></a><span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">entity_scope</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;risk_group&quot;</span>
</span><span id="__span-1-36"><a id="__codelineno-1-36" name="__codelineno-1-36" href="#__codelineno-1-36"></a>
</span><span id="__span-1-37"><a id="__codelineno-1-37" name="__codelineno-1-37" href="#__codelineno-1-37"></a><span class="w">      </span><span class="nt">rule_type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;choice&quot;</span>
</span><span id="__span-1-38"><a id="__codelineno-1-38" name="__codelineno-1-38" href="#__codelineno-1-38"></a><span class="w">      </span><span class="nt">count</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span>
</span></code></pre></div></p>
<p>Attributes:
    rules (List[FailureRule]):
        A list of FailureRules to apply.
    attrs (Dict[str, Any]):
        Arbitrary metadata about this policy (e.g. "name", "description").
    fail_risk_groups (bool):
        If True, after initial selection, expand failures among any
        node/link that shares a risk group with a failed entity.
    fail_risk_group_children (bool):
        If True, and if a risk_group is marked as failed, expand to
        children risk_groups recursively.
    seed (Optional[int]):
        Seed for reproducible random operations. If None, operations
        will be non-deterministic.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>fail_risk_groups</code> (bool) = False</li>
<li><code>fail_risk_group_children</code> (bool) = False</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>modes</code> (List[FailureMode]) = []</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>apply_failures(self, network_nodes: 'Dict[str, Any]', network_links: 'Dict[str, Any]', network_risk_groups: 'Dict[str, Any] | None' = None, *, seed: 'Optional[int]' = None) -&gt; 'List[str]'</code> - Identify which entities fail for this iteration.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<h3 id="failurerule">FailureRule<a class="headerlink" href="#failurerule" title="Permanent link">&para;</a></h3>
<p>Defines how to match and then select entities for failure.</p>
<p>Attributes:
    entity_scope (EntityScope):
        The type of entities this rule applies to: "node", "link", or "risk_group".
    conditions (List[FailureCondition]):
        A list of conditions to filter matching entities.
    logic (Literal["and", "or"]):
        "and": All conditions must be true for a match.
        "or": At least one condition is true for a match (default).
    rule_type (Literal["random", "choice", "all"]):
        The selection strategy among the matched set:</p>
<ul>
<li>"random": each matched entity is chosen with probability = <code>probability</code>.</li>
<li>"choice": pick exactly <code>count</code> items from the matched set (random sample).</li>
<li>
<p>"all": select every matched entity in the matched set.</p>
<p>probability (float):
    Probability in [0,1], used if <code>rule_type="random"</code>.
count (int):
    Number of entities to pick if <code>rule_type="choice"</code>.</p>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>entity_scope</code> (EntityScope)</li>
<li><code>conditions</code> (List[FailureCondition]) = []</li>
<li><code>logic</code> (Literal['and', 'or']) = or</li>
<li><code>rule_type</code> (Literal['random', 'choice', 'all']) = all</li>
<li><code>probability</code> (float) = 1.0</li>
<li><code>count</code> (int) = 1</li>
<li><code>weight_by</code> (Optional[str])</li>
</ul>
<hr />
<h2 id="ngraphfailurepolicy_set">ngraph.failure.policy_set<a class="headerlink" href="#ngraphfailurepolicy_set" title="Permanent link">&para;</a></h2>
<p>Failure policy containers.</p>
<p>Provides <code>FailurePolicySet</code>, a named collection of <code>FailurePolicy</code> objects
used as input to failure analysis workflows. This module contains input
containers, not analysis results.</p>
<h3 id="failurepolicyset">FailurePolicySet<a class="headerlink" href="#failurepolicyset" title="Permanent link">&para;</a></h3>
<p>Named collection of FailurePolicy objects.</p>
<p>This mutable container maps failure policy names to FailurePolicy objects,
allowing management of multiple failure policies for analysis.</p>
<p>Attributes:
    policies: Dictionary mapping failure policy names to FailurePolicy objects.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>policies</code> (dict[str, FailurePolicy]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add(self, name: 'str', policy: 'FailurePolicy') -&gt; 'None'</code> - Add a failure policy to the collection.</li>
<li><code>get_all_policies(self) -&gt; 'list[FailurePolicy]'</code> - Get all failure policies from the collection.</li>
<li><code>get_policy(self, name: 'str') -&gt; 'FailurePolicy'</code> - Get a specific failure policy by name.</li>
<li><code>to_dict(self) -&gt; 'dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphworkflowbase">ngraph.workflow.base<a class="headerlink" href="#ngraphworkflowbase" title="Permanent link">&para;</a></h2>
<p>Base classes for workflow automation.</p>
<p>Defines the workflow step abstraction, registration decorator, and execution
wrapper that adds timing and logging. Steps implement <code>run()</code> and are executed
via <code>execute()</code> which records metadata and re-raises failures.</p>
<h3 id="workflowstep">WorkflowStep<a class="headerlink" href="#workflowstep" title="Permanent link">&para;</a></h3>
<p>Base class for all workflow steps.</p>
<p>All workflow steps are automatically logged with execution timing information.
All workflow steps support seeding for reproducible random operations.
Workflow metadata is automatically stored in scenario.results for analysis.</p>
<p>YAML Configuration:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">step_type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;StepTypeName&gt;</span>
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;optional_step_name&quot;</span><span class="w">  </span><span class="c1"># Optional: Custom name for this step instance</span>
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="w">    </span><span class="nt">seed</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">42</span><span class="w">                    </span><span class="c1"># Optional: Seed for reproducible random operations</span>
</span><span id="__span-2-6"><a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a><span class="w">    </span><span class="c1"># ... step-specific parameters ...</span>
</span></code></pre></div></p>
<p>Attributes:
    name: Optional custom identifier for this workflow step instance,
        used for logging and result storage purposes.
    seed: Optional seed for reproducible random operations. If None,
        random operations will be non-deterministic.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<h3 id="register_workflow_stepstep_type-str">register_workflow_step(step_type: 'str')<a class="headerlink" href="#register_workflow_stepstep_type-str" title="Permanent link">&para;</a></h3>
<p>Return a decorator that registers a <code>WorkflowStep</code> subclass.</p>
<p>Args:
    step_type: Registry key used to instantiate steps from configuration.</p>
<p>Returns:
    A class decorator that adds the class to <code>WORKFLOW_STEP_REGISTRY</code>.</p>
<hr />
<h2 id="ngraphworkflowbuild_graph">ngraph.workflow.build_graph<a class="headerlink" href="#ngraphworkflowbuild_graph" title="Permanent link">&para;</a></h2>
<p>Graph building workflow component.</p>
<p>Converts scenario network definitions into StrictMultiDiGraph structures suitable
for analysis algorithms. No additional parameters required beyond basic workflow step options.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">step_type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">BuildGraph</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;build_network_graph&quot;</span><span class="w">  </span><span class="c1"># Optional: Custom name for this step</span>
</span></code></pre></div></p>
<p>Results stored in <code>scenario.results</code> under the step name as two keys:</p>
<ul>
<li>metadata: Step-level execution metadata (empty dict)</li>
<li>data: { graph: node-link JSON dict, context: { add_reverse: bool } }</li>
</ul>
<h3 id="buildgraph">BuildGraph<a class="headerlink" href="#buildgraph" title="Permanent link">&para;</a></h3>
<p>A workflow step that builds a StrictMultiDiGraph from scenario.network.</p>
<p>This step converts the scenario's network definition into a graph structure
suitable for analysis algorithms. No additional parameters are required.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Scenario') -&gt; 'None'</code> - Build the network graph and store it in results.</li>
</ul>
<hr />
<h2 id="ngraphworkflowcost_power">ngraph.workflow.cost_power<a class="headerlink" href="#ngraphworkflowcost_power" title="Permanent link">&para;</a></h2>
<p>CostPower workflow step: collect capex and power by hierarchy level.</p>
<p>This step aggregates capex and power from the network hardware inventory without
performing any normalization or reporting. It separates contributions into two
categories:</p>
<ul>
<li>platform_*: node hardware (e.g., chassis, linecards) resolved from node attrs</li>
<li>optics_*: per-end link hardware (e.g., optics) resolved from link attrs</li>
</ul>
<p>Aggregation is computed at hierarchy levels 0..N where level 0 is the global
root (path ""), and higher levels correspond to prefixes of node names split by
"/". For example, for node "dc1/plane1/leaf/leaf-1":</p>
<ul>
<li>level 1 path is "dc1"</li>
<li>level 2 path is "dc1/plane1"</li>
<li>etc.</li>
</ul>
<p>Disabled handling:</p>
<ul>
<li>When include_disabled is False, only enabled nodes and links are considered.</li>
<li>Optics are counted only when the endpoint node has platform hardware.</li>
</ul>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">step_type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">CostPower</span>
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;cost_power&quot;</span><span class="w">           </span><span class="c1"># Optional custom name</span>
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="w">    </span><span class="nt">include_disabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span><span class="w">       </span><span class="c1"># Default: only enabled nodes/links</span>
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="w">    </span><span class="nt">aggregation_level</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span><span class="w">          </span><span class="c1"># Produce levels: 0, 1, 2</span>
</span></code></pre></div></p>
<p>Results stored in <code>scenario.results</code> under this step namespace:
    data:
      context:
        include_disabled: bool
        aggregation_level: int
      levels:
        "0":</p>
<ul>
<li>path: ""<div class="language-text highlight"><pre><span></span><code>    platform_capex: float
    platform_power_watts: float
    optics_capex: float
    optics_power_watts: float
    capex_total: float
    power_total_watts: float
&quot;1&quot;: [ ... ]
&quot;2&quot;: [ ... ]
</code></pre></div>
</li>
</ul>
<h3 id="costpower">CostPower<a class="headerlink" href="#costpower" title="Permanent link">&para;</a></h3>
<p>Collect platform and optics capex/power by aggregation level.</p>
<p>Attributes:
    include_disabled: If True, include disabled nodes and links.
    aggregation_level: Inclusive depth for aggregation. 0=root only.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>include_disabled</code> (bool) = False</li>
<li><code>aggregation_level</code> (int) = 2</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Any') -&gt; 'None'</code> - Aggregate capex and power by hierarchy levels 0..N.</li>
</ul>
<hr />
<h2 id="ngraphworkflowmax_flow_step">ngraph.workflow.max_flow_step<a class="headerlink" href="#ngraphworkflowmax_flow_step" title="Permanent link">&para;</a></h2>
<p>MaxFlow workflow step.</p>
<p>Monte Carlo analysis of maximum flow capacity between node groups using FailureManager.
Produces unified <code>flow_results</code> per iteration under <code>data.flow_results</code>.</p>
<p>YAML Configuration Example:</p>
<div class="language-text highlight"><pre><span></span><code>workflow:
</code></pre></div>
<ul>
<li>step_type: MaxFlow<div class="language-text highlight"><pre><span></span><code>name: &quot;maxflow_dc_to_edge&quot;
source_path: &quot;^datacenter/.*&quot;
sink_path: &quot;^edge/.*&quot;
mode: &quot;combine&quot;
failure_policy: &quot;random_failures&quot;
iterations: 100
parallelism: auto
shortest_path: false
flow_placement: &quot;PROPORTIONAL&quot;
baseline: false
seed: 42
store_failure_patterns: false
include_flow_details: false      # cost_distribution
include_min_cut: false           # min-cut edges list
</code></pre></div>
</li>
</ul>
<h3 id="maxflow">MaxFlow<a class="headerlink" href="#maxflow" title="Permanent link">&para;</a></h3>
<p>Maximum flow Monte Carlo workflow step.</p>
<p>Attributes:
    source_path: Regex pattern for source node groups.
    sink_path: Regex pattern for sink node groups.
    mode: Flow analysis mode ("combine" or "pairwise").
    failure_policy: Name of failure policy in scenario.failure_policy_set.
    iterations: Number of Monte Carlo trials.
    parallelism: Number of parallel worker processes.
    shortest_path: Whether to use shortest paths only.
    flow_placement: Flow placement strategy.
    baseline: Whether to run first iteration without failures as baseline.
    seed: Optional seed for reproducible results.
    store_failure_patterns: Whether to store failure patterns in results.
    include_flow_details: Whether to collect cost distribution per flow.
    include_min_cut: Whether to include min-cut edges per flow.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (int | None)</li>
<li><code>_seed_source</code> (str)</li>
<li><code>source_path</code> (str)</li>
<li><code>sink_path</code> (str)</li>
<li><code>mode</code> (str) = combine</li>
<li><code>failure_policy</code> (str | None)</li>
<li><code>iterations</code> (int) = 1</li>
<li><code>parallelism</code> (int | str) = auto</li>
<li><code>shortest_path</code> (bool) = False</li>
<li><code>flow_placement</code> (FlowPlacement | str) = 1</li>
<li><code>baseline</code> (bool) = False</li>
<li><code>store_failure_patterns</code> (bool) = False</li>
<li><code>include_flow_details</code> (bool) = False</li>
<li><code>include_min_cut</code> (bool) = False</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphworkflowmaximum_supported_demand_step">ngraph.workflow.maximum_supported_demand_step<a class="headerlink" href="#ngraphworkflowmaximum_supported_demand_step" title="Permanent link">&para;</a></h2>
<p>Maximum Supported Demand (MSD) workflow step.</p>
<p>Searches for the maximum uniform traffic multiplier <code>alpha_star</code> that is fully
placeable for a given matrix. Stores results under <code>data</code> as:</p>
<ul>
<li><code>alpha_star</code>: float</li>
<li><code>context</code>: parameters used for the search</li>
<li><code>base_demands</code>: serialized base demand specs</li>
<li><code>probes</code>: bracket/bisect evaluations with feasibility</li>
</ul>
<h3 id="maximumsupporteddemand">MaximumSupportedDemand<a class="headerlink" href="#maximumsupporteddemand" title="Permanent link">&para;</a></h3>
<p>MaximumSupportedDemand(name: 'str' = '', seed: 'Optional[int]' = None, _seed_source: 'str' = '', matrix_name: 'str' = 'default', acceptance_rule: 'str' = 'hard', alpha_start: 'float' = 1.0, growth_factor: 'float' = 2.0, alpha_min: 'float' = 1e-06, alpha_max: 'float' = 1000000000.0, resolution: 'float' = 0.01, max_bracket_iters: 'int' = 32, max_bisect_iters: 'int' = 32, seeds_per_alpha: 'int' = 1, placement_rounds: 'int | str' = 'auto')</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>matrix_name</code> (str) = default</li>
<li><code>acceptance_rule</code> (str) = hard</li>
<li><code>alpha_start</code> (float) = 1.0</li>
<li><code>growth_factor</code> (float) = 2.0</li>
<li><code>alpha_min</code> (float) = 1e-06</li>
<li><code>alpha_max</code> (float) = 1000000000.0</li>
<li><code>resolution</code> (float) = 0.01</li>
<li><code>max_bracket_iters</code> (int) = 32</li>
<li><code>max_bisect_iters</code> (int) = 32</li>
<li><code>seeds_per_alpha</code> (int) = 1</li>
<li><code>placement_rounds</code> (int | str) = auto</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Any'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphworkflownetwork_stats">ngraph.workflow.network_stats<a class="headerlink" href="#ngraphworkflownetwork_stats" title="Permanent link">&para;</a></h2>
<p>Workflow step for basic node and link statistics.</p>
<p>Computes and stores network statistics including node/link counts,
capacity distributions, cost distributions, and degree distributions. Supports
optional exclusion simulation and disabled entity handling.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">step_type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">NetworkStats</span>
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;network_statistics&quot;</span><span class="w">           </span><span class="c1"># Optional: Custom name for this step</span>
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="w">    </span><span class="nt">include_disabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span><span class="w">              </span><span class="c1"># Include disabled nodes/links in stats</span>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="w">    </span><span class="nt">excluded_nodes</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;node1&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;node2&quot;</span><span class="p p-Indicator">]</span><span class="w">   </span><span class="c1"># Optional: Temporary node exclusions</span>
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="w">    </span><span class="nt">excluded_links</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;link1&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;link3&quot;</span><span class="p p-Indicator">]</span><span class="w">   </span><span class="c1"># Optional: Temporary link exclusions</span>
</span></code></pre></div></p>
<p>Results stored in <code>scenario.results</code>:</p>
<ul>
<li>Node statistics: node_count</li>
<li>
<p>Link statistics: link_count, total_capacity, mean_capacity, median_capacity,</p>
<p>min_capacity, max_capacity, mean_cost, median_cost, min_cost, max_cost</p>
</li>
<li>
<p>Degree statistics: mean_degree, median_degree, min_degree, max_degree</p>
</li>
</ul>
<h3 id="networkstats">NetworkStats<a class="headerlink" href="#networkstats" title="Permanent link">&para;</a></h3>
<p>Compute basic node and link statistics for the network.</p>
<p>Supports optional exclusion simulation using NetworkView without modifying the base network.</p>
<p>Attributes:
    include_disabled: If True, include disabled nodes and links in statistics.
        If False, only consider enabled entities.
    excluded_nodes: Optional list of node names to exclude (temporary exclusion).
    excluded_links: Optional list of link IDs to exclude (temporary exclusion).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>include_disabled</code> (bool) = False</li>
<li><code>excluded_nodes</code> (Iterable[str]) = ()</li>
<li><code>excluded_links</code> (Iterable[str]) = ()</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Scenario') -&gt; 'None'</code> - Compute and store network statistics.</li>
</ul>
<hr />
<h2 id="ngraphworkflowtraffic_matrix_placement_step">ngraph.workflow.traffic_matrix_placement_step<a class="headerlink" href="#ngraphworkflowtraffic_matrix_placement_step" title="Permanent link">&para;</a></h2>
<p>TrafficMatrixPlacement workflow step.</p>
<p>Runs Monte Carlo demand placement using a named traffic matrix and produces
unified <code>flow_results</code> per iteration under <code>data.flow_results</code>.</p>
<h3 id="trafficmatrixplacement">TrafficMatrixPlacement<a class="headerlink" href="#trafficmatrixplacement" title="Permanent link">&para;</a></h3>
<p>Monte Carlo demand placement using a named traffic matrix.</p>
<p>Attributes:
    matrix_name: Name of the traffic matrix to analyze.
    failure_policy: Optional policy name in scenario.failure_policy_set.
    iterations: Number of Monte Carlo iterations.
    parallelism: Number of parallel worker processes.
    placement_rounds: Placement optimization rounds (int or "auto").
    baseline: Include baseline iteration without failures first.
    seed: Optional seed for reproducibility.
    store_failure_patterns: Whether to store failure pattern results.
    include_flow_details: When True, include cost_distribution per flow.
    include_used_edges: When True, include set of used edges per demand in entry data.
    alpha: Numeric scale for demands in the matrix.
    alpha_from_step: Optional producer step name to read alpha from.
    alpha_from_field: Dotted field path in producer step (default: "data.alpha_star").</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (int | None)</li>
<li><code>_seed_source</code> (str)</li>
<li><code>matrix_name</code> (str)</li>
<li><code>failure_policy</code> (str | None)</li>
<li><code>iterations</code> (int) = 1</li>
<li><code>parallelism</code> (int | str) = auto</li>
<li><code>placement_rounds</code> (int | str) = auto</li>
<li><code>baseline</code> (bool) = False</li>
<li><code>store_failure_patterns</code> (bool) = False</li>
<li><code>include_flow_details</code> (bool) = False</li>
<li><code>include_used_edges</code> (bool) = False</li>
<li><code>alpha</code> (float) = 1.0</li>
<li><code>alpha_from_step</code> (str | None)</li>
<li><code>alpha_from_field</code> (str) = data.alpha_star</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphdslblueprintsexpand">ngraph.dsl.blueprints.expand<a class="headerlink" href="#ngraphdslblueprintsexpand" title="Permanent link">&para;</a></h2>
<p>Network topology blueprints and generation.</p>
<h3 id="blueprint">Blueprint<a class="headerlink" href="#blueprint" title="Permanent link">&para;</a></h3>
<p>Represents a reusable blueprint for hierarchical sub-topologies.</p>
<p>A blueprint may contain multiple groups of nodes (each can have a node_count
and a name_template), plus adjacency rules describing how those groups connect.</p>
<p>Attributes:
    name (str): Unique identifier of this blueprint.
    groups (Dict[str, Any]): A mapping of group_name -&gt; group definition.
        Allowed top-level keys in each group definition here are the same
        as in normal group definitions (e.g. node_count, name_template,
        attrs, disabled, risk_groups, or nested use_blueprint references, etc.).
    adjacency (List[Dict[str, Any]]): A list of adjacency definitions
        describing how these groups are linked, using the DSL fields
        (source, target, pattern, link_params, etc.).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>groups</code> (Dict[str, Any])</li>
<li><code>adjacency</code> (List[Dict[str, Any]])</li>
</ul>
<h3 id="dslexpansioncontext">DSLExpansionContext<a class="headerlink" href="#dslexpansioncontext" title="Permanent link">&para;</a></h3>
<p>Carries the blueprint definitions and the final Network instance
to be populated during DSL expansion.</p>
<p>Attributes:
    blueprints (Dict[str, Blueprint]): Dictionary of blueprint-name -&gt; Blueprint.
    network (Network): The Network into which expanded nodes/links are inserted.
    pending_bp_adj (List[tuple[Dict[str, Any], str]]): Deferred blueprint adjacency
        expansions collected as (adj_def, parent_path) to be processed later.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>blueprints</code> (Dict[str, Blueprint])</li>
<li><code>network</code> (Network)</li>
<li><code>pending_bp_adj</code> (List[tuple[Dict[str, Any], str]]) = []</li>
</ul>
<h3 id="expand_network_dsldata-dictstr-any-network">expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'<a class="headerlink" href="#expand_network_dsldata-dictstr-any-network" title="Permanent link">&para;</a></h3>
<p>Expands a combined blueprint + network DSL into a complete Network object.</p>
<p>Overall flow:
  1) Parse "blueprints" into Blueprint objects.
  2) Build a new Network from "network" metadata (e.g. name, version).
  3) Expand 'network["groups"]' (collect blueprint adjacencies for later).</p>
<ul>
<li>
<p>If a group references a blueprint, incorporate that blueprint's subgroups</p>
<p>while merging parent's attrs + disabled + risk_groups into subgroups.
   Blueprint adjacency is deferred and processed after node overrides.</p>
</li>
<li>
<p>Otherwise, directly create nodes (a "direct node group").</p>
</li>
</ul>
<p>4) Process any direct node definitions (network["nodes"]).
  5) Process node overrides (in order if multiple overrides match).
  6) Expand deferred blueprint adjacencies.
  7) Expand adjacency definitions in 'network["adjacency"]'.
  8) Process any direct link definitions (network["links"]).
  9) Process link overrides (in order if multiple overrides match).</p>
<p>Under the new rules:</p>
<ul>
<li>
<p>Only certain top-level fields are permitted in each structure. Any extra</p>
<p>keys raise a ValueError. "attrs" is where arbitrary user fields go.</p>
</li>
<li>
<p>For link_params, recognized fields are "capacity", "cost", "disabled",</p>
<p>"risk_groups", "attrs". Everything else must go inside link_params["attrs"].</p>
</li>
<li>
<p>For node/group definitions, recognized fields include "node_count",</p>
<p>"name_template", "attrs", "disabled", "risk_groups" or "use_blueprint"
for blueprint-based groups.</p>
</li>
</ul>
<p>Args:
    data (Dict[str, Any]): The YAML-parsed dictionary containing
        optional "blueprints" + "network".</p>
<p>Returns:
    Network: The expanded Network object with all nodes and links.</p>
<hr />
<h2 id="ngraphdslblueprintsparse">ngraph.dsl.blueprints.parse<a class="headerlink" href="#ngraphdslblueprintsparse" title="Permanent link">&para;</a></h2>
<p>Parsing helpers for the network DSL.</p>
<p>This module factors out pure parsing/validation helpers from the expansion
module so they can be tested independently and reused.</p>
<h3 id="check_adjacency_keysadj_def-dictstr-any-context-str-none">check_adjacency_keys(adj_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'<a class="headerlink" href="#check_adjacency_keysadj_def-dictstr-any-context-str-none" title="Permanent link">&para;</a></h3>
<p>Ensure adjacency definitions only contain recognized keys.</p>
<h3 id="check_link_paramslink_params-dictstr-any-context-str-none">check_link_params(link_params: 'Dict[str, Any]', context: 'str') -&gt; 'None'<a class="headerlink" href="#check_link_paramslink_params-dictstr-any-context-str-none" title="Permanent link">&para;</a></h3>
<p>Ensure link_params contain only recognized keys.</p>
<p>Link attributes may include "hardware" per-end mapping when set under
link_params.attrs. This function only validates top-level link_params keys.</p>
<h3 id="check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none">check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'<a class="headerlink" href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" title="Permanent link">&para;</a></h3>
<p>Raise if <code>data_dict</code> contains keys outside <code>allowed</code>.</p>
<p>Args:
    data_dict: The dict to check.
    allowed: Set of recognized keys.
    context: Short description used in error messages.</p>
<h3 id="expand_name_patternsname-str-liststr">expand_name_patterns(name: 'str') -&gt; 'List[str]'<a class="headerlink" href="#expand_name_patternsname-str-liststr" title="Permanent link">&para;</a></h3>
<p>Expand bracket expressions in a group name.</p>
<p>Examples:</p>
<ul>
<li>"fa[1-3]" -&gt; ["fa1", "fa2", "fa3"]</li>
<li>"dc[1,3,5-6]" -&gt; ["dc1", "dc3", "dc5", "dc6"]</li>
<li>"fa[1-2]_plane[5-6]" -&gt; ["fa1_plane5", "fa1_plane6", "fa2_plane5", "fa2_plane6"]</li>
</ul>
<h3 id="join_pathsparent_path-str-rel_path-str-str">join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'<a class="headerlink" href="#join_pathsparent_path-str-rel_path-str-str" title="Permanent link">&para;</a></h3>
<p>Join two path segments according to the DSL conventions.</p>
<hr />
<h2 id="ngraphresultsartifacts">ngraph.results.artifacts<a class="headerlink" href="#ngraphresultsartifacts" title="Permanent link">&para;</a></h2>
<p>Serializable result artifacts for analysis workflows.</p>
<p>This module defines dataclasses that capture outputs from analyses and
simulations in a JSON-serializable form:</p>
<ul>
<li><code>PlacementResultSet</code>: aggregated placement results and statistics</li>
<li><code>CapacityEnvelope</code>: frequency-based capacity distributions and optional</li>
</ul>
<p>aggregated flow statistics</p>
<ul>
<li><code>FailurePatternResult</code>: capacity results for specific failure patterns</li>
</ul>
<h3 id="capacityenvelope">CapacityEnvelope<a class="headerlink" href="#capacityenvelope" title="Permanent link">&para;</a></h3>
<p>Frequency-based capacity envelope that stores capacity values as frequencies.</p>
<p>This approach is memory-efficient for Monte Carlo analysis where we care
about statistical distributions rather than individual sample order.</p>
<p>Attributes:
    source_pattern: Regex pattern used to select source nodes.
    sink_pattern: Regex pattern used to select sink nodes.
    mode: Flow analysis mode ("combine" or "pairwise").
    frequencies: Dictionary mapping capacity values to their occurrence counts.
    min_capacity: Minimum observed capacity.
    max_capacity: Maximum observed capacity.
    mean_capacity: Mean capacity across all samples.
    stdev_capacity: Standard deviation of capacity values.
    total_samples: Total number of samples represented.
    flow_summary_stats: Optional dictionary with aggregated FlowSummary statistics.
                       Contains cost_distribution_stats and other flow analytics.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source_pattern</code> (str)</li>
<li><code>sink_pattern</code> (str)</li>
<li><code>mode</code> (str)</li>
<li><code>frequencies</code> (Dict[float, int])</li>
<li><code>min_capacity</code> (float)</li>
<li><code>max_capacity</code> (float)</li>
<li><code>mean_capacity</code> (float)</li>
<li><code>stdev_capacity</code> (float)</li>
<li><code>total_samples</code> (int)</li>
<li><code>flow_summary_stats</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>expand_to_values(self) -&gt; 'List[float]'</code> - Expand frequency map back to individual values.</li>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "'CapacityEnvelope'"</code> - Construct a CapacityEnvelope from a dictionary.</li>
<li><code>from_values(source_pattern: 'str', sink_pattern: 'str', mode: 'str', values: 'List[float]', flow_summaries: 'List[Any] | None' = None) -&gt; "'CapacityEnvelope'"</code> - Create envelope from capacity values and optional flow summaries.</li>
<li><code>get_percentile(self, percentile: 'float') -&gt; 'float'</code> - Calculate percentile from frequency distribution.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<h3 id="failurepatternresult">FailurePatternResult<a class="headerlink" href="#failurepatternresult" title="Permanent link">&para;</a></h3>
<p>Result for a unique failure pattern with associated capacity matrix.</p>
<p>Attributes:
    excluded_nodes: List of failed node IDs.
    excluded_links: List of failed link IDs.
    capacity_matrix: Dictionary mapping flow keys to capacity values.
    count: Number of times this pattern occurred.
    is_baseline: Whether this represents the baseline (no failures) case.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>excluded_nodes</code> (List[str])</li>
<li><code>excluded_links</code> (List[str])</li>
<li><code>capacity_matrix</code> (Dict[str, float])</li>
<li><code>count</code> (int)</li>
<li><code>is_baseline</code> (bool) = False</li>
<li><code>_pattern_key_cache</code> (str)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "'FailurePatternResult'"</code> - Construct FailurePatternResult from a dictionary.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<h3 id="placementenvelope">PlacementEnvelope<a class="headerlink" href="#placementenvelope" title="Permanent link">&para;</a></h3>
<p>Per-demand placement envelope keyed like capacity envelopes.</p>
<p>Each envelope captures frequency distribution of placement ratio for a
specific demand definition across Monte Carlo iterations.</p>
<p>Attributes:
    source: Source selection regex or node label.
    sink: Sink selection regex or node label.
    mode: Demand expansion mode ("combine" or "pairwise").
    priority: Demand priority class.
    frequencies: Mapping of placement ratio to occurrence count.
    min: Minimum observed placement ratio.
    max: Maximum observed placement ratio.
    mean: Mean placement ratio.
    stdev: Standard deviation of placement ratio.
    total_samples: Number of iterations represented.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>sink</code> (str)</li>
<li><code>mode</code> (str)</li>
<li><code>priority</code> (int)</li>
<li><code>frequencies</code> (Dict[float, int])</li>
<li><code>min</code> (float)</li>
<li><code>max</code> (float)</li>
<li><code>mean</code> (float)</li>
<li><code>stdev</code> (float)</li>
<li><code>total_samples</code> (int)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "'PlacementEnvelope'"</code> - Construct a PlacementEnvelope from a dictionary.</li>
<li><code>from_values(source: 'str', sink: 'str', mode: 'str', priority: 'int', ratios: 'List[float]', rounding_decimals: 'int' = 4) -&gt; "'PlacementEnvelope'"</code></li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code></li>
</ul>
<h3 id="placementresultset">PlacementResultSet<a class="headerlink" href="#placementresultset" title="Permanent link">&para;</a></h3>
<p>Aggregated traffic placement results from one or many runs.</p>
<p>This immutable dataclass stores traffic placement results organized by case,
with overall statistics and per-demand statistics.</p>
<p>Attributes:
    results_by_case: Dictionary mapping case names to TrafficResult lists.
    overall_stats: Dictionary of overall statistics.
    demand_stats: Dictionary mapping demand keys to per-demand statistics.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>results_by_case</code> (dict[str, list[TrafficResult]]) = {}</li>
<li><code>overall_stats</code> (dict[str, float]) = {}</li>
<li><code>demand_stats</code> (dict[tuple[str, str, int], dict[str, float]]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphresultsflow">ngraph.results.flow<a class="headerlink" href="#ngraphresultsflow" title="Permanent link">&para;</a></h2>
<p>Unified flow result containers for failure-analysis iterations.</p>
<p>Defines small, serializable dataclasses that capture per-iteration outcomes
for capacity and demand-placement style analyses in a unit-agnostic form.</p>
<p>Objects expose <code>to_dict()</code> that returns JSON-safe primitives. Float-keyed
distributions are normalized to string keys, and arbitrary <code>data</code> payloads are
sanitized. These dicts are written under <code>data.flow_results</code> by steps.</p>
<h3 id="flowentry">FlowEntry<a class="headerlink" href="#flowentry" title="Permanent link">&para;</a></h3>
<p>Represents a single source→destination flow outcome within an iteration.</p>
<p>Fields are unit-agnostic. Callers can interpret numbers as needed for
presentation (e.g., Gbit/s).</p>
<p>Args:
    source: Source identifier.
    destination: Destination identifier.
    priority: Priority/class for traffic placement scenarios. Zero when not applicable.
    demand: Requested volume for this flow.
    placed: Delivered volume for this flow.
    dropped: Unmet volume (<code>demand - placed</code>).
    cost_distribution: Optional distribution of placed volume by path cost.
    data: Optional per-flow details (e.g., min-cut edges, used edges).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>destination</code> (str)</li>
<li><code>priority</code> (int)</li>
<li><code>demand</code> (float)</li>
<li><code>placed</code> (float)</li>
<li><code>dropped</code> (float)</li>
<li><code>cost_distribution</code> (Dict[float, float]) = {}</li>
<li><code>data</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<h3 id="flowiterationresult">FlowIterationResult<a class="headerlink" href="#flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Container for per-iteration analysis results.</p>
<p>Args:
    failure_id: Stable identifier for the failure scenario (e.g., "baseline" or a hash).
    failure_state: Optional excluded components for the iteration.
    flows: List of flow entries for this iteration.
    summary: Aggregated summary across <code>flows</code>.
    data: Optional per-iteration extras.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>failure_id</code> (str)</li>
<li><code>failure_state</code> (Optional[Dict[str, List[str]]])</li>
<li><code>flows</code> (List[FlowEntry]) = []</li>
<li><code>summary</code> (FlowSummary) = FlowSummary(total_demand=0.0, total_placed=0.0, overall_ratio=1.0, dropped_flows=0, num_flows=0)</li>
<li><code>data</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<h3 id="flowsummary_1">FlowSummary<a class="headerlink" href="#flowsummary_1" title="Permanent link">&para;</a></h3>
<p>Aggregated metrics across all flows in one iteration.</p>
<p>Args:
    total_demand: Sum of all demands in this iteration.
    total_placed: Sum of all delivered volumes in this iteration.
    overall_ratio: <code>total_placed / total_demand</code> when demand &gt; 0, else 1.0.
    dropped_flows: Number of flow entries with non-zero drop.
    num_flows: Total number of flows considered.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>total_demand</code> (float)</li>
<li><code>total_placed</code> (float)</li>
<li><code>overall_ratio</code> (float)</li>
<li><code>dropped_flows</code> (int)</li>
<li><code>num_flows</code> (int)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<hr />
<h2 id="ngraphresultsstore">ngraph.results.store<a class="headerlink" href="#ngraphresultsstore" title="Permanent link">&para;</a></h2>
<p>Generic results store for workflow steps and their metadata.</p>
<p><code>Results</code> organizes outputs by workflow step name and records
<code>WorkflowStepMetadata</code> for execution context. Storage is strictly
step-scoped: steps must write two keys under their namespace:</p>
<ul>
<li><code>metadata</code>: step-level metadata (dict)</li>
<li><code>data</code>: step-specific payload (dict)</li>
</ul>
<p>Export with :meth:<code>Results.to_dict</code>, which returns a JSON-safe structure
with shape <code>{workflow, steps, scenario}</code>. During export, objects with a
<code>to_dict()</code> method are converted, dictionary keys are coerced to strings,
tuples are emitted as lists, and only JSON primitives are produced.</p>
<h3 id="results">Results<a class="headerlink" href="#results" title="Permanent link">&para;</a></h3>
<p>Step-scoped results container with deterministic export shape.</p>
<p>Structure:</p>
<ul>
<li>workflow: step metadata registry</li>
<li>steps: per-step results with enforced keys {"metadata", "data"}</li>
<li>scenario: optional scenario snapshot set once at load time</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>_store</code> (Dict) = {}</li>
<li><code>_metadata</code> (Dict) = {}</li>
<li><code>_active_step</code> (Optional)</li>
<li><code>_scenario</code> (Dict) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>enter_step(self, step_name: str) -&gt; None</code> - Enter step scope. Subsequent put/get are scoped to this step.</li>
<li><code>exit_step(self) -&gt; None</code> - Exit step scope.</li>
<li><code>get(self, key: str, default: Any = None) -&gt; Any</code> - Get a value from the active step scope.</li>
<li><code>get_all_step_metadata(self) -&gt; Dict[str, ngraph.results.store.WorkflowStepMetadata]</code> - Get metadata for all workflow steps.</li>
<li><code>get_step(self, step_name: str) -&gt; Dict[str, Any]</code> - Return the raw dict for a given step name (for cross-step reads).</li>
<li><code>get_step_metadata(self, step_name: str) -&gt; Optional[ngraph.results.store.WorkflowStepMetadata]</code> - Get metadata for a workflow step.</li>
<li><code>get_steps_by_execution_order(self) -&gt; list[str]</code> - Get step names ordered by their execution order.</li>
<li><code>put(self, key: str, value: Any) -&gt; None</code> - Store a value in the active step under an allowed key.</li>
<li><code>put_step_metadata(self, step_name: str, step_type: str, execution_order: int, *, scenario_seed: Optional[int] = None, step_seed: Optional[int] = None, seed_source: str = 'none', active_seed: Optional[int] = None) -&gt; None</code> - Store metadata for a workflow step.</li>
<li><code>set_scenario_snapshot(self, snapshot: Dict[str, Any]) -&gt; None</code> - Attach a normalized scenario snapshot for export.</li>
<li><code>to_dict(self) -&gt; Dict[str, Any]</code> - Return exported results with shape: {workflow, steps, scenario}.</li>
</ul>
<h3 id="workflowstepmetadata">WorkflowStepMetadata<a class="headerlink" href="#workflowstepmetadata" title="Permanent link">&para;</a></h3>
<p>Metadata for a workflow step execution.</p>
<p>Attributes:
    step_type: The workflow step class name (e.g., 'CapacityEnvelopeAnalysis').
    step_name: The instance name of the step.
    execution_order: Order in which this step was executed (0-based).
    scenario_seed: Scenario-level seed provided in the YAML (if any).
    step_seed: Seed assigned to this step (explicit or scenario-derived).
    seed_source: Source for the step seed. One of:</p>
<ul>
<li>"scenario-derived": seed was derived from scenario.seed</li>
<li>"explicit-step": seed was explicitly provided for the step</li>
<li>
<p>"none": no seed provided/active for this step</p>
<p>active_seed: The effective base seed used by the step, if any. For steps
    that use Monte Carlo execution, per-iteration seeds are derived from
    active_seed (e.g., active_seed + iteration_index).</p>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_type</code> (str)</li>
<li><code>step_name</code> (str)</li>
<li><code>execution_order</code> (int)</li>
<li><code>scenario_seed</code> (Optional)</li>
<li><code>step_seed</code> (Optional)</li>
<li><code>seed_source</code> (str) = none</li>
<li><code>active_seed</code> (Optional)</li>
</ul>
<hr />
<h2 id="ngraphmonte_carlofunctions">ngraph.monte_carlo.functions<a class="headerlink" href="#ngraphmonte_carlofunctions" title="Permanent link">&para;</a></h2>
<p>Picklable Monte Carlo analysis functions for FailureManager simulations.</p>
<p>These functions are designed for use with FailureManager.run_monte_carlo_analysis()
and follow the pattern: analysis_func(network_view: NetworkView, **kwargs) -&gt; Any.</p>
<p>All functions accept only simple, hashable parameters to ensure compatibility
with FailureManager's caching and multiprocessing systems for Monte Carlo
failure analysis scenarios.</p>
<p>This module provides only computation functions. Visualization and notebook
analysis live in external packages.</p>
<h3 id="demand_placement_analysisnetwork_view-networkview-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-kwargs-flowiterationresult">demand_placement_analysis(network_view: "'NetworkView'", demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'<a class="headerlink" href="#demand_placement_analysisnetwork_view-networkview-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-kwargs-flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Analyze traffic demand placement success rates.</p>
<p>Produces per-demand FlowEntry records and an iteration-level summary suitable
for downstream statistics (e.g., delivered percentiles) without reconstructing
joint distributions.</p>
<p>Additionally exposes placement engine counters to aid performance analysis:</p>
<ul>
<li>Per-demand: <code>FlowEntry.data.policy_metrics</code> (dict) with totals collected by</li>
</ul>
<p>the active FlowPolicy (e.g., <code>spf_calls_total</code>, <code>flows_created_total</code>,
  <code>reopt_calls_total</code>, <code>place_iterations_total</code>).</p>
<ul>
<li>Per-iteration: <code>FlowIterationResult.data.iteration_metrics</code> aggregating the</li>
</ul>
<p>same counters across all demands in the iteration. Use
  <code>FlowIterationResult.summary.total_placed</code> for placed volume totals.</p>
<p>Args:
    network_view: NetworkView with potential exclusions applied.
    demands_config: List of demand configurations (serializable dicts).
    placement_rounds: Number of placement optimization rounds.
    include_flow_details: When True, include cost_distribution per flow.
    include_used_edges: When True, include set of used edges per demand in entry data
        as <code>FlowEntry.data.edges</code> with <code>edges_kind='used'</code>.
    **kwargs: Ignored. Accepted for interface compatibility.</p>
<p>Returns:
    FlowIterationResult describing this iteration. The <code>data</code> field contains
    <code>{"iteration_metrics": { ... }}</code>.</p>
<h3 id="max_flow_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-kwargs-flowiterationresult">max_flow_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, **kwargs) -&gt; 'FlowIterationResult'<a class="headerlink" href="#max_flow_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-kwargs-flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Analyze maximum flow capacity between node groups.</p>
<p>Args:
    network_view: NetworkView with potential exclusions applied.
    source_regex: Regex pattern for source node groups.
    sink_regex: Regex pattern for sink node groups.
    mode: Flow analysis mode ("combine" or "pairwise").
    shortest_path: Whether to use shortest paths only.
    flow_placement: Flow placement strategy.
    include_flow_details: Whether to collect cost distribution and similar details.
    include_min_cut: Whether to include min-cut edge list in entry data.
    **kwargs: Ignored. Accepted for interface compatibility.</p>
<p>Returns:
    FlowIterationResult describing this iteration.</p>
<h3 id="sensitivity_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-kwargs-dictstr-dictstr-float">sensitivity_analysis(network_view: "'NetworkView'", source_regex: 'str', sink_regex: 'str', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, **kwargs) -&gt; 'dict[str, dict[str, float]]'<a class="headerlink" href="#sensitivity_analysisnetwork_view-networkview-source_regex-str-sink_regex-str-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-kwargs-dictstr-dictstr-float" title="Permanent link">&para;</a></h3>
<p>Analyze component sensitivity to failures.</p>
<p>Args:
    network_view: NetworkView with potential exclusions applied.
    source_regex: Regex pattern for source node groups.
    sink_regex: Regex pattern for sink node groups.
    mode: Flow analysis mode ("combine" or "pairwise").
    shortest_path: Whether to use shortest paths only.
    flow_placement: Flow placement strategy.
    **kwargs: Ignored. Accepted for interface compatibility.</p>
<p>Returns:
    Dictionary mapping flow keys ("src-&gt;dst") to dictionaries of component
    identifiers mapped to sensitivity scores.</p>
<hr />
<h2 id="ngraphmonte_carloresults">ngraph.monte_carlo.results<a class="headerlink" href="#ngraphmonte_carloresults" title="Permanent link">&para;</a></h2>
<p>Structured result objects for FailureManager analysis functions.</p>
<p>These classes provide interfaces for accessing Monte Carlo analysis
results from FailureManager convenience methods. Visualization is handled by
specialized analyzer classes in the workflow.analysis module.</p>
<h3 id="capacityenveloperesults">CapacityEnvelopeResults<a class="headerlink" href="#capacityenveloperesults" title="Permanent link">&para;</a></h3>
<p>CapacityEnvelopeResults(envelopes: 'Dict[str, CapacityEnvelope]', failure_patterns: 'Dict[str, FailurePatternResult]', source_pattern: 'str', sink_pattern: 'str', mode: 'str', iterations: 'int', metadata: 'Dict[str, Any]')</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>envelopes</code> (Dict[str, CapacityEnvelope])</li>
<li><code>failure_patterns</code> (Dict[str, FailurePatternResult])</li>
<li><code>source_pattern</code> (str)</li>
<li><code>sink_pattern</code> (str)</li>
<li><code>mode</code> (str)</li>
<li><code>iterations</code> (int)</li>
<li><code>metadata</code> (Dict[str, Any])</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>export_summary(self) -&gt; 'Dict[str, Any]'</code></li>
</ul>
<h3 id="demandplacementresults">DemandPlacementResults<a class="headerlink" href="#demandplacementresults" title="Permanent link">&para;</a></h3>
<p>DemandPlacementResults(raw_results: 'dict[str, Any]', iterations: 'int', baseline: 'Optional[dict[str, Any]]' = None, failure_patterns: 'Optional[Dict[str, Any]]' = None, metadata: 'Optional[Dict[str, Any]]' = None)</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>raw_results</code> (dict[str, Any])</li>
<li><code>iterations</code> (int)</li>
<li><code>baseline</code> (Optional[dict[str, Any]])</li>
<li><code>failure_patterns</code> (Optional[Dict[str, Any]])</li>
<li><code>metadata</code> (Optional[Dict[str, Any]])</li>
</ul>
<h3 id="sensitivityresults">SensitivityResults<a class="headerlink" href="#sensitivityresults" title="Permanent link">&para;</a></h3>
<p>Results from sensitivity Monte Carlo analysis.</p>
<p>Attributes:
    raw_results: Raw results from FailureManager
    iterations: Number of Monte Carlo iterations
    baseline: Optional baseline result (no failures)
    component_scores: Aggregated component impact scores by flow
    failure_patterns: Dictionary mapping pattern keys to failure pattern results
    source_pattern: Source node regex pattern used in analysis
    sink_pattern: Sink node regex pattern used in analysis
    mode: Flow analysis mode ("combine" or "pairwise")
    metadata: Additional analysis metadata from FailureManager</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>raw_results</code> (dict[str, Any])</li>
<li><code>iterations</code> (int)</li>
<li><code>baseline</code> (Optional[dict[str, Any]])</li>
<li><code>component_scores</code> (Optional[Dict[str, Dict[str, Dict[str, float]]]])</li>
<li><code>failure_patterns</code> (Optional[Dict[str, Any]])</li>
<li><code>source_pattern</code> (Optional[str])</li>
<li><code>sink_pattern</code> (Optional[str])</li>
<li><code>mode</code> (Optional[str])</li>
<li><code>metadata</code> (Optional[Dict[str, Any]])</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>component_impact_distribution(self) -&gt; 'pd.DataFrame'</code> - Get component impact distribution as DataFrame.</li>
<li><code>export_summary(self) -&gt; 'Dict[str, Any]'</code> - Export summary for serialization.</li>
<li><code>flow_keys(self) -&gt; 'List[str]'</code> - Get list of all flow keys in results.</li>
<li><code>get_failure_pattern_summary(self) -&gt; 'pd.DataFrame'</code> - Get summary of failure patterns if available.</li>
<li><code>get_flow_sensitivity(self, flow_key: 'str') -&gt; 'Dict[str, Dict[str, float]]'</code> - Get component sensitivity scores for a specific flow.</li>
<li><code>summary_statistics(self) -&gt; 'Dict[str, Dict[str, float]]'</code> - Get summary statistics for component impact across all flows.</li>
<li><code>to_dataframe(self) -&gt; 'pd.DataFrame'</code> - Convert sensitivity results to DataFrame for analysis.</li>
</ul>
<hr />
<h2 id="ngraphmonte_carlotypes">ngraph.monte_carlo.types<a class="headerlink" href="#ngraphmonte_carlotypes" title="Permanent link">&para;</a></h2>
<p>Typed protocols for Monte Carlo analysis IPC payloads.</p>
<p>Defines lightweight, serializable structures used across worker boundaries.</p>
<h3 id="flowresult">FlowResult<a class="headerlink" href="#flowresult" title="Permanent link">&para;</a></h3>
<p>Normalized result record for a flow pair in one iteration.</p>
<p>Keys:
    src: Source label
    dst: Destination label
    metric: Name of metric ('capacity' or 'placement_ratio')
    value: Numeric value for the metric
    stats: Optional FlowStats with compact details
    priority: Optional demand priority (only for placement results)</p>
<h3 id="flowstats">FlowStats<a class="headerlink" href="#flowstats" title="Permanent link">&para;</a></h3>
<p>Compact per-flow statistics for aggregation.</p>
<p>Keys:
    cost_distribution: Mapping of path cost to flow volume.
    edges: List of edge identifiers (string form).
    edges_kind: Meaning of edges list: 'min_cut' for capacity analysis,
        'used' for demand placement edge usage.</p>
<hr />
<h2 id="ngraphprofilingprofiler">ngraph.profiling.profiler<a class="headerlink" href="#ngraphprofilingprofiler" title="Permanent link">&para;</a></h2>
<p>Profiling for NetGraph workflow execution.</p>
<p>Provides CPU and wall-clock timing per workflow step using <code>cProfile</code> and
optionally peak memory via <code>tracemalloc</code>. Aggregates results into structured
summaries and identifies time-dominant steps (bottlenecks).</p>
<h3 id="performanceprofiler">PerformanceProfiler<a class="headerlink" href="#performanceprofiler" title="Permanent link">&para;</a></h3>
<p>CPU profiler for NetGraph workflow execution.</p>
<p>Profiles workflow steps using cProfile and identifies bottlenecks.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>analyze_performance(self) -&gt; 'None'</code> - Analyze profiling results and identify bottlenecks.</li>
<li><code>end_scenario(self) -&gt; 'None'</code> - End profiling for the entire scenario execution.</li>
<li><code>get_top_functions(self, step_name: 'str', limit: 'int' = 10) -&gt; 'List[Tuple[str, float, int]]'</code> - Get the top CPU-consuming functions for a specific step.</li>
<li><code>merge_child_profiles(self, profile_dir: 'Path', step_name: 'str') -&gt; 'None'</code> - Merge child worker profiles into the parent step profile.</li>
<li><code>profile_step(self, step_name: 'str', step_type: 'str') -&gt; 'Generator[None, None, None]'</code> - Context manager for profiling individual workflow steps.</li>
<li><code>save_detailed_profile(self, output_path: 'Path', step_name: 'Optional[str]' = None) -&gt; 'None'</code> - Save detailed profiling data to a file.</li>
<li><code>start_scenario(self) -&gt; 'None'</code> - Start profiling for the entire scenario execution.</li>
</ul>
<h3 id="performancereporter">PerformanceReporter<a class="headerlink" href="#performancereporter" title="Permanent link">&para;</a></h3>
<p>Format and render performance profiling results.</p>
<p>Generates plain-text reports with timing analysis, bottleneck identification,
and practical performance tuning suggestions.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>generate_report(self) -&gt; 'str'</code> - Generate performance report.</li>
</ul>
<h3 id="profileresults">ProfileResults<a class="headerlink" href="#profileresults" title="Permanent link">&para;</a></h3>
<p>Profiling results for a scenario execution.</p>
<p>Attributes:
    step_profiles: List of individual step performance profiles.
    total_wall_time: Total wall-clock time for entire scenario.
    total_cpu_time: Total CPU time across all steps.
    total_function_calls: Total function calls across all steps.
    bottlenecks: List of performance bottlenecks (&gt;10% execution time).
    analysis_summary: Performance metrics and statistics.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_profiles</code> (List[StepProfile]) = []</li>
<li><code>total_wall_time</code> (float) = 0.0</li>
<li><code>total_cpu_time</code> (float) = 0.0</li>
<li><code>total_function_calls</code> (int) = 0</li>
<li><code>bottlenecks</code> (List[Dict[str, Any]]) = []</li>
<li><code>analysis_summary</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="stepprofile">StepProfile<a class="headerlink" href="#stepprofile" title="Permanent link">&para;</a></h3>
<p>Performance profile data for a single workflow step.</p>
<p>Attributes:
    step_name: Name of the workflow step.
    step_type: Type/class name of the workflow step.
    wall_time: Total wall-clock time in seconds.
    cpu_time: CPU time spent in step execution.
    function_calls: Number of function calls during execution.
    memory_peak: Peak memory usage during step in bytes (if available).
    cprofile_stats: Detailed cProfile statistics object.
    worker_profiles_merged: Number of worker profiles merged into this step.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_name</code> (str)</li>
<li><code>step_type</code> (str)</li>
<li><code>wall_time</code> (float)</li>
<li><code>cpu_time</code> (float)</li>
<li><code>function_calls</code> (int)</li>
<li><code>memory_peak</code> (Optional[float])</li>
<li><code>cprofile_stats</code> (Optional[pstats.Stats])</li>
<li><code>worker_profiles_merged</code> (int) = 0</li>
</ul>
<hr />
<h2 id="ngraphprofilingreporter">ngraph.profiling.reporter<a class="headerlink" href="#ngraphprofilingreporter" title="Permanent link">&para;</a></h2>
<hr />
<h2 id="ngraphutilsids">ngraph.utils.ids<a class="headerlink" href="#ngraphutilsids" title="Permanent link">&para;</a></h2>
<h3 id="new_base64_uuid-str">new_base64_uuid() -&gt; 'str'<a class="headerlink" href="#new_base64_uuid-str" title="Permanent link">&para;</a></h3>
<p>Return a 22-character URL-safe Base64-encoded UUID without padding.</p>
<p>The function generates a random version 4 UUID, encodes the 16 raw bytes
using URL-safe Base64, removes the two trailing padding characters, and
decodes to ASCII. The resulting string length is 22 characters.</p>
<p>Returns:
    A 22-character URL-safe Base64 representation of a UUID4 without
    padding.</p>
<hr />
<h2 id="ngraphutilsoutput_paths">ngraph.utils.output_paths<a class="headerlink" href="#ngraphutilsoutput_paths" title="Permanent link">&para;</a></h2>
<p>Utilities for building CLI artifact output paths.</p>
<p>This module centralizes logic for composing file and directory paths for
artifacts produced by the NetGraph CLI. Paths are built from an optional
output directory, a prefix (usually derived from the scenario file or
results file), and a per-artifact suffix.</p>
<h3 id="build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path">build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'<a class="headerlink" href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" title="Permanent link">&para;</a></h3>
<p>Compose an artifact path as output_dir / (prefix + suffix).</p>
<p>If <code>output_dir</code> is None, the path is created relative to the current
working directory.</p>
<p>Args:
    output_dir: Base directory for outputs; if None, use CWD.
    prefix: Filename prefix; usually derived from scenario or results stem.
    suffix: Per-artifact suffix including the dot (e.g. ".results.json").</p>
<p>Returns:
    The composed path.</p>
<h3 id="ensure_parent_dirpath-path-none">ensure_parent_dir(path: 'Path') -&gt; 'None'<a class="headerlink" href="#ensure_parent_dirpath-path-none" title="Permanent link">&para;</a></h3>
<p>Ensure the parent directory exists for a file path.</p>
<h3 id="profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path">profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'<a class="headerlink" href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" title="Permanent link">&para;</a></h3>
<p>Return the directory for child worker profiles for <code>run --profile</code>.</p>
<p>Args:
    scenario_path: The scenario YAML path.
    output_dir: Optional base output directory.</p>
<p>Returns:
    Directory path where worker profiles should be stored.</p>
<h3 id="resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath">resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'<a class="headerlink" href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" title="Permanent link">&para;</a></h3>
<p>Resolve an override path with respect to an optional output directory.</p>
<ul>
<li>Absolute override paths are returned as-is.</li>
<li>Relative override paths are interpreted as relative to <code>output_dir</code></li>
</ul>
<p>when provided; otherwise relative to the current working directory.</p>
<p>Args:
    override: Path provided by the user to override the default.
    output_dir: Optional base directory for relative overrides.</p>
<p>Returns:
    The resolved path or None if no override was provided.</p>
<h3 id="results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path">results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'<a class="headerlink" href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" title="Permanent link">&para;</a></h3>
<p>Determine the results JSON path for the <code>run</code> command.</p>
<p>Behavior:</p>
<ul>
<li>If <code>results_override</code> is provided, return it (resolved relative to</li>
</ul>
<p><code>output_dir</code> when that is specified, otherwise as-is).</p>
<ul>
<li>Else if <code>output_dir</code> is provided, return <code>output_dir/&lt;prefix&gt;.results.json</code>.</li>
<li>Else, return <code>&lt;scenario_stem&gt;.results.json</code> in the current working directory.</li>
</ul>
<p>Args:
    scenario_path: The scenario YAML file path.
    output_dir: Optional base output directory.
    results_override: Optional explicit results file path.</p>
<p>Returns:
    The path where results should be written.</p>
<h3 id="scenario_prefix_from_pathscenario_path-path-str">scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'<a class="headerlink" href="#scenario_prefix_from_pathscenario_path-path-str" title="Permanent link">&para;</a></h3>
<p>Return a safe prefix derived from a scenario file path.</p>
<p>Args:
    scenario_path: The scenario YAML file path.</p>
<p>Returns:
    The scenario filename stem, trimmed of extensions.</p>
<hr />
<h2 id="error-handling">Error Handling<a class="headerlink" href="#error-handling" title="Permanent link">&para;</a></h2>
<p>NetGraph uses standard Python exceptions:</p>
<ul>
<li><code>ValueError</code> - For validation errors</li>
<li><code>KeyError</code> - For missing required fields</li>
<li><code>RuntimeError</code> - For runtime errors</li>
</ul>
<p>For complete method signatures and detailed documentation, use Python's help system:</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="n">help</span><span class="p">(</span><span class="n">ngraph</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">Scenario</span><span class="p">)</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="n">help</span><span class="p">(</span><span class="n">ngraph</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">Network</span><span class="o">.</span><span class="n">max_flow</span><span class="p">)</span>
</span></code></pre></div>
<hr />
<p><em>This documentation was auto-generated from the NetGraph source code.</em></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.sections", "navigation.tabs", "navigation.top", "content.code.copy"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>