
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://networmix.github.io/NetGraph/reference/api-full/">
      
      
        <link rel="prev" href="../api/">
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>API Full - NetGraph</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#netgraph-api-reference-auto-generated" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="NetGraph" class="md-header__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            NetGraph
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Full
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../getting-started/installation/" class="md-tabs__link">
          
  
  
  Getting Started

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../examples/bundled-scenarios/" class="md-tabs__link">
          
  
  
  Examples

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../design/" class="md-tabs__link">
          
  
  
  Reference

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="NetGraph" class="md-nav__button md-logo" aria-label="NetGraph" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    NetGraph
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/networmix/NetGraph" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Getting Started
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Getting Started
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Installation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../getting-started/tutorial/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Quickstart
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Examples
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Examples
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/bundled-scenarios/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bundled Scenarios
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/basic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Basic Example
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/clos-fabric/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Clos Fabric
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    Reference
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Reference
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Design
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dsl/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    DSL
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../workflow/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Workflow
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    CLI
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schemas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Schemas
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    API
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    API Full
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    API Full
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ngraphcli" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.cli
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.cli">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mainargv-optionalliststr-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        main(argv: 'Optional[List[str]]' = None) -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.explorer
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.explorer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#externallinkbreakdown" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExternalLinkBreakdown
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkcapacityissue" class="md-nav__link">
    <span class="md-ellipsis">
      
        LinkCapacityIssue
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      
        NetworkExplorer
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeutilization" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeUtilization
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    <span class="md-ellipsis">
      
        TreeNode
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treestats" class="md-nav__link">
    <span class="md-ellipsis">
      
        TreeStats
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlogging" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.logging
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.logging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#disable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        disable_debug_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        enable_debug_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_loggername-str-logginglogger" class="md-nav__link">
    <span class="md-ellipsis">
      
        get_logger(name: str) -&gt; logging.Logger
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        reset_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_global_log_levellevel-int-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        set_global_log_level(level: int) -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphscenario" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.scenario
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.scenario">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario" class="md-nav__link">
    <span class="md-ellipsis">
      
        Scenario
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelcomponents" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.components
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.components">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#component" class="md-nav__link">
    <span class="md-ellipsis">
      
        Component
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#componentslibrary" class="md-nav__link">
    <span class="md-ellipsis">
      
        ComponentsLibrary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" class="md-nav__link">
    <span class="md-ellipsis">
      
        totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandbuilder" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.builder
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.builder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_demand_setraw-dictstr-listdict-demandset" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_demand_set(raw: 'Dict[str, List[dict]]') -&gt; 'DemandSet'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandmatrix" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.matrix
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.matrix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demandset" class="md-nav__link">
    <span class="md-ellipsis">
      
        DemandSet
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.spec
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.spec">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficdemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        TrafficDemand
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailuregenerate" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.generate
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.generate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generatespec" class="md-nav__link">
    <span class="md-ellipsis">
      
        GenerateSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_risk_groupsnetwork-network-spec-generatespec-listriskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        generate_risk_groups(network: "'Network'", spec: 'GenerateSpec') -&gt; 'List[RiskGroup]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_generate_specraw-dictstr-any-generatespec" class="md-nav__link">
    <span class="md-ellipsis">
      
        parse_generate_spec(raw: 'Dict[str, Any]') -&gt; 'GenerateSpec'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailuremembership" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.membership
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.membership">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#membershipspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        MembershipSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_membership_rulesnetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_membership_rules(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailureparser" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.parser
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.parser">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_failure_policyfp_data-dictstr-any-policy_name-str-derive_seed-callablestr-optionalint-failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_failure_policy(fp_data: 'Dict[str, Any]', *, policy_name: 'str', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicy'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_failure_policy_setraw-dictstr-any-derive_seed-callablestr-optionalint-failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_failure_policy_set(raw: 'Dict[str, Any]', *, derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicySet'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_risk_groupsrg_data-listany-tuplelistriskgroup-listdictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_risk_groups(rg_data: 'List[Any]') -&gt; 'tuple[List[RiskGroup], List[Dict[str, Any]]]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.policy
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failuremode" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureMode
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePolicy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurerule" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureRule
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurepolicy_set" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.policy_set
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.policy_set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePolicySet
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurevalidation" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.validation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.validation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#validate_risk_group_hierarchynetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        validate_risk_group_hierarchy(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validate_risk_group_referencesnetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        validate_risk_group_references(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelflowpolicy_config" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.flow.policy_config
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.flow.policy_config">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowpolicypreset" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowPolicyPreset
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create_flow_policyalgorithms-netgraph_corealgorithms-graph-netgraph_coregraph-preset-flowpolicypreset-node_masknone-edge_masknone-netgraph_coreflowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        create_flow_policy(algorithms: 'netgraph_core.Algorithms', graph: 'netgraph_core.Graph', preset: 'FlowPolicyPreset', node_mask=None, edge_mask=None) -&gt; 'netgraph_core.FlowPolicy'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#serialize_policy_presetcfg-any-optionalstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        serialize_policy_preset(cfg: 'Any') -&gt; 'Optional[str]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelnetwork" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.network
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      
        Link
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        RiskGroup
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelpath" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.path
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.path">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    <span class="md-ellipsis">
      
        Path
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#workflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      
        WorkflowStep
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_workflow_stepstep_type-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_workflow_step(step_type: 'str')
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_parallelismparallelism-unionint-str-int" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_parallelism(parallelism: 'Union[int, str]') -&gt; 'int'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbuild_graph" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.build_graph
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.build_graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buildgraph" class="md-nav__link">
    <span class="md-ellipsis">
      
        BuildGraph
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowcost_power" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.cost_power
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.cost_power">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#costpower" class="md-nav__link">
    <span class="md-ellipsis">
      
        CostPower
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmax_flow_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.max_flow_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.max_flow_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxflow" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaxFlow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmaximum_supported_demand_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.maximum_supported_demand_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.maximum_supported_demand_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maximumsupporteddemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaximumSupportedDemand
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflownetwork_stats" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.network_stats
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.network_stats">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkstats" class="md-nav__link">
    <span class="md-ellipsis">
      
        NetworkStats
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowparse" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.parse
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.parse">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_workflow_stepsworkflow_data-listdictstr-any-derive_seed-callablestr-optionalint-listworkflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_workflow_steps(workflow_data: 'List[Dict[str, Any]]', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'List[WorkflowStep]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowtraffic_matrix_placement_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.traffic_matrix_placement_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.traffic_matrix_placement_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        TrafficMatrixPlacement
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsexpand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.blueprints.expand
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    <span class="md-ellipsis">
      
        Blueprint
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslexpansioncontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        DSLExpansionContext
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_network_dsldata-dictstr-any-network" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsparser" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.blueprints.parser
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.parser">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check_link_keyslink_def-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        check_link_keys(link_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_pathsparent_path-str-rel_path-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionbrackets" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.brackets
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.brackets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_name_patternsname-str-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_name_patterns(name: 'str') -&gt; 'List[str]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_risk_group_refsrg_list-iterablestr-setstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_risk_group_refs(rg_list: 'Iterable[str]') -&gt; 'Set[str]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionschema" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.schema
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.schema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expansionspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExpansionSpec
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionvariables" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.variables
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.variables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_blockblock-dictstr-any-spec-optionalexpansionspec-iteratordictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_block(block: 'Dict[str, Any]', spec: "Optional['ExpansionSpec']") -&gt; 'Iterator[Dict[str, Any]]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_templatestemplates-dictstr-str-spec-expansionspec-iteratordictstr-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_templates(templates: 'Dict[str, str]', spec: "'ExpansionSpec'") -&gt; 'Iterator[Dict[str, str]]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substitute_varsobj-any-var_dict-dictstr-any-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        substitute_vars(obj: 'Any', var_dict: 'Dict[str, Any]') -&gt; 'Any'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslloader" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.loader
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.loader">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#load_scenario_yamlyaml_str-str-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        load_scenario_yaml(yaml_str: 'str') -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsconditions" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.conditions
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionattrs-dictstr-any-cond-condition-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        evaluate_condition(attrs: 'Dict[str, Any]', cond: "'Condition'") -&gt; 'bool'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionsattrs-dictstr-any-conditions-iterablecondition-logic-str-or-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        evaluate_conditions(attrs: 'Dict[str, Any]', conditions: "Iterable['Condition']", logic: 'str' = 'or') -&gt; 'bool'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_attr_pathattrs-dictstr-any-path-str-tuplebool-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_attr_path(attrs: 'Dict[str, Any]', path: 'str') -&gt; 'Tuple[bool, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsnormalize" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.normalize
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.normalize">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_selectorraw-unionstr-dictstr-any-nodeselector-context-str-nodeselector" class="md-nav__link">
    <span class="md-ellipsis">
      
        normalize_selector(raw: 'Union[str, Dict[str, Any], NodeSelector]', context: 'str') -&gt; 'NodeSelector'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_match_specraw-dictstr-any-default_logic-literaland-or-or-require_conditions-bool-false-context-str-match-matchspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        parse_match_spec(raw: 'Dict[str, Any]', *, default_logic: "Literal['and', 'or']" = 'or', require_conditions: 'bool' = False, context: 'str' = 'match') -&gt; 'MatchSpec'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsschema" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.schema
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.schema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#condition" class="md-nav__link">
    <span class="md-ellipsis">
      
        Condition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matchspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        MatchSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeselector" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeSelector
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsselect" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.select
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.select">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flatten_link_attrslink-link-link_id-str-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_link_attrs(link: "'Link'", link_id: 'str') -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatten_node_attrsnode-node-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_node_attrs(node: "'Node'") -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatten_risk_group_attrsrg-unionriskgroup-dictstr-any-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_risk_group_attrs(rg: "Union['RiskGroup', Dict[str, Any]]") -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match_entity_idsentity_attrs-dictstr-dictstr-any-conditions-listcondition-logic-str-or-setstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        match_entity_ids(entity_attrs: 'Dict[str, Dict[str, Any]]', conditions: 'List[Condition]', logic: 'str' = 'or') -&gt; 'Set[str]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_nodesnetwork-network-selector-nodeselector-default_active_only-bool-excluded_nodes-optionalsetstr-none-dictstr-listnode" class="md-nav__link">
    <span class="md-ellipsis">
      
        select_nodes(network: "'Network'", selector: 'NodeSelector', default_active_only: 'bool', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; "Dict[str, List['Node']]"
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsartifacts" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.artifacts
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.artifacts">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      
        CapacityEnvelope
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepatternresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePatternResult
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsflow" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.flow
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowentry" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowEntry
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowIterationResult
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowSummary
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultssnapshot" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.snapshot
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.snapshot">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_scenario_snapshot-seed-int-none-failure_policy_set-demand_set-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_scenario_snapshot(*, seed: 'int | None', failure_policy_set, demand_set) -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsstore" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.store
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.store">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      
        Results
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflowstepmetadata" class="md-nav__link">
    <span class="md-ellipsis">
      
        WorkflowStepMetadata
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.profiling.profiler
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.profiling.profiler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performanceprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      
        PerformanceProfiler
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performancereporter" class="md-nav__link">
    <span class="md-ellipsis">
      
        PerformanceReporter
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profileresults" class="md-nav__link">
    <span class="md-ellipsis">
      
        ProfileResults
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stepprofile" class="md-nav__link">
    <span class="md-ellipsis">
      
        StepProfile
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphtypesbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.types.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.types.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeselect" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeSelect
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowPlacement
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mode" class="md-nav__link">
    <span class="md-ellipsis">
      
        Mode
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphtypesdto" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.types.dto
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.types.dto">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeref" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeRef
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxflowresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaxFlowResult
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsids" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.ids
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.ids">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#new_base64_uuid-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        new_base64_uuid() -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsoutput_paths" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.output_paths
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.output_paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ensure_parent_dirpath-path-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        ensure_parent_dir(path: 'Path') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scenario_prefix_from_pathscenario_path-path-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsseed_manager" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.seed_manager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.seed_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seedmanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        SeedManager
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsyaml_utils" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.yaml_utils
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.yaml_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" class="md-nav__link">
    <span class="md-ellipsis">
      
        normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.context
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.context">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        AnalysisContext
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#augmentationedge" class="md-nav__link">
    <span class="md-ellipsis">
      
        AugmentationEdge
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analyzenetwork-network-source-optionalunionstr-dictstr-any-none-sink-optionalunionstr-dictstr-any-none-mode-mode-augmentations-optionallistaugmentationedge-none-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        analyze(network: "'Network'", *, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, mode: 'Mode' = , augmentations: 'Optional[List[AugmentationEdge]]' = None) -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_edge_maskctx-analysiscontext-excluded_links-optionalsetstr-none-npndarray" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_edge_mask(ctx: 'AnalysisContext', excluded_links: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_node_maskctx-analysiscontext-excluded_nodes-optionalsetstr-none-npndarray" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_node_mask(ctx: 'AnalysisContext', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisdemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.demand
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.demand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demandexpansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        DemandExpansion
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expandeddemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExpandedDemand
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_demandsnetwork-network-traffic_demands-listtrafficdemand-default_policy_preset-flowpolicypreset-demandexpansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_demands(network: 'Network', traffic_demands: 'List[TrafficDemand]', default_policy_preset: 'FlowPolicyPreset' = ) -&gt; 'DemandExpansion'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisfailure_manager" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.failure_manager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.failure_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysisfunction" class="md-nav__link">
    <span class="md-ellipsis">
      
        AnalysisFunction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureManager
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisfunctions" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.functions
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_demand_contextnetwork-network-demands_config-listdictstr-any-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_demand_context(network: "'Network'", demands_config: 'list[dict[str, Any]]') -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_maxflow_contextnetwork-network-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_maxflow_context(network: "'Network'", source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine') -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demand_placement_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        demand_placement_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-require_capacity-bool-true-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        max_flow_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = , include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensitivity_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.placement
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.placement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#placemententry" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementEntry
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementResult
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementsummary" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementSummary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#place_demandsdemands-sequenceexpandeddemand-volumes-sequencefloat-flow_graph-netgraph_coreflowgraph-ctx-analysiscontext-node_mask-npndarray-edge_mask-npndarray-resolved_ids-sequencetupleint-int-none-none-collect_entries-bool-false-include_cost_distribution-bool-false-include_used_edges-bool-false-placementresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        place_demands(demands: "Sequence['ExpandedDemand']", volumes: 'Sequence[float]', flow_graph: 'netgraph_core.FlowGraph', ctx: "'AnalysisContext'", node_mask: 'np.ndarray', edge_mask: 'np.ndarray', *, resolved_ids: 'Sequence[tuple[int, int]] | None' = None, collect_entries: 'bool' = False, include_cost_distribution: 'bool' = False, include_used_edges: 'bool' = False) -&gt; 'PlacementResult'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlibnx" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.lib.nx
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.lib.nx">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeMap
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeMap
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#from_networkxg-nxgraph-capacity_attr-str-capacity-cost_attr-str-cost-default_capacity-float-10-default_cost-int-1-bidirectional-bool-false-tuplenetgraph_corestrictmultidigraph-nodemap-edgemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        from_networkx(G: 'NxGraph', *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost', default_capacity: 'float' = 1.0, default_cost: 'int' = 1, bidirectional: 'bool' = False) -&gt; 'Tuple[netgraph_core.StrictMultiDiGraph, NodeMap, EdgeMap]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_networkxgraph-netgraph_corestrictmultidigraph-node_map-optionalnodemap-none-capacity_attr-str-capacity-cost_attr-str-cost-nxmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_networkx(graph: 'netgraph_core.StrictMultiDiGraph', node_map: 'Optional[NodeMap]' = None, *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost') -&gt; "'nx.MultiDiGraph'"
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#error-handling" class="md-nav__link">
    <span class="md-ellipsis">
      
        Error Handling
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ngraphcli" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.cli
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.cli">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mainargv-optionalliststr-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        main(argv: 'Optional[List[str]]' = None) -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.explorer
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.explorer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#externallinkbreakdown" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExternalLinkBreakdown
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkcapacityissue" class="md-nav__link">
    <span class="md-ellipsis">
      
        LinkCapacityIssue
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkexplorer" class="md-nav__link">
    <span class="md-ellipsis">
      
        NetworkExplorer
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeutilization" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeUtilization
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treenode" class="md-nav__link">
    <span class="md-ellipsis">
      
        TreeNode
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#treestats" class="md-nav__link">
    <span class="md-ellipsis">
      
        TreeStats
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlogging" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.logging
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.logging">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#disable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        disable_debug_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enable_debug_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        enable_debug_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_loggername-str-logginglogger" class="md-nav__link">
    <span class="md-ellipsis">
      
        get_logger(name: str) -&gt; logging.Logger
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset_logging-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        reset_logging() -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_global_log_levellevel-int-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        set_global_log_level(level: int) -&gt; None
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphscenario" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.scenario
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.scenario">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario" class="md-nav__link">
    <span class="md-ellipsis">
      
        Scenario
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelcomponents" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.components
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.components">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#component" class="md-nav__link">
    <span class="md-ellipsis">
      
        Component
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#componentslibrary" class="md-nav__link">
    <span class="md-ellipsis">
      
        ComponentsLibrary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" class="md-nav__link">
    <span class="md-ellipsis">
      
        totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandbuilder" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.builder
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.builder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_demand_setraw-dictstr-listdict-demandset" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_demand_set(raw: 'Dict[str, List[dict]]') -&gt; 'DemandSet'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandmatrix" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.matrix
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.matrix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demandset" class="md-nav__link">
    <span class="md-ellipsis">
      
        DemandSet
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodeldemandspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.demand.spec
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.demand.spec">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficdemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        TrafficDemand
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailuregenerate" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.generate
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.generate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generatespec" class="md-nav__link">
    <span class="md-ellipsis">
      
        GenerateSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_risk_groupsnetwork-network-spec-generatespec-listriskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        generate_risk_groups(network: "'Network'", spec: 'GenerateSpec') -&gt; 'List[RiskGroup]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_generate_specraw-dictstr-any-generatespec" class="md-nav__link">
    <span class="md-ellipsis">
      
        parse_generate_spec(raw: 'Dict[str, Any]') -&gt; 'GenerateSpec'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailuremembership" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.membership
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.membership">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#membershipspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        MembershipSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_membership_rulesnetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_membership_rules(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailureparser" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.parser
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.parser">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_failure_policyfp_data-dictstr-any-policy_name-str-derive_seed-callablestr-optionalint-failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_failure_policy(fp_data: 'Dict[str, Any]', *, policy_name: 'str', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicy'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_failure_policy_setraw-dictstr-any-derive_seed-callablestr-optionalint-failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_failure_policy_set(raw: 'Dict[str, Any]', *, derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicySet'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_risk_groupsrg_data-listany-tuplelistriskgroup-listdictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_risk_groups(rg_data: 'List[Any]') -&gt; 'tuple[List[RiskGroup], List[Dict[str, Any]]]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.policy
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.policy">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failuremode" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureMode
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePolicy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurerule" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureRule
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurepolicy_set" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.policy_set
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.policy_set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#failurepolicyset" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePolicySet
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelfailurevalidation" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.failure.validation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.failure.validation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#validate_risk_group_hierarchynetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        validate_risk_group_hierarchy(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validate_risk_group_referencesnetwork-network-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        validate_risk_group_references(network: "'Network'") -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelflowpolicy_config" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.flow.policy_config
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.flow.policy_config">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowpolicypreset" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowPolicyPreset
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create_flow_policyalgorithms-netgraph_corealgorithms-graph-netgraph_coregraph-preset-flowpolicypreset-node_masknone-edge_masknone-netgraph_coreflowpolicy" class="md-nav__link">
    <span class="md-ellipsis">
      
        create_flow_policy(algorithms: 'netgraph_core.Algorithms', graph: 'netgraph_core.Graph', preset: 'FlowPolicyPreset', node_mask=None, edge_mask=None) -&gt; 'netgraph_core.FlowPolicy'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#serialize_policy_presetcfg-any-optionalstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        serialize_policy_preset(cfg: 'Any') -&gt; 'Optional[str]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelnetwork" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.network
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#link" class="md-nav__link">
    <span class="md-ellipsis">
      
        Link
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    <span class="md-ellipsis">
      
        Node
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#riskgroup" class="md-nav__link">
    <span class="md-ellipsis">
      
        RiskGroup
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphmodelpath" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.model.path
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.model.path">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#path" class="md-nav__link">
    <span class="md-ellipsis">
      
        Path
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#workflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      
        WorkflowStep
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_workflow_stepstep_type-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        register_workflow_step(step_type: 'str')
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_parallelismparallelism-unionint-str-int" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_parallelism(parallelism: 'Union[int, str]') -&gt; 'int'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowbuild_graph" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.build_graph
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.build_graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buildgraph" class="md-nav__link">
    <span class="md-ellipsis">
      
        BuildGraph
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowcost_power" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.cost_power
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.cost_power">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#costpower" class="md-nav__link">
    <span class="md-ellipsis">
      
        CostPower
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmax_flow_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.max_flow_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.max_flow_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxflow" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaxFlow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowmaximum_supported_demand_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.maximum_supported_demand_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.maximum_supported_demand_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maximumsupporteddemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaximumSupportedDemand
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflownetwork_stats" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.network_stats
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.network_stats">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#networkstats" class="md-nav__link">
    <span class="md-ellipsis">
      
        NetworkStats
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowparse" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.parse
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.parse">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_workflow_stepsworkflow_data-listdictstr-any-derive_seed-callablestr-optionalint-listworkflowstep" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_workflow_steps(workflow_data: 'List[Dict[str, Any]]', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'List[WorkflowStep]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphworkflowtraffic_matrix_placement_step" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.workflow.traffic_matrix_placement_step
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.workflow.traffic_matrix_placement_step">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trafficmatrixplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        TrafficMatrixPlacement
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsexpand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.blueprints.expand
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.expand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    <span class="md-ellipsis">
      
        Blueprint
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dslexpansioncontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        DSLExpansionContext
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_network_dsldata-dictstr-any-network" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslblueprintsparser" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.blueprints.parser
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.blueprints.parser">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check_link_keyslink_def-dictstr-any-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        check_link_keys(link_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_pathsparent_path-str-rel_path-str-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionbrackets" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.brackets
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.brackets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_name_patternsname-str-liststr" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_name_patterns(name: 'str') -&gt; 'List[str]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_risk_group_refsrg_list-iterablestr-setstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_risk_group_refs(rg_list: 'Iterable[str]') -&gt; 'Set[str]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionschema" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.schema
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.schema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expansionspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExpansionSpec
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslexpansionvariables" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.expansion.variables
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.expansion.variables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expand_blockblock-dictstr-any-spec-optionalexpansionspec-iteratordictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_block(block: 'Dict[str, Any]', spec: "Optional['ExpansionSpec']") -&gt; 'Iterator[Dict[str, Any]]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_templatestemplates-dictstr-str-spec-expansionspec-iteratordictstr-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_templates(templates: 'Dict[str, str]', spec: "'ExpansionSpec'") -&gt; 'Iterator[Dict[str, str]]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substitute_varsobj-any-var_dict-dictstr-any-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        substitute_vars(obj: 'Any', var_dict: 'Dict[str, Any]') -&gt; 'Any'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslloader" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.loader
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.loader">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#load_scenario_yamlyaml_str-str-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        load_scenario_yaml(yaml_str: 'str') -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsconditions" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.conditions
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionattrs-dictstr-any-cond-condition-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        evaluate_condition(attrs: 'Dict[str, Any]', cond: "'Condition'") -&gt; 'bool'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluate_conditionsattrs-dictstr-any-conditions-iterablecondition-logic-str-or-bool" class="md-nav__link">
    <span class="md-ellipsis">
      
        evaluate_conditions(attrs: 'Dict[str, Any]', conditions: "Iterable['Condition']", logic: 'str' = 'or') -&gt; 'bool'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_attr_pathattrs-dictstr-any-path-str-tuplebool-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_attr_path(attrs: 'Dict[str, Any]', path: 'str') -&gt; 'Tuple[bool, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsnormalize" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.normalize
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.normalize">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_selectorraw-unionstr-dictstr-any-nodeselector-context-str-nodeselector" class="md-nav__link">
    <span class="md-ellipsis">
      
        normalize_selector(raw: 'Union[str, Dict[str, Any], NodeSelector]', context: 'str') -&gt; 'NodeSelector'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_match_specraw-dictstr-any-default_logic-literaland-or-or-require_conditions-bool-false-context-str-match-matchspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        parse_match_spec(raw: 'Dict[str, Any]', *, default_logic: "Literal['and', 'or']" = 'or', require_conditions: 'bool' = False, context: 'str' = 'match') -&gt; 'MatchSpec'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsschema" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.schema
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.schema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#condition" class="md-nav__link">
    <span class="md-ellipsis">
      
        Condition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matchspec" class="md-nav__link">
    <span class="md-ellipsis">
      
        MatchSpec
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodeselector" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeSelector
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphdslselectorsselect" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.dsl.selectors.select
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.dsl.selectors.select">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flatten_link_attrslink-link-link_id-str-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_link_attrs(link: "'Link'", link_id: 'str') -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatten_node_attrsnode-node-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_node_attrs(node: "'Node'") -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatten_risk_group_attrsrg-unionriskgroup-dictstr-any-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        flatten_risk_group_attrs(rg: "Union['RiskGroup', Dict[str, Any]]") -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#match_entity_idsentity_attrs-dictstr-dictstr-any-conditions-listcondition-logic-str-or-setstr" class="md-nav__link">
    <span class="md-ellipsis">
      
        match_entity_ids(entity_attrs: 'Dict[str, Dict[str, Any]]', conditions: 'List[Condition]', logic: 'str' = 'or') -&gt; 'Set[str]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_nodesnetwork-network-selector-nodeselector-default_active_only-bool-excluded_nodes-optionalsetstr-none-dictstr-listnode" class="md-nav__link">
    <span class="md-ellipsis">
      
        select_nodes(network: "'Network'", selector: 'NodeSelector', default_active_only: 'bool', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; "Dict[str, List['Node']]"
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsartifacts" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.artifacts
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.artifacts">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capacityenvelope" class="md-nav__link">
    <span class="md-ellipsis">
      
        CapacityEnvelope
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failurepatternresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailurePatternResult
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsflow" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.flow
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.flow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flowentry" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowEntry
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowIterationResult
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowsummary" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowSummary
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultssnapshot" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.snapshot
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.snapshot">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_scenario_snapshot-seed-int-none-failure_policy_set-demand_set-dictstr-any" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_scenario_snapshot(*, seed: 'int | None', failure_policy_set, demand_set) -&gt; 'Dict[str, Any]'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphresultsstore" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.results.store
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.results.store">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      
        Results
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#workflowstepmetadata" class="md-nav__link">
    <span class="md-ellipsis">
      
        WorkflowStepMetadata
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphprofilingprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.profiling.profiler
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.profiling.profiler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performanceprofiler" class="md-nav__link">
    <span class="md-ellipsis">
      
        PerformanceProfiler
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#performancereporter" class="md-nav__link">
    <span class="md-ellipsis">
      
        PerformanceReporter
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profileresults" class="md-nav__link">
    <span class="md-ellipsis">
      
        ProfileResults
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stepprofile" class="md-nav__link">
    <span class="md-ellipsis">
      
        StepProfile
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphtypesbase" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.types.base
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.types.base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeselect" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeSelect
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flowplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        FlowPlacement
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mode" class="md-nav__link">
    <span class="md-ellipsis">
      
        Mode
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphtypesdto" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.types.dto
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.types.dto">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgeref" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeRef
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxflowresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        MaxFlowResult
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsids" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.ids
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.ids">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#new_base64_uuid-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        new_base64_uuid() -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsoutput_paths" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.output_paths
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.output_paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ensure_parent_dirpath-path-none" class="md-nav__link">
    <span class="md-ellipsis">
      
        ensure_parent_dir(path: 'Path') -&gt; 'None'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" class="md-nav__link">
    <span class="md-ellipsis">
      
        resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" class="md-nav__link">
    <span class="md-ellipsis">
      
        results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scenario_prefix_from_pathscenario_path-path-str" class="md-nav__link">
    <span class="md-ellipsis">
      
        scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsseed_manager" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.seed_manager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.seed_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seedmanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        SeedManager
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphutilsyaml_utils" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.utils.yaml_utils
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.utils.yaml_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" class="md-nav__link">
    <span class="md-ellipsis">
      
        normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.context
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.context">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        AnalysisContext
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#augmentationedge" class="md-nav__link">
    <span class="md-ellipsis">
      
        AugmentationEdge
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analyzenetwork-network-source-optionalunionstr-dictstr-any-none-sink-optionalunionstr-dictstr-any-none-mode-mode-augmentations-optionallistaugmentationedge-none-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        analyze(network: "'Network'", *, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, mode: 'Mode' = , augmentations: 'Optional[List[AugmentationEdge]]' = None) -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_edge_maskctx-analysiscontext-excluded_links-optionalsetstr-none-npndarray" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_edge_mask(ctx: 'AnalysisContext', excluded_links: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_node_maskctx-analysiscontext-excluded_nodes-optionalsetstr-none-npndarray" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_node_mask(ctx: 'AnalysisContext', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisdemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.demand
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.demand">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demandexpansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        DemandExpansion
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expandeddemand" class="md-nav__link">
    <span class="md-ellipsis">
      
        ExpandedDemand
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expand_demandsnetwork-network-traffic_demands-listtrafficdemand-default_policy_preset-flowpolicypreset-demandexpansion" class="md-nav__link">
    <span class="md-ellipsis">
      
        expand_demands(network: 'Network', traffic_demands: 'List[TrafficDemand]', default_policy_preset: 'FlowPolicyPreset' = ) -&gt; 'DemandExpansion'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisfailure_manager" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.failure_manager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.failure_manager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analysisfunction" class="md-nav__link">
    <span class="md-ellipsis">
      
        AnalysisFunction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#failuremanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        FailureManager
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisfunctions" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.functions
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build_demand_contextnetwork-network-demands_config-listdictstr-any-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_demand_context(network: "'Network'", demands_config: 'list[dict[str, Any]]') -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_maxflow_contextnetwork-network-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-analysiscontext" class="md-nav__link">
    <span class="md-ellipsis">
      
        build_maxflow_context(network: "'Network'", source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine') -&gt; 'AnalysisContext'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demand_placement_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        demand_placement_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max_flow_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-require_capacity-bool-true-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        max_flow_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = , include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sensitivity_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-context-optionalanalysiscontext-none-flowiterationresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        sensitivity_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = , context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphanalysisplacement" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.analysis.placement
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.analysis.placement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#placemententry" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementEntry
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementResult
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#placementsummary" class="md-nav__link">
    <span class="md-ellipsis">
      
        PlacementSummary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#place_demandsdemands-sequenceexpandeddemand-volumes-sequencefloat-flow_graph-netgraph_coreflowgraph-ctx-analysiscontext-node_mask-npndarray-edge_mask-npndarray-resolved_ids-sequencetupleint-int-none-none-collect_entries-bool-false-include_cost_distribution-bool-false-include_used_edges-bool-false-placementresult" class="md-nav__link">
    <span class="md-ellipsis">
      
        place_demands(demands: "Sequence['ExpandedDemand']", volumes: 'Sequence[float]', flow_graph: 'netgraph_core.FlowGraph', ctx: "'AnalysisContext'", node_mask: 'np.ndarray', edge_mask: 'np.ndarray', *, resolved_ids: 'Sequence[tuple[int, int]] | None' = None, collect_entries: 'bool' = False, include_cost_distribution: 'bool' = False, include_used_edges: 'bool' = False) -&gt; 'PlacementResult'
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ngraphlibnx" class="md-nav__link">
    <span class="md-ellipsis">
      
        ngraph.lib.nx
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngraph.lib.nx">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edgemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        EdgeMap
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        NodeMap
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#from_networkxg-nxgraph-capacity_attr-str-capacity-cost_attr-str-cost-default_capacity-float-10-default_cost-int-1-bidirectional-bool-false-tuplenetgraph_corestrictmultidigraph-nodemap-edgemap" class="md-nav__link">
    <span class="md-ellipsis">
      
        from_networkx(G: 'NxGraph', *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost', default_capacity: 'float' = 1.0, default_cost: 'int' = 1, bidirectional: 'bool' = False) -&gt; 'Tuple[netgraph_core.StrictMultiDiGraph, NodeMap, EdgeMap]'
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_networkxgraph-netgraph_corestrictmultidigraph-node_map-optionalnodemap-none-capacity_attr-str-capacity-cost_attr-str-cost-nxmultidigraph" class="md-nav__link">
    <span class="md-ellipsis">
      
        to_networkx(graph: 'netgraph_core.StrictMultiDiGraph', node_map: 'Optional[NodeMap]' = None, *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost') -&gt; "'nx.MultiDiGraph'"
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#error-handling" class="md-nav__link">
    <span class="md-ellipsis">
      
        Error Handling
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<!-- markdownlint-disable MD007 MD032 MD029 MD050 MD004 MD052 MD012 -->

<h1 id="netgraph-api-reference-auto-generated">NetGraph API Reference (Auto-Generated)<a class="headerlink" href="#netgraph-api-reference-auto-generated" title="Permanent link">&para;</a></h1>
<p>This is the complete auto-generated API documentation for NetGraph.
For a curated, example-driven API guide, see <a href="../api/">api.md</a>.</p>
<p>Quick links:</p>
<ul>
<li><a href="../api/">Main API Guide (api.md)</a></li>
<li><a href="./">This Document (api-full.md)</a></li>
<li><a href="../cli/">CLI Reference</a></li>
<li><a href="../dsl/">DSL Reference</a></li>
</ul>
<p>Generated from source code on: February 08, 2026 at 18:49 UTC</p>
<p>Modules auto-discovered: 52</p>
<hr />
<h2 id="ngraphcli">ngraph.cli<a class="headerlink" href="#ngraphcli" title="Permanent link">&para;</a></h2>
<p>Command-line interface for NetGraph.</p>
<h3 id="mainargv-optionalliststr-none-none">main(argv: 'Optional[List[str]]' = None) -&gt; 'None'<a class="headerlink" href="#mainargv-optionalliststr-none-none" title="Permanent link">&para;</a></h3>
<p>Entry point for the <code>ngraph</code> command.</p>
<p>Args:
    argv: Optional list of command-line arguments. If <code>None</code>, <code>sys.argv</code>
        is used.</p>
<hr />
<h2 id="ngraphexplorer">ngraph.explorer<a class="headerlink" href="#ngraphexplorer" title="Permanent link">&para;</a></h2>
<p>NetworkExplorer class for analyzing network hierarchy and structure.</p>
<h3 id="externallinkbreakdown">ExternalLinkBreakdown<a class="headerlink" href="#externallinkbreakdown" title="Permanent link">&para;</a></h3>
<p>Holds stats for external links to a particular other subtree.</p>
<p>Attributes:
    link_count (int): Number of links to that other subtree.
    link_capacity (float): Sum of capacities for those links.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>link_count</code> (int) = 0</li>
<li><code>link_capacity</code> (float) = 0.0</li>
</ul>
<h3 id="linkcapacityissue">LinkCapacityIssue<a class="headerlink" href="#linkcapacityissue" title="Permanent link">&para;</a></h3>
<p>Represents a link capacity constraint violation in active topology.</p>
<p>Attributes:
    source: Source node name.
    target: Target node name.
    capacity: Configured link capacity.
    limit: Effective capacity limit from per-end hardware (min of ends).
    reason: Brief reason tag.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>target</code> (str)</li>
<li><code>capacity</code> (float)</li>
<li><code>limit</code> (float)</li>
<li><code>reason</code> (str)</li>
</ul>
<h3 id="networkexplorer">NetworkExplorer<a class="headerlink" href="#networkexplorer" title="Permanent link">&para;</a></h3>
<p>Provides hierarchical exploration of a Network, computing statistics in two modes:
'all' (ignores disabled) and 'active' (only enabled).</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>explore_network(network: 'Network', components_library: 'Optional[ComponentsLibrary]' = None, strict_validation: 'bool' = True) -&gt; 'NetworkExplorer'</code> - Build a NetworkExplorer, constructing a tree plus 'all' and 'active' stats.</li>
<li><code>get_bom(self, include_disabled: 'bool' = True) -&gt; 'Dict[str, float]'</code> - Return aggregated hardware BOM for the whole network.</li>
<li><code>get_bom_by_path(self, path: 'str', include_disabled: 'bool' = True) -&gt; 'Dict[str, float]'</code> - Return the hardware BOM for a specific hierarchy path.</li>
<li><code>get_bom_map(self, include_disabled: 'bool' = True, include_root: 'bool' = True, root_label: 'str' = '') -&gt; 'Dict[str, Dict[str, float]]'</code> - Return a mapping from hierarchy path to BOM for each subtree.</li>
<li><code>get_link_issues(self) -&gt; 'List[LinkCapacityIssue]'</code> - Return recorded link capacity issues discovered in non-strict mode.</li>
<li><code>get_node_utilization(self, include_disabled: 'bool' = True) -&gt; 'List[NodeUtilization]'</code> - Return hardware utilization per node based on active topology.</li>
<li><code>print_tree(self, node: 'Optional[TreeNode]' = None, indent: 'int' = 0, max_depth: 'Optional[int]' = None, skip_leaves: 'bool' = False, detailed: 'bool' = False, include_disabled: 'bool' = True, max_external_lines: 'Optional[int]' = None, line_prefix: 'str' = '') -&gt; 'None'</code> - Print the hierarchy from 'node' down (default: root).</li>
</ul>
<h3 id="nodeutilization">NodeUtilization<a class="headerlink" href="#nodeutilization" title="Permanent link">&para;</a></h3>
<p>Per-node hardware utilization snapshot based on active topology.</p>
<p>Attributes:
    node_name: Fully qualified node name.
    component_name: Hardware component name if present.
    hw_count: Hardware multiplicity used for capacity/power scaling.
    capacity_supported: Total capacity supported by node hardware.
    attached_capacity_active: Sum of capacities of enabled adjacent links where the
        opposite endpoint is also enabled.
    capacity_utilization: Ratio of attached to supported capacity (0.0 when N/A).
    ports_available: Total port equivalents available on the node (0.0 when N/A).
    ports_used: Sum of port equivalents used by per-end link optics attached to this
        node on active links.
    ports_utilization: Ratio of used to available ports (0.0 when N/A).
    capacity_violation: True if attached capacity exceeds supported capacity.
    ports_violation: True if used ports exceed available ports.
    disabled: True if the node itself is disabled.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>node_name</code> (str)</li>
<li><code>component_name</code> (Optional[str])</li>
<li><code>hw_count</code> (float)</li>
<li><code>capacity_supported</code> (float)</li>
<li><code>attached_capacity_active</code> (float)</li>
<li><code>capacity_utilization</code> (float)</li>
<li><code>ports_available</code> (float)</li>
<li><code>ports_used</code> (float)</li>
<li><code>ports_utilization</code> (float)</li>
<li><code>capacity_violation</code> (bool)</li>
<li><code>ports_violation</code> (bool)</li>
<li><code>disabled</code> (bool)</li>
</ul>
<h3 id="treenode">TreeNode<a class="headerlink" href="#treenode" title="Permanent link">&para;</a></h3>
<p>Represents a node in the hierarchical tree.</p>
<p>Attributes:
    name (str): Name/label of this node.
    parent (Optional[TreeNode]): Pointer to the parent tree node.
    children (Dict[str, TreeNode]): Mapping of child name -&gt; child TreeNode.
    subtree_nodes (Set[str]): Node names in the subtree (all nodes, ignoring disabled).
    active_subtree_nodes (Set[str]): Node names in the subtree (only enabled).
    stats (TreeStats): Aggregated stats for "all" view.
    active_stats (TreeStats): Aggregated stats for "active" (only enabled) view.
    raw_nodes (List[Node]): Direct Node objects at this hierarchy level.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>parent</code> (Optional[TreeNode])</li>
<li><code>children</code> (Dict[str, TreeNode]) = {}</li>
<li><code>subtree_nodes</code> (Set[str]) = set()</li>
<li><code>active_subtree_nodes</code> (Set[str]) = set()</li>
<li><code>stats</code> (TreeStats) = TreeStats(node_count=0, internal_link_count=0, internal_link_capacity=0.0, external_link_count=0, external_link_capacity=0.0, external_link_details={}, total_capex=0.0, total_power=0.0, bom={}, active_bom={})</li>
<li><code>active_stats</code> (TreeStats) = TreeStats(node_count=0, internal_link_count=0, internal_link_capacity=0.0, external_link_count=0, external_link_capacity=0.0, external_link_details={}, total_capex=0.0, total_power=0.0, bom={}, active_bom={})</li>
<li><code>raw_nodes</code> (List[Node]) = []</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add_child(self, child_name: 'str') -&gt; 'TreeNode'</code> - Ensure a child node named 'child_name' exists and return it.</li>
<li><code>is_leaf(self) -&gt; 'bool'</code> - Return True if this node has no children.</li>
</ul>
<h3 id="treestats">TreeStats<a class="headerlink" href="#treestats" title="Permanent link">&para;</a></h3>
<p>Aggregated statistics for a single tree node (subtree).</p>
<p>Attributes:
    node_count (int): Total number of nodes in this subtree.
    internal_link_count (int): Number of internal links in this subtree.
    internal_link_capacity (float): Sum of capacities for those internal links.
    external_link_count (int): Number of external links from this subtree to another.
    external_link_capacity (float): Sum of capacities for those external links.
    external_link_details (Dict[str, ExternalLinkBreakdown]): Breakdown by other subtree path.
    total_capex (float): Cumulative capex (nodes + links).
    total_power (float): Cumulative power (nodes + links).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>node_count</code> (int) = 0</li>
<li><code>internal_link_count</code> (int) = 0</li>
<li><code>internal_link_capacity</code> (float) = 0.0</li>
<li><code>external_link_count</code> (int) = 0</li>
<li><code>external_link_capacity</code> (float) = 0.0</li>
<li><code>external_link_details</code> (Dict[str, ExternalLinkBreakdown]) = {}</li>
<li><code>total_capex</code> (float) = 0.0</li>
<li><code>total_power</code> (float) = 0.0</li>
<li><code>bom</code> (Dict[str, float]) = {}</li>
<li><code>active_bom</code> (Dict[str, float]) = {}</li>
</ul>
<hr />
<h2 id="ngraphlogging">ngraph.logging<a class="headerlink" href="#ngraphlogging" title="Permanent link">&para;</a></h2>
<p>Centralized logging configuration for NetGraph.</p>
<h3 id="disable_debug_logging-none">disable_debug_logging() -&gt; None<a class="headerlink" href="#disable_debug_logging-none" title="Permanent link">&para;</a></h3>
<p>Disable debug logging, set to INFO level.</p>
<h3 id="enable_debug_logging-none">enable_debug_logging() -&gt; None<a class="headerlink" href="#enable_debug_logging-none" title="Permanent link">&para;</a></h3>
<p>Enable debug logging for the entire package.</p>
<h3 id="get_loggername-str-logginglogger">get_logger(name: str) -&gt; logging.Logger<a class="headerlink" href="#get_loggername-str-logginglogger" title="Permanent link">&para;</a></h3>
<p>Get a logger with NetGraph's standard configuration.</p>
<p>This is the main function that should be used throughout the package.
All loggers will inherit from the root 'ngraph' logger configuration.</p>
<p>Args:
    name: Logger name (typically <strong>name</strong> from calling module).</p>
<p>Returns:
    Configured logger instance.</p>
<h3 id="reset_logging-none">reset_logging() -&gt; None<a class="headerlink" href="#reset_logging-none" title="Permanent link">&para;</a></h3>
<p>Reset logging configuration (mainly for testing).</p>
<h3 id="set_global_log_levellevel-int-none">set_global_log_level(level: int) -&gt; None<a class="headerlink" href="#set_global_log_levellevel-int-none" title="Permanent link">&para;</a></h3>
<p>Set the log level for all NetGraph loggers.</p>
<p>Args:
    level: Logging level (e.g., logging.DEBUG, logging.INFO).</p>
<h3 id="setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none">setup_root_logger(level: int = 20, format_string: Optional[str] = None, handler: Optional[logging.Handler] = None) -&gt; None<a class="headerlink" href="#setup_root_loggerlevel-int-20-format_string-optionalstr-none-handler-optionallogginghandler-none-none" title="Permanent link">&para;</a></h3>
<p>Set up the root NetGraph logger with a single handler.</p>
<p>This should only be called once to avoid duplicate handlers.</p>
<p>Args:
    level: Logging level (default: INFO).
    format_string: Custom format string (optional).
    handler: Custom handler (optional, defaults to StreamHandler).</p>
<hr />
<h2 id="ngraphscenario">ngraph.scenario<a class="headerlink" href="#ngraphscenario" title="Permanent link">&para;</a></h2>
<p>Scenario class for defining network analysis workflows from YAML.</p>
<h3 id="scenario">Scenario<a class="headerlink" href="#scenario" title="Permanent link">&para;</a></h3>
<p>Represents a complete scenario for building and executing network workflows.</p>
<p>This scenario includes:</p>
<ul>
<li>A network (nodes/links), constructed via blueprint expansion.</li>
<li>A failure policy set (one or more named failure policies).</li>
<li>A traffic matrix set containing one or more named traffic matrices.</li>
<li>A list of workflow steps to execute.</li>
<li>A results container for storing outputs.</li>
<li>A components_library for hardware/optics definitions.</li>
<li>A seed for reproducible random operations (optional).</li>
</ul>
<p>Typical usage example:</p>
<div class="language-text highlight"><pre><span></span><code>scenario = Scenario.from_yaml(yaml_str, default_components=default_lib)
scenario.run()
# Inspect scenario.results
</code></pre></div>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>network</code> (Network)</li>
<li><code>workflow</code> (List[WorkflowStep])</li>
<li><code>failure_policy_set</code> (FailurePolicySet) = FailurePolicySet(policies={})</li>
<li><code>demand_set</code> (DemandSet) = DemandSet(sets={})</li>
<li><code>results</code> (Results) = Results(_store={}, _metadata={}, _active_step=None, _scenario={})</li>
<li><code>components_library</code> (ComponentsLibrary) = ComponentsLibrary(components={})</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_execution_counter</code> (int) = 0</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_yaml(yaml_str: 'str', default_components: 'Optional[ComponentsLibrary]' = None) -&gt; 'Scenario'</code> - Constructs a Scenario from a YAML string, optionally merging</li>
<li><code>run(self) -&gt; 'None'</code> - Executes the scenario's workflow steps in order.</li>
</ul>
<hr />
<h2 id="ngraphmodelcomponents">ngraph.model.components<a class="headerlink" href="#ngraphmodelcomponents" title="Permanent link">&para;</a></h2>
<p>Component and ComponentsLibrary classes for hardware capex/power modeling.</p>
<h3 id="component">Component<a class="headerlink" href="#component" title="Permanent link">&para;</a></h3>
<p>A generic component that can represent chassis, line cards, optics, etc.
Components can have nested children, each with their own capex, power, etc.</p>
<p>Attributes:
    name (str): Name of the component (e.g., "SpineChassis" or "400G-LR4").
    component_type (str): A string label (e.g., "chassis", "linecard", "optic").
    description (str): A human-readable description of this component.
    capex (float): Monetary capex of a single instance of this component.
    power_watts (float): Typical/nominal power usage (watts) for one instance.
    power_watts_max (float): Maximum/peak power usage (watts) for one instance.
    capacity (float): A generic capacity measure (e.g., platform capacity).
    ports (int): Number of ports if relevant for this component.
    count (int): How many identical copies of this component are present.
    attrs (Dict[str, Any]): Arbitrary key-value attributes for extra metadata.
    children (Dict[str, Component]): Nested child components (e.g., line cards
        inside a chassis), keyed by child name.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>component_type</code> (str) = generic</li>
<li><code>description</code> (str)</li>
<li><code>capex</code> (float) = 0.0</li>
<li><code>power_watts</code> (float) = 0.0</li>
<li><code>power_watts_max</code> (float) = 0.0</li>
<li><code>capacity</code> (float) = 0.0</li>
<li><code>ports</code> (int) = 0</li>
<li><code>count</code> (int) = 1</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>children</code> (Dict[str, Component]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>as_dict(self, include_children: 'bool' = True) -&gt; 'Dict[str, Any]'</code> - Returns a dictionary containing all properties of this component.</li>
<li><code>total_capacity(self) -&gt; 'float'</code> - Computes the total (recursive) capacity of this component,</li>
<li><code>total_capex(self) -&gt; 'float'</code> - Computes total capex including children, multiplied by count.</li>
<li><code>total_power(self) -&gt; 'float'</code> - Computes the total <em>typical</em> (recursive) power usage of this component,</li>
<li><code>total_power_max(self) -&gt; 'float'</code> - Computes the total <em>peak</em> (recursive) power usage of this component,</li>
</ul>
<h3 id="componentslibrary">ComponentsLibrary<a class="headerlink" href="#componentslibrary" title="Permanent link">&para;</a></h3>
<p>Holds a collection of named Components. Each entry is a top-level "template"
that can be referenced for cost/power/capacity lookups, possibly with nested children.</p>
<p>Example (YAML-like):
    components:
      BigSwitch:
        component_type: chassis
        cost: 20000
        power_watts: 1750
        capacity: 25600
        children:
          PIM16Q-16x200G:
            component_type: linecard
            cost: 1000
            power_watts: 10
            ports: 16
            count: 8
      200G-FR4:
        component_type: optic
        cost: 2000
        power_watts: 6
        power_watts_max: 6.5</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>components</code> (Dict[str, Component]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>clone(self) -&gt; 'ComponentsLibrary'</code> - Creates a deep copy of this ComponentsLibrary.</li>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; 'ComponentsLibrary'</code> - Constructs a ComponentsLibrary from a dictionary of raw component definitions.</li>
<li><code>from_yaml(yaml_str: 'str') -&gt; 'ComponentsLibrary'</code> - Constructs a ComponentsLibrary from a YAML string. If the YAML contains</li>
<li><code>get(self, name: 'str') -&gt; 'Optional[Component]'</code> - Retrieves a Component by its name from the library.</li>
<li><code>merge(self, other: 'ComponentsLibrary', override: 'bool' = True) -&gt; 'ComponentsLibrary'</code> - Merges another ComponentsLibrary into this one. By default (override=True),</li>
</ul>
<h3 id="resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool">resolve_link_end_components(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'tuple[tuple[Optional[Component], float, bool], tuple[Optional[Component], float, bool], bool]'<a class="headerlink" href="#resolve_link_end_componentsattrs-dictstr-any-library-componentslibrary-tupletupleoptionalcomponent-float-bool-tupleoptionalcomponent-float-bool-bool" title="Permanent link">&para;</a></h3>
<p>Resolve per-end hardware components for a link.</p>
<p>Input format inside <code>link.attrs</code>:</p>
<p>Structured mapping under <code>hardware</code> key only:
  <code>{"hardware": {"source": {"component": NAME, "count": N},
                   "target": {"component": NAME, "count": N}}}</code></p>
<p>Args:
    attrs: Link attributes mapping.
    library: Components library for lookups.</p>
<p>Exclusive usage:</p>
<ul>
<li>
<p>Optional <code>exclusive: true</code> per end indicates unsharable usage.</p>
<p>For exclusive ends, validation and BOM counting should round-up counts
to integers.</p>
</li>
</ul>
<p>Returns:
    ((src_comp, src_count, src_exclusive), (dst_comp, dst_count, dst_exclusive), per_end_specified)
    where components may be <code>None</code> if name is absent/unknown. <code>per_end_specified</code>
    is True when a structured per-end mapping is present.</p>
<h3 id="resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float">resolve_node_hardware(attrs: 'Dict[str, Any]', library: 'ComponentsLibrary') -&gt; 'Tuple[Optional[Component], float]'<a class="headerlink" href="#resolve_node_hardwareattrs-dictstr-any-library-componentslibrary-tupleoptionalcomponent-float" title="Permanent link">&para;</a></h3>
<p>Resolve node hardware from <code>attrs['hardware']</code>.</p>
<p>Expects the mapping: <code>{"hardware": {"component": NAME, "count": N}}</code>.
<code>count</code> defaults to 1 if missing or invalid. If <code>component</code> is missing
or unknown, returns <code>(None, 1.0)</code>.</p>
<p>Args:
    attrs: Node attributes mapping.
    library: Component library used for lookups.</p>
<p>Returns:
    Tuple of (component or None, positive multiplier).</p>
<h3 id="totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float">totals_with_multiplier(comp: 'Component', hw_count: 'float') -&gt; 'Tuple[float, float, float]'<a class="headerlink" href="#totals_with_multipliercomp-component-hw_count-float-tuplefloat-float-float" title="Permanent link">&para;</a></h3>
<p>Return (capex, power_watts, capacity) totals multiplied by <code>hw_count</code>.</p>
<p>Args:
    comp: Component definition (may include nested children and internal <code>count</code>).
    hw_count: External multiplier (e.g., number of modules used for a link or node).</p>
<p>Returns:
    Tuple of total capex, total power (typical), and total capacity as floats.</p>
<hr />
<h2 id="ngraphmodeldemandbuilder">ngraph.model.demand.builder<a class="headerlink" href="#ngraphmodeldemandbuilder" title="Permanent link">&para;</a></h2>
<p>Builders for demand sets.</p>
<p>Construct <code>DemandSet</code> from raw dictionaries (e.g. parsed YAML).</p>
<h3 id="build_demand_setraw-dictstr-listdict-demandset">build_demand_set(raw: 'Dict[str, List[dict]]') -&gt; 'DemandSet'<a class="headerlink" href="#build_demand_setraw-dictstr-listdict-demandset" title="Permanent link">&para;</a></h3>
<p>Build a <code>DemandSet</code> from a mapping of name -&gt; list of dicts.</p>
<p>Args:
    raw: Mapping where each key is a demand set name and each value is a list of
        dictionaries with <code>TrafficDemand</code> constructor fields.</p>
<p>Returns:
    Initialized <code>DemandSet</code> with constructed <code>TrafficDemand</code> objects.</p>
<p>Raises:
    ValueError: If <code>raw</code> is not a mapping of name -&gt; list[dict],
        or if required fields are missing.</p>
<hr />
<h2 id="ngraphmodeldemandmatrix">ngraph.model.demand.matrix<a class="headerlink" href="#ngraphmodeldemandmatrix" title="Permanent link">&para;</a></h2>
<p>Demand set containers.</p>
<p>Provides <code>DemandSet</code>, a named collection of <code>TrafficDemand</code> lists
used as input to demand expansion and placement. This module contains input
containers, not analysis results.</p>
<h3 id="demandset">DemandSet<a class="headerlink" href="#demandset" title="Permanent link">&para;</a></h3>
<p>Named collection of TrafficDemand lists.</p>
<p>This mutable container maps set names to lists of TrafficDemand objects,
allowing management of multiple demand sets for analysis.</p>
<p>Attributes:
    sets: Dictionary mapping set names to TrafficDemand lists.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>sets</code> (dict[str, list[TrafficDemand]]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add(self, name: 'str', demands: 'list[TrafficDemand]') -&gt; 'None'</code> - Add a demand list to the collection.</li>
<li><code>get_all_demands(self) -&gt; 'list[TrafficDemand]'</code> - Get all traffic demands from all sets combined.</li>
<li><code>get_default_set(self) -&gt; 'list[TrafficDemand]'</code> - Get default demand set.</li>
<li><code>get_set(self, name: 'str') -&gt; 'list[TrafficDemand]'</code> - Get a specific demand set by name.</li>
<li><code>to_dict(self) -&gt; 'dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphmodeldemandspec">ngraph.model.demand.spec<a class="headerlink" href="#ngraphmodeldemandspec" title="Permanent link">&para;</a></h2>
<p>Traffic demand specification.</p>
<p>Defines <code>TrafficDemand</code>, a user-facing specification used by demand expansion
and placement. It can carry either a concrete <code>FlowPolicy</code> instance or a
<code>FlowPolicyPreset</code> enum to construct one.</p>
<h3 id="trafficdemand">TrafficDemand<a class="headerlink" href="#trafficdemand" title="Permanent link">&para;</a></h3>
<p>Traffic demand specification using unified selectors.</p>
<p>Attributes:
    source: Source node selector (string path or selector dict).
    target: Target node selector (string path or selector dict).
    volume: Total demand volume.
    volume_placed: Portion of this demand placed so far.
    priority: Priority class (lower = higher priority).
    mode: Node pairing mode ("combine" or "pairwise").
    group_mode: How grouped nodes produce demands
        ("flatten", "per_group", "group_pairwise").
    flow_policy: Policy preset for routing.
    flow_policy_obj: Concrete policy instance (overrides flow_policy).
    attrs: Arbitrary user metadata.
    id: Unique identifier. Auto-generated if empty.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (Union)</li>
<li><code>target</code> (Union)</li>
<li><code>volume</code> (float) = 0.0</li>
<li><code>volume_placed</code> (float) = 0.0</li>
<li><code>priority</code> (int) = 0</li>
<li><code>mode</code> (str) = combine</li>
<li><code>group_mode</code> (str) = flatten</li>
<li><code>flow_policy</code> (Optional)</li>
<li><code>flow_policy_obj</code> (Optional)</li>
<li><code>attrs</code> (Dict) = {}</li>
<li><code>id</code> (str)</li>
</ul>
<hr />
<h2 id="ngraphmodelfailuregenerate">ngraph.model.failure.generate<a class="headerlink" href="#ngraphmodelfailuregenerate" title="Permanent link">&para;</a></h2>
<p>Dynamic risk group generation from entity attributes.</p>
<p>Provides functionality to auto-generate risk groups based on unique
attribute values from nodes or links.</p>
<h3 id="generatespec">GenerateSpec<a class="headerlink" href="#generatespec" title="Permanent link">&para;</a></h3>
<p>Parsed generate block specification.</p>
<p>Attributes:
    scope: Type of entities to group ("node" or "link").
    path: Optional regex pattern to filter entities by name.
    group_by: Attribute name to group by (supports dot-notation).
    name: Template for generated group names. Use ${value}
        as placeholder for the attribute value.
    attrs: Optional static attributes for generated groups.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>scope</code> (Literal['node', 'link'])</li>
<li><code>group_by</code> (str)</li>
<li><code>name</code> (str)</li>
<li><code>path</code> (Optional[str])</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="generate_risk_groupsnetwork-network-spec-generatespec-listriskgroup">generate_risk_groups(network: "'Network'", spec: 'GenerateSpec') -&gt; 'List[RiskGroup]'<a class="headerlink" href="#generate_risk_groupsnetwork-network-spec-generatespec-listriskgroup" title="Permanent link">&para;</a></h3>
<p>Generate risk groups from unique attribute values.</p>
<p>For each unique value of the specified attribute, creates a new risk
group and adds all matching entities to it.</p>
<p>Args:
    network: Network with nodes and links populated.
    spec: Generation specification.</p>
<p>Returns:
    List of newly created RiskGroup objects.</p>
<p>Note:
    This function modifies entity risk_groups sets in place.</p>
<h3 id="parse_generate_specraw-dictstr-any-generatespec">parse_generate_spec(raw: 'Dict[str, Any]') -&gt; 'GenerateSpec'<a class="headerlink" href="#parse_generate_specraw-dictstr-any-generatespec" title="Permanent link">&para;</a></h3>
<p>Parse raw generate dict into a GenerateSpec.</p>
<p>Args:
    raw: Raw generate dict from YAML.</p>
<p>Returns:
    Parsed GenerateSpec.</p>
<p>Raises:
    ValueError: If required fields are missing or invalid.</p>
<hr />
<h2 id="ngraphmodelfailuremembership">ngraph.model.failure.membership<a class="headerlink" href="#ngraphmodelfailuremembership" title="Permanent link">&para;</a></h2>
<p>Risk group membership rule resolution.</p>
<p>Provides functionality to resolve policy-based membership rules that
auto-assign entities (nodes, links, risk groups) to risk groups based
on attribute conditions.</p>
<h3 id="membershipspec">MembershipSpec<a class="headerlink" href="#membershipspec" title="Permanent link">&para;</a></h3>
<p>Parsed membership rule specification.</p>
<p>Attributes:
    scope: Type of entities to match ("node", "link", or "risk_group").
    path: Optional regex pattern to filter entities by name.
    match: Match specification with conditions.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>scope</code> (EntityScope)</li>
<li><code>path</code> (Optional[str])</li>
<li><code>match</code> (Optional[MatchSpec])</li>
</ul>
<h3 id="resolve_membership_rulesnetwork-network-none">resolve_membership_rules(network: "'Network'") -&gt; 'None'<a class="headerlink" href="#resolve_membership_rulesnetwork-network-none" title="Permanent link">&para;</a></h3>
<p>Apply membership rules to populate entity risk_groups sets.</p>
<p>For each risk group with a <code>_membership_raw</code> specification:</p>
<ul>
<li>If scope is "node" or "link": adds the risk group name to each</li>
</ul>
<p>matched entity's risk_groups set.</p>
<ul>
<li>If scope is "risk_group": adds matched risk groups as children</li>
</ul>
<p>of this risk group (hierarchical membership).</p>
<p>Args:
    network: Network with risk_groups, nodes, and links populated.</p>
<p>Note:
    This function modifies entities in place. It should be called after
    all risk groups are registered but before validation.</p>
<hr />
<h2 id="ngraphmodelfailureparser">ngraph.model.failure.parser<a class="headerlink" href="#ngraphmodelfailureparser" title="Permanent link">&para;</a></h2>
<p>Parsers for FailurePolicySet and related failure modeling structures.</p>
<h3 id="build_failure_policyfp_data-dictstr-any-policy_name-str-derive_seed-callablestr-optionalint-failurepolicy">build_failure_policy(fp_data: 'Dict[str, Any]', *, policy_name: 'str', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicy'<a class="headerlink" href="#build_failure_policyfp_data-dictstr-any-policy_name-str-derive_seed-callablestr-optionalint-failurepolicy" title="Permanent link">&para;</a></h3>
<p>Build a FailurePolicy from a raw configuration dictionary.</p>
<p>Parses modes, rules, and conditions from the policy definition and
constructs a fully initialized FailurePolicy object.</p>
<p>Args:
    fp_data: Policy definition dict with keys: modes (required), attrs,
        expand_groups, expand_children. Each mode contains weight and rules.
    policy_name: Name identifier for this policy (used for seed derivation).
    derive_seed: Callable to derive deterministic seeds from component names.</p>
<p>Returns:
    FailurePolicy: Configured policy with parsed modes and rules.</p>
<p>Raises:
    ValueError: If modes is empty or malformed, or if rules are invalid.</p>
<h3 id="build_failure_policy_setraw-dictstr-any-derive_seed-callablestr-optionalint-failurepolicyset">build_failure_policy_set(raw: 'Dict[str, Any]', *, derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'FailurePolicySet'<a class="headerlink" href="#build_failure_policy_setraw-dictstr-any-derive_seed-callablestr-optionalint-failurepolicyset" title="Permanent link">&para;</a></h3>
<p>Build a FailurePolicySet from raw config data.</p>
<p>Args:
    raw: Mapping of policy name -&gt; policy definition dict.
    derive_seed: Callable to derive deterministic seeds from component names.</p>
<p>Returns:
    Configured FailurePolicySet.</p>
<p>Raises:
    ValueError: If raw is not a dict or contains invalid policy definitions.</p>
<h3 id="build_risk_groupsrg_data-listany-tuplelistriskgroup-listdictstr-any">build_risk_groups(rg_data: 'List[Any]') -&gt; 'tuple[List[RiskGroup], List[Dict[str, Any]]]'<a class="headerlink" href="#build_risk_groupsrg_data-listany-tuplelistriskgroup-listdictstr-any" title="Permanent link">&para;</a></h3>
<p>Build RiskGroup objects from raw config data.</p>
<p>Supports:</p>
<ul>
<li>String shorthand: "GroupName" is equivalent to {name: "GroupName"}</li>
<li>Bracket expansion: {name: "DC[1-3]_Power"} creates DC1_Power, DC2_Power, DC3_Power</li>
<li>Children are also expanded recursively</li>
<li>Generate blocks: {generate: {...}} for dynamic group creation</li>
</ul>
<p>Args:
    rg_data: List of risk group definitions (strings or dicts).</p>
<p>Returns:
    Tuple of (explicit_risk_groups, generate_specs_raw):</p>
<ul>
<li>explicit_risk_groups: List of RiskGroup objects with names expanded.</li>
<li>generate_specs_raw: List of raw generate block dicts for deferred processing.</li>
</ul>
<hr />
<h2 id="ngraphmodelfailurepolicy">ngraph.model.failure.policy<a class="headerlink" href="#ngraphmodelfailurepolicy" title="Permanent link">&para;</a></h2>
<p>Failure policy primitives.</p>
<p>Defines <code>FailureRule</code> and <code>FailurePolicy</code> for expressing how nodes, links,
and risk groups fail in analyses. Conditions match on top-level attributes
with simple operators; rules select matches using "all", probabilistic
"random" (with <code>probability</code>), or fixed-size "choice" (with <code>count</code>).
Policies can optionally expand failures by shared risk groups or by
risk-group children.</p>
<h3 id="failuremode">FailureMode<a class="headerlink" href="#failuremode" title="Permanent link">&para;</a></h3>
<p>A weighted mode that encapsulates a set of rules applied together.</p>
<p>Exactly one mode is selected per failure iteration according to the
mode weights. Within a mode, all contained rules are applied and their
selections are unioned into the failure set.</p>
<p>Attributes:
    weight: Non-negative weight used for mode selection. All weights are
        normalized internally. Modes with zero weight are never selected.
    rules: A list of <code>FailureRule</code> applied together when this mode is chosen.
    attrs: Optional metadata.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>weight</code> (float)</li>
<li><code>rules</code> (List[FailureRule]) = []</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="failurepolicy">FailurePolicy<a class="headerlink" href="#failurepolicy" title="Permanent link">&para;</a></h3>
<p>A container for failure modes plus optional metadata in <code>attrs</code>.</p>
<p>The main entry point is <code>apply_failures</code>, which:
  1) Build a single RNG for the entire call (from <code>seed</code> or <code>self.seed</code>).
  2) Select a mode based on weights (one RNG draw).
  3) For each rule in the mode, gather relevant entities.
  4) Match based on rule conditions using 'and' or 'or' logic.
  5) Apply the selection strategy (all, random, or choice) drawing
     from the same RNG, ensuring statistical independence across rules.
  6) Collect the union of all failed entities across all rules.
  7) Optionally expand failures by shared-risk groups or sub-risks.</p>
<p>Attributes:
    attrs: Arbitrary metadata about this policy.
    expand_groups: If True, expand failures among entities sharing
        risk groups with failed entities.
    expand_children: If True, expand failed risk groups to include
        their children recursively.
    seed: Default seed for reproducible random operations. Overridden
        by the <code>seed</code> parameter on <code>apply_failures</code> when provided.
    modes: List of weighted failure modes.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>expand_groups</code> (bool) = False</li>
<li><code>expand_children</code> (bool) = False</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>modes</code> (List[FailureMode]) = []</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>apply_failures(self, network_nodes: 'Dict[str, Any]', network_links: 'Dict[str, Any]', network_risk_groups: 'Dict[str, Any] | None' = None, *, seed: 'Optional[int]' = None, failure_trace: 'Optional[Dict[str, Any]]' = None) -&gt; 'List[str]'</code> - Identify which entities fail for this iteration.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<h3 id="failurerule">FailureRule<a class="headerlink" href="#failurerule" title="Permanent link">&para;</a></h3>
<p>Defines how to match and then select entities for failure.</p>
<p>Attributes:
    scope: The type of entities this rule applies to: "node", "link",
        or "risk_group".
    conditions: A list of conditions to filter matching entities.
    logic: "and" (all must be true) or "or" (any must be true, default).
    mode: The selection strategy among the matched set:</p>
<ul>
<li>"random": each matched entity is chosen with probability.</li>
<li>"choice": pick exactly <code>count</code> items (random sample).</li>
<li>
<p>"all": select every matched entity.</p>
<p>probability: Probability in [0,1], used if mode="random".
count: Number of entities to pick if mode="choice".
weight_by: Optional attribute for weighted sampling in choice mode.
path: Optional regex pattern to filter entities by name.</p>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>scope</code> (EntityScope)</li>
<li><code>conditions</code> (List[Condition]) = []</li>
<li><code>logic</code> (Literal['and', 'or']) = or</li>
<li><code>mode</code> (Literal['random', 'choice', 'all']) = all</li>
<li><code>probability</code> (float) = 1.0</li>
<li><code>count</code> (int) = 1</li>
<li><code>weight_by</code> (Optional[str])</li>
<li><code>path</code> (Optional[str])</li>
</ul>
<hr />
<h2 id="ngraphmodelfailurepolicy_set">ngraph.model.failure.policy_set<a class="headerlink" href="#ngraphmodelfailurepolicy_set" title="Permanent link">&para;</a></h2>
<p>Failure policy containers.</p>
<p>Provides <code>FailurePolicySet</code>, a named collection of <code>FailurePolicy</code> objects
used as input to failure analysis workflows. This module contains input
containers, not analysis results.</p>
<h3 id="failurepolicyset">FailurePolicySet<a class="headerlink" href="#failurepolicyset" title="Permanent link">&para;</a></h3>
<p>Named collection of FailurePolicy objects.</p>
<p>This mutable container maps failure policy names to FailurePolicy objects,
allowing management of multiple failure policies for analysis.</p>
<p>Attributes:
    policies: Dictionary mapping failure policy names to FailurePolicy objects.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>policies</code> (dict[str, FailurePolicy]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add(self, name: 'str', policy: 'FailurePolicy') -&gt; 'None'</code> - Add a failure policy to the collection.</li>
<li><code>get_all_policies(self) -&gt; 'list[FailurePolicy]'</code> - Get all failure policies from the collection.</li>
<li><code>get_policy(self, name: 'str') -&gt; 'FailurePolicy'</code> - Get a specific failure policy by name.</li>
<li><code>to_dict(self) -&gt; 'dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphmodelfailurevalidation">ngraph.model.failure.validation<a class="headerlink" href="#ngraphmodelfailurevalidation" title="Permanent link">&para;</a></h2>
<p>Risk group reference validation.</p>
<p>Validates that all risk group references in nodes and links resolve to
defined risk groups. Catches typos and missing definitions early.</p>
<p>Also provides cycle detection for risk group hierarchies.</p>
<h3 id="validate_risk_group_hierarchynetwork-network-none">validate_risk_group_hierarchy(network: "'Network'") -&gt; 'None'<a class="headerlink" href="#validate_risk_group_hierarchynetwork-network-none" title="Permanent link">&para;</a></h3>
<p>Detect circular references in risk group parent-child relationships.</p>
<p>Uses DFS-based cycle detection to find any risk group that is part of
a cycle in the children hierarchy. This can happen when membership rules
with scope='risk_group' create mutual parent-child relationships.</p>
<p>Args:
    network: Network with risk_groups populated (after membership resolution).</p>
<p>Raises:
    ValueError: If a cycle is detected, with details about the cycle path.</p>
<h3 id="validate_risk_group_referencesnetwork-network-none">validate_risk_group_references(network: "'Network'") -&gt; 'None'<a class="headerlink" href="#validate_risk_group_referencesnetwork-network-none" title="Permanent link">&para;</a></h3>
<p>Ensure all risk group references resolve to defined groups.</p>
<p>Checks that every risk group name referenced by nodes and links
exists in network.risk_groups. This catches typos and missing
definitions that would otherwise cause silent failures in simulations.</p>
<p>Args:
    network: Network with nodes, links, and risk_groups populated.</p>
<p>Raises:
    ValueError: If any node or link references an undefined risk group.
        The error message lists up to 10 violations with entity names
        and the undefined group names.</p>
<hr />
<h2 id="ngraphmodelflowpolicy_config">ngraph.model.flow.policy_config<a class="headerlink" href="#ngraphmodelflowpolicy_config" title="Permanent link">&para;</a></h2>
<p>Flow policy preset configurations for NetGraph.</p>
<p>Provides convenient factory functions to create common FlowPolicy configurations
using NetGraph-Core's FlowPolicy and FlowPolicyConfig.</p>
<h3 id="flowpolicypreset">FlowPolicyPreset<a class="headerlink" href="#flowpolicypreset" title="Permanent link">&para;</a></h3>
<p>Enumerates common flow policy presets for traffic routing.</p>
<p>These presets map to specific combinations of path algorithms, flow placement
strategies, and edge selection modes provided by NetGraph-Core.</p>
<h3 id="create_flow_policyalgorithms-netgraph_corealgorithms-graph-netgraph_coregraph-preset-flowpolicypreset-node_masknone-edge_masknone-netgraph_coreflowpolicy">create_flow_policy(algorithms: 'netgraph_core.Algorithms', graph: 'netgraph_core.Graph', preset: 'FlowPolicyPreset', node_mask=None, edge_mask=None) -&gt; 'netgraph_core.FlowPolicy'<a class="headerlink" href="#create_flow_policyalgorithms-netgraph_corealgorithms-graph-netgraph_coregraph-preset-flowpolicypreset-node_masknone-edge_masknone-netgraph_coreflowpolicy" title="Permanent link">&para;</a></h3>
<p>Create a FlowPolicy instance from a preset configuration.</p>
<p>Args:
    algorithms: NetGraph-Core Algorithms instance.
    graph: NetGraph-Core Graph handle.
    preset: FlowPolicyPreset enum value specifying the desired policy.
    node_mask: Optional numpy bool array for node exclusions (True = include).
    edge_mask: Optional numpy bool array for edge exclusions (True = include).</p>
<p>Returns:
    netgraph_core.FlowPolicy: Configured policy instance.</p>
<p>Raises:
    ValueError: If an unknown FlowPolicyPreset value is provided.</p>
<p>Example:
    &gt;&gt;&gt; backend = netgraph_core.Backend.cpu()
    &gt;&gt;&gt; algs = netgraph_core.Algorithms(backend)
    &gt;&gt;&gt; graph = algs.build_graph(strict_multidigraph)
    &gt;&gt;&gt; policy = create_flow_policy(algs, graph, FlowPolicyPreset.SHORTEST_PATHS_ECMP)</p>
<h3 id="serialize_policy_presetcfg-any-optionalstr">serialize_policy_preset(cfg: 'Any') -&gt; 'Optional[str]'<a class="headerlink" href="#serialize_policy_presetcfg-any-optionalstr" title="Permanent link">&para;</a></h3>
<p>Serialize a FlowPolicyPreset to its string name for JSON storage.</p>
<p>Handles FlowPolicyPreset enum values, integer enum values, and string inputs.
Returns None for None input.</p>
<p>Args:
    cfg: FlowPolicyPreset enum, integer, or other value to serialize.</p>
<p>Returns:
    String name of the preset (e.g., "SHORTEST_PATHS_ECMP"), or None if input is None.</p>
<hr />
<h2 id="ngraphmodelnetwork">ngraph.model.network<a class="headerlink" href="#ngraphmodelnetwork" title="Permanent link">&para;</a></h2>
<p>Network topology modeling with Node, Link, RiskGroup, and Network classes.</p>
<p>This module provides the core network model classes (Node, Link, RiskGroup, Network)
that can be used independently.</p>
<h3 id="link">Link<a class="headerlink" href="#link" title="Permanent link">&para;</a></h3>
<p>Represents one directed link between two nodes.</p>
<p>The model stores a single direction (<code>source</code> -&gt; <code>target</code>). When building
the working graph for analysis, a reverse edge is added by default to provide
bidirectional connectivity. Disable with <code>add_reverse=False</code> in
<code>Network.to_strict_multidigraph</code>.</p>
<p>Attributes:
    source (str): Name of the source node.
    target (str): Name of the target node.
    capacity (float): Link capacity (default 1.0).
    cost (float): Link cost (default 1.0).
    disabled (bool): Whether the link is disabled.
    risk_groups (Set[str]): Set of risk group names this link belongs to.
    attrs (Dict[str, Any]): Additional metadata (e.g., distance).
    id (str): Auto-generated unique identifier: "{source}|{target}|<base64_uuid>".</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>target</code> (str)</li>
<li><code>capacity</code> (float) = 1.0</li>
<li><code>cost</code> (float) = 1.0</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>risk_groups</code> (Set[str]) = set()</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>id</code> (str)</li>
</ul>
<h3 id="network">Network<a class="headerlink" href="#network" title="Permanent link">&para;</a></h3>
<p>A container for network nodes and links.</p>
<p>Network represents the scenario-level topology with persistent state (nodes/links
that are disabled in the scenario configuration). For temporary exclusion of
nodes/links during analysis (e.g., failure simulation), use node_mask and edge_mask
parameters when calling NetGraph-Core algorithms.</p>
<p>Attributes:
    nodes (Dict[str, Node]): Mapping from node name -&gt; Node object.
    links (Dict[str, Link]): Mapping from link ID -&gt; Link object.
    risk_groups (Dict[str, RiskGroup]): Top-level risk groups by name.
    attrs (Dict[str, Any]): Optional metadata about the network.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>nodes</code> (Dict[str, Node]) = {}</li>
<li><code>links</code> (Dict[str, Link]) = {}</li>
<li><code>risk_groups</code> (Dict[str, RiskGroup]) = {}</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>_selection_cache</code> (Dict[str, Dict[str, List[Node]]]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>add_link(self, link: 'Link') -&gt; 'None'</code> - Add a link to the network (keyed by the link's auto-generated ID).</li>
<li><code>add_node(self, node: 'Node') -&gt; 'None'</code> - Add a node to the network (keyed by node.name).</li>
<li><code>disable_all(self) -&gt; 'None'</code> - Mark all nodes and links as disabled.</li>
<li><code>disable_link(self, link_id: 'str') -&gt; 'None'</code> - Mark a link as disabled.</li>
<li><code>disable_node(self, node_name: 'str') -&gt; 'None'</code> - Mark a node as disabled.</li>
<li><code>disable_risk_group(self, name: 'str', recursive: 'bool' = True) -&gt; 'None'</code> - Disable all nodes/links that have 'name' in their risk_groups.</li>
<li><code>enable_all(self) -&gt; 'None'</code> - Mark all nodes and links as enabled.</li>
<li><code>enable_link(self, link_id: 'str') -&gt; 'None'</code> - Mark a link as enabled.</li>
<li><code>enable_node(self, node_name: 'str') -&gt; 'None'</code> - Mark a node as enabled.</li>
<li><code>enable_risk_group(self, name: 'str', recursive: 'bool' = True) -&gt; 'None'</code> - Enable all nodes/links that have 'name' in their risk_groups.</li>
<li><code>find_links(self, source_regex: 'Optional[str]' = None, target_regex: 'Optional[str]' = None, any_direction: 'bool' = False) -&gt; 'List[Link]'</code> - Search for links using optional regex patterns for source or target node names.</li>
<li><code>get_links_between(self, source: 'str', target: 'str') -&gt; 'List[str]'</code> - Retrieve all link IDs that connect the specified source node</li>
<li><code>select_node_groups_by_path(self, path: 'str') -&gt; 'Dict[str, List[Node]]'</code> - Select and group nodes by regex pattern on node name.</li>
</ul>
<h3 id="node">Node<a class="headerlink" href="#node" title="Permanent link">&para;</a></h3>
<p>Represents a node in the network.</p>
<p>Each node is uniquely identified by its name, which is used as
the key in the Network's node dictionary.</p>
<p>Attributes:
    name (str): Unique identifier for the node.
    disabled (bool): Whether the node is disabled in the scenario configuration.
    risk_groups (Set[str]): Set of risk group names this node belongs to.
    attrs (Dict[str, Any]): Additional metadata (e.g., coordinates, region).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>risk_groups</code> (Set[str]) = set()</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="riskgroup">RiskGroup<a class="headerlink" href="#riskgroup" title="Permanent link">&para;</a></h3>
<p>Represents a shared-risk or failure domain, which may have nested children.</p>
<p>Risk groups model correlated failures: when a risk group fails, all entities
(nodes, links) in that group fail together. Hierarchical children enable
cascading failures (parent failure implies all descendants fail).</p>
<p>Risk groups can be created three ways:</p>
<ol>
<li>Direct definition: Explicitly named in YAML risk_groups section</li>
<li>Membership rules: Auto-assign entities based on attribute matching</li>
<li>Generate blocks: Auto-create groups from unique attribute values</li>
</ol>
<p>Attributes:
    name (str): Unique name of this risk group.
    children (List[RiskGroup]): Subdomains in a nested structure.
    disabled (bool): Whether this group was declared disabled on load.
    attrs (Dict[str, Any]): Additional metadata for the risk group.
    _membership_raw (Optional[Dict[str, Any]]): Raw membership rule for
        deferred resolution. Internal use only.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>children</code> (List[RiskGroup]) = []</li>
<li><code>disabled</code> (bool) = False</li>
<li><code>attrs</code> (Dict[str, Any]) = {}</li>
<li><code>_membership_raw</code> (Optional[Dict[str, Any]])</li>
</ul>
<hr />
<h2 id="ngraphmodelpath">ngraph.model.path<a class="headerlink" href="#ngraphmodelpath" title="Permanent link">&para;</a></h2>
<p>Lightweight representation of a single routing path.</p>
<p>The <code>Path</code> dataclass stores a node-and-parallel-edges sequence and a numeric
cost. Cached properties expose derived sequences for nodes and edges, and
helpers provide equality, ordering by cost, and sub-path extraction with cost
recalculation.</p>
<h3 id="path">Path<a class="headerlink" href="#path" title="Permanent link">&para;</a></h3>
<p>Represents a single path in the network.</p>
<p>Attributes:
    path: Sequence of (node_name, (edge_refs...)) tuples representing the path.
          The final element typically has an empty tuple of edge refs.
    cost: Total numeric cost (e.g., distance or metric) of the path.
    edges: Set of all EdgeRefs encountered in the path.
    nodes: Set of all node names encountered in the path.
    edge_tuples: Set of all tuples of parallel EdgeRefs from each path element.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>path</code> (Tuple[Tuple[str, Tuple[EdgeRef, ...]], ...])</li>
<li><code>cost</code> (Cost)</li>
<li><code>edges</code> (Set[EdgeRef]) = set()</li>
<li><code>nodes</code> (Set[str]) = set()</li>
<li><code>edge_tuples</code> (Set[Tuple[EdgeRef, ...]]) = set()</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>get_sub_path(self, dst_node: 'str') -&gt; 'Path'</code> - Create a sub-path ending at the specified destination node.</li>
</ul>
<hr />
<h2 id="ngraphworkflowbase">ngraph.workflow.base<a class="headerlink" href="#ngraphworkflowbase" title="Permanent link">&para;</a></h2>
<p>Base classes for workflow automation.</p>
<p>Defines the workflow step abstraction, registration decorator, and execution
lifecycle. Steps implement <code>run()</code> and are executed via <code>execute()</code> which
handles timing, logging, and metadata recording. Failures are logged and
re-raised.</p>
<h3 id="workflowstep">WorkflowStep<a class="headerlink" href="#workflowstep" title="Permanent link">&para;</a></h3>
<p>Base class for all workflow steps.</p>
<p>All workflow steps are automatically logged with execution timing information.
All workflow steps support seeding for reproducible random operations.
Workflow metadata is automatically stored in scenario.results for analysis.</p>
<p>YAML Configuration:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;StepTypeName&gt;</span>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;optional_step_name&quot;</span><span class="w">  </span><span class="c1"># Optional: Custom name for this step instance</span>
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a><span class="w">    </span><span class="nt">seed</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">42</span><span class="w">                    </span><span class="c1"># Optional: Seed for reproducible random operations</span>
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span class="w">    </span><span class="c1"># ... step-specific parameters ...</span>
</span></code></pre></div></p>
<p>Attributes:
    name: Optional custom identifier for this workflow step instance,
        used for logging and result storage purposes.
    seed: Optional seed for reproducible random operations. If None,
        random operations will be non-deterministic.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<h3 id="register_workflow_stepstep_type-str">register_workflow_step(step_type: 'str')<a class="headerlink" href="#register_workflow_stepstep_type-str" title="Permanent link">&para;</a></h3>
<p>Return a decorator that registers a <code>WorkflowStep</code> subclass.</p>
<p>Args:
    step_type: Registry key used to instantiate steps from configuration.</p>
<p>Returns:
    A class decorator that adds the class to <code>WORKFLOW_STEP_REGISTRY</code>.</p>
<h3 id="resolve_parallelismparallelism-unionint-str-int">resolve_parallelism(parallelism: 'Union[int, str]') -&gt; 'int'<a class="headerlink" href="#resolve_parallelismparallelism-unionint-str-int" title="Permanent link">&para;</a></h3>
<p>Resolve parallelism setting to a concrete worker count.</p>
<p>Args:
    parallelism: Either an integer worker count or "auto" for CPU count.</p>
<p>Returns:
    Positive integer worker count (minimum 1).</p>
<hr />
<h2 id="ngraphworkflowbuild_graph">ngraph.workflow.build_graph<a class="headerlink" href="#ngraphworkflowbuild_graph" title="Permanent link">&para;</a></h2>
<p>Graph building workflow component.</p>
<p>Validates and exports network topology as a node-link representation using NetworkX.
Actual graph building for analysis happens in analysis functions; this step
primarily validates the network and stores a serializable representation for
inspection.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">BuildGraph</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;build_network_graph&quot;</span><span class="w">  </span><span class="c1"># Optional: Custom name for this step</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">    </span><span class="nt">add_reverse</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w">  </span><span class="c1"># Optional: Add reverse edges (default: true)</span>
</span></code></pre></div></p>
<p>The <code>add_reverse</code> parameter controls whether reverse edges are added for each link.
When <code>True</code> (default), each Link(AB) gets both forward(AB) and reverse(BA) edges
for bidirectional connectivity. Set to <code>False</code> for directed-only graphs.</p>
<p>Results stored in <code>scenario.results</code> under the step name as two keys:</p>
<ul>
<li>metadata: Step-level execution metadata (node/link counts)</li>
<li>data: { graph: node-link JSON dict, context: { add_reverse: bool } }</li>
</ul>
<h3 id="buildgraph">BuildGraph<a class="headerlink" href="#buildgraph" title="Permanent link">&para;</a></h3>
<p>Validates network topology and stores node-link representation.</p>
<p>This step validates the network structure and stores a JSON-serializable
node-link representation using NetworkX. Core graph building happens in
analysis functions as needed.</p>
<p>Attributes:
    add_reverse: If True, adds reverse edges for bidirectional connectivity.
                 Defaults to True.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>add_reverse</code> (bool) = True</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Scenario') -&gt; 'None'</code> - Validate network and store node-link representation.</li>
</ul>
<hr />
<h2 id="ngraphworkflowcost_power">ngraph.workflow.cost_power<a class="headerlink" href="#ngraphworkflowcost_power" title="Permanent link">&para;</a></h2>
<p>CostPower workflow step: collect capex and power by hierarchy level.</p>
<p>This step aggregates capex and power from the network hardware inventory without
performing any normalization or reporting. It separates contributions into two
categories:</p>
<ul>
<li>platform_*: node hardware (e.g., chassis, linecards) resolved from node attrs</li>
<li>optics_*: per-end link hardware (e.g., optics) resolved from link attrs</li>
</ul>
<p>Aggregation is computed at hierarchy levels 0..N where level 0 is the global
root (path ""), and higher levels correspond to prefixes of node names split by
"/". For example, for node "dc1/plane1/leaf/leaf-1":</p>
<ul>
<li>level 1 path is "dc1"</li>
<li>level 2 path is "dc1/plane1"</li>
<li>etc.</li>
</ul>
<p>Disabled handling:</p>
<ul>
<li>When include_disabled is False, only enabled nodes and links are considered.</li>
<li>Optics are counted only when the endpoint node has platform hardware.</li>
</ul>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">CostPower</span>
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;cost_power&quot;</span><span class="w">           </span><span class="c1"># Optional custom name</span>
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="w">    </span><span class="nt">include_disabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span><span class="w">       </span><span class="c1"># Default: only enabled nodes/links</span>
</span><span id="__span-2-6"><a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a><span class="w">    </span><span class="nt">aggregation_level</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span><span class="w">          </span><span class="c1"># Produce levels: 0, 1, 2</span>
</span></code></pre></div></p>
<p>Results stored in <code>scenario.results</code> under this step namespace:
    data:
      context:
        include_disabled: bool
        aggregation_level: int
      levels:
        "0":</p>
<ul>
<li>path: ""<div class="language-text highlight"><pre><span></span><code>    platform_capex: float
    platform_power_watts: float
    optics_capex: float
    optics_power_watts: float
    capex_total: float
    power_total_watts: float
&quot;1&quot;: [ ... ]
&quot;2&quot;: [ ... ]
</code></pre></div>
</li>
</ul>
<h3 id="costpower">CostPower<a class="headerlink" href="#costpower" title="Permanent link">&para;</a></h3>
<p>Collect platform and optics capex/power by aggregation level.</p>
<p>Attributes:
    include_disabled: If True, include disabled nodes and links.
    aggregation_level: Inclusive depth for aggregation. 0=root only.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>include_disabled</code> (bool) = False</li>
<li><code>aggregation_level</code> (int) = 2</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Any') -&gt; 'None'</code> - Aggregate capex and power by hierarchy levels 0..N.</li>
</ul>
<hr />
<h2 id="ngraphworkflowmax_flow_step">ngraph.workflow.max_flow_step<a class="headerlink" href="#ngraphworkflowmax_flow_step" title="Permanent link">&para;</a></h2>
<p>MaxFlow workflow step.</p>
<p>Monte Carlo analysis of maximum flow capacity between node groups using FailureManager.
Produces unified <code>flow_results</code> per iteration under <code>data.flow_results</code>.</p>
<p>Baseline (no failures) is always run first as a separate reference. The <code>iterations</code>
parameter specifies how many failure scenarios to run.</p>
<p>YAML Configuration Example:</p>
<div class="language-text highlight"><pre><span></span><code>workflow:
</code></pre></div>
<ul>
<li>type: MaxFlow<div class="language-text highlight"><pre><span></span><code>name: &quot;maxflow_dc_to_edge&quot;
source: &quot;^datacenter/.*&quot;
target: &quot;^edge/.*&quot;
mode: &quot;combine&quot;
failure_policy: &quot;random_failures&quot;
iterations: 100
parallelism: auto
shortest_path: false
require_capacity: true           # false for true IP/IGP semantics
flow_placement: &quot;PROPORTIONAL&quot;
seed: 42
store_failure_patterns: false
include_flow_details: false      # cost_distribution
include_min_cut: false           # min-cut edges list
</code></pre></div>
</li>
</ul>
<h3 id="maxflow">MaxFlow<a class="headerlink" href="#maxflow" title="Permanent link">&para;</a></h3>
<p>Maximum flow Monte Carlo workflow step.</p>
<p>Baseline (no failures) is always run first as a separate reference. Results are
returned with baseline in a separate field. The flow_results list contains unique
failure patterns (deduplicated); each result has occurrence_count indicating how
many iterations matched that pattern.</p>
<p>Attributes:
    source: Source node selector (string path or selector dict).
    target: Target node selector (string path or selector dict).
    mode: Flow analysis mode ("combine" or "pairwise").
    failure_policy: Name of failure policy in scenario.failure_policy_set.
    iterations: Number of failure iterations to run.
    parallelism: Number of parallel worker processes.
    shortest_path: Whether to use shortest paths only.
    require_capacity: If True (default), path selection considers capacity.
        If False, path selection is cost-only (true IP/IGP semantics).
    flow_placement: Flow placement strategy.
    seed: Optional seed for reproducible results.
    store_failure_patterns: Whether to store failure patterns in results.
    include_flow_details: Whether to collect cost distribution per flow.
    include_min_cut: Whether to include min-cut edges per flow.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (int | None)</li>
<li><code>_seed_source</code> (str)</li>
<li><code>source</code> (Union[str, Dict[str, Any]])</li>
<li><code>target</code> (Union[str, Dict[str, Any]])</li>
<li><code>mode</code> (str) = combine</li>
<li><code>failure_policy</code> (str | None)</li>
<li><code>iterations</code> (int) = 1</li>
<li><code>parallelism</code> (int | str) = auto</li>
<li><code>shortest_path</code> (bool) = False</li>
<li><code>require_capacity</code> (bool) = True</li>
<li><code>flow_placement</code> (FlowPlacement | str) = 1</li>
<li><code>store_failure_patterns</code> (bool) = False</li>
<li><code>include_flow_details</code> (bool) = False</li>
<li><code>include_min_cut</code> (bool) = False</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphworkflowmaximum_supported_demand_step">ngraph.workflow.maximum_supported_demand_step<a class="headerlink" href="#ngraphworkflowmaximum_supported_demand_step" title="Permanent link">&para;</a></h2>
<p>MaximumSupportedDemand workflow step.</p>
<p>Searches for the maximum uniform traffic multiplier <code>alpha_star</code> that is fully
placeable for a given demand set. Stores results under <code>data</code> as:</p>
<ul>
<li><code>alpha_star</code>: float</li>
<li><code>context</code>: parameters used for the search</li>
<li><code>base_demands</code>: serialized base demand specs</li>
<li><code>probes</code>: bracket/bisect evaluations with feasibility</li>
</ul>
<p>Performance: AnalysisContext is built once at search start and reused across
all binary search probes. Only demand volumes change per probe.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">MaximumSupportedDemand</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;msd_search&quot;</span>
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="w">    </span><span class="nt">demand_set</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;default&quot;</span>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="w">    </span><span class="nt">resolution</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0.01</span><span class="w">        </span><span class="c1"># Convergence threshold</span>
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="w">    </span><span class="nt">max_bisect_iters</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">50</span><span class="w">    </span><span class="c1"># Maximum bisection iterations</span>
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a><span class="w">    </span><span class="nt">alpha_start</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1.0</span><span class="w">        </span><span class="c1"># Starting multiplier</span>
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a><span class="w">    </span><span class="nt">growth_factor</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2.0</span><span class="w">      </span><span class="c1"># Bracket expansion factor</span>
</span></code></pre></div></p>
<h3 id="maximumsupporteddemand">MaximumSupportedDemand<a class="headerlink" href="#maximumsupporteddemand" title="Permanent link">&para;</a></h3>
<p>Finds the maximum uniform traffic multiplier that is fully placeable.</p>
<p>Uses binary search to find alpha_star, the maximum multiplier for all
demands in the set that can still be fully placed on the network.</p>
<p>Attributes:
    demand_set: Name of the demand set to analyze.
    acceptance_rule: Currently only "hard" is implemented.
    alpha_start: Starting multiplier for binary search.
    growth_factor: Factor for bracket expansion.
    alpha_min: Minimum allowed alpha value.
    alpha_max: Maximum allowed alpha value.
    resolution: Convergence threshold for binary search.
    max_bracket_iters: Maximum iterations for bracketing phase.
    max_bisect_iters: Maximum iterations for bisection phase.
    placement_rounds: Placement optimization rounds.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>demand_set</code> (str) = default</li>
<li><code>acceptance_rule</code> (str) = hard</li>
<li><code>alpha_start</code> (float) = 1.0</li>
<li><code>growth_factor</code> (float) = 2.0</li>
<li><code>alpha_min</code> (float) = 1e-06</li>
<li><code>alpha_max</code> (float) = 1000000000.0</li>
<li><code>resolution</code> (float) = 0.01</li>
<li><code>max_bracket_iters</code> (int) = 32</li>
<li><code>max_bisect_iters</code> (int) = 32</li>
<li><code>placement_rounds</code> (int | str) = auto</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Any'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphworkflownetwork_stats">ngraph.workflow.network_stats<a class="headerlink" href="#ngraphworkflownetwork_stats" title="Permanent link">&para;</a></h2>
<p>Workflow step for basic node and link statistics.</p>
<p>Computes and stores network statistics including node/link counts,
capacity distributions, cost distributions, and degree distributions. Supports
optional exclusion simulation and disabled entity handling.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">NetworkStats</span>
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;network_statistics&quot;</span><span class="w">           </span><span class="c1"># Optional: Custom name for this step</span>
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="w">    </span><span class="nt">include_disabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span><span class="w">              </span><span class="c1"># Include disabled nodes/links in stats</span>
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="w">    </span><span class="nt">excluded_nodes</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;node1&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;node2&quot;</span><span class="p p-Indicator">]</span><span class="w">   </span><span class="c1"># Optional: Temporary node exclusions</span>
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="w">    </span><span class="nt">excluded_links</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;link1&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;link3&quot;</span><span class="p p-Indicator">]</span><span class="w">   </span><span class="c1"># Optional: Temporary link exclusions</span>
</span></code></pre></div></p>
<p>Results stored in <code>scenario.results</code>:</p>
<ul>
<li>Node statistics: node_count</li>
<li>
<p>Link statistics: link_count, total_capacity, mean_capacity, median_capacity,</p>
<p>min_capacity, max_capacity, mean_cost, median_cost, min_cost, max_cost</p>
</li>
<li>
<p>Degree statistics: mean_degree, median_degree, min_degree, max_degree</p>
</li>
</ul>
<h3 id="networkstats">NetworkStats<a class="headerlink" href="#networkstats" title="Permanent link">&para;</a></h3>
<p>Compute basic node and link statistics for the network.</p>
<p>Supports optional exclusion simulation without modifying the base network.</p>
<p>Attributes:
    include_disabled: If True, include disabled nodes and links in statistics.
        If False, only consider enabled entities.
    excluded_nodes: Optional list of node names to exclude (temporary exclusion).
    excluded_links: Optional list of link IDs to exclude (temporary exclusion).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (Optional[int])</li>
<li><code>_seed_source</code> (str)</li>
<li><code>include_disabled</code> (bool) = False</li>
<li><code>excluded_nodes</code> (Iterable[str]) = ()</li>
<li><code>excluded_links</code> (Iterable[str]) = ()</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: 'Scenario') -&gt; 'None'</code> - Compute and store network statistics.</li>
</ul>
<hr />
<h2 id="ngraphworkflowparse">ngraph.workflow.parse<a class="headerlink" href="#ngraphworkflowparse" title="Permanent link">&para;</a></h2>
<p>Workflow parsing helpers.</p>
<p>Converts a normalized workflow section (list[dict]) into WorkflowStep
instances using the WORKFLOW_STEP_REGISTRY and attaches unique names/seeds.</p>
<h3 id="build_workflow_stepsworkflow_data-listdictstr-any-derive_seed-callablestr-optionalint-listworkflowstep">build_workflow_steps(workflow_data: 'List[Dict[str, Any]]', derive_seed: 'Callable[[str], Optional[int]]') -&gt; 'List[WorkflowStep]'<a class="headerlink" href="#build_workflow_stepsworkflow_data-listdictstr-any-derive_seed-callablestr-optionalint-listworkflowstep" title="Permanent link">&para;</a></h3>
<p>Instantiate workflow steps from normalized dictionaries.</p>
<p>Args:
    workflow_data: List of step dicts; each must have "type".
    derive_seed: Callable that takes a step name and returns a seed or None.</p>
<p>Returns:
    A list of WorkflowStep instances with unique names and optional seeds.</p>
<hr />
<h2 id="ngraphworkflowtraffic_matrix_placement_step">ngraph.workflow.traffic_matrix_placement_step<a class="headerlink" href="#ngraphworkflowtraffic_matrix_placement_step" title="Permanent link">&para;</a></h2>
<p>TrafficMatrixPlacement workflow step.</p>
<p>Runs Monte Carlo demand placement using a named demand set and produces
unified <code>flow_results</code> per iteration under <code>data.flow_results</code>.</p>
<p>Baseline (no failures) is always run first as a separate reference. The <code>iterations</code>
parameter specifies how many failure scenarios to run.</p>
<p>YAML Configuration Example:
    <div class="language-yaml highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="nt">workflow</span><span class="p">:</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">TrafficMatrixPlacement</span>
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;tm_analysis&quot;</span>
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="w">    </span><span class="nt">demand_set</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;default&quot;</span>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="w">    </span><span class="nt">failure_policy</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;single_link&quot;</span><span class="w">    </span><span class="c1"># Optional: failure policy name</span>
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="w">    </span><span class="nt">iterations</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">100</span><span class="w">                  </span><span class="c1"># Number of failure scenarios</span>
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a><span class="w">    </span><span class="nt">parallelism</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">4</span><span class="w">                   </span><span class="c1"># Worker processes (or &quot;auto&quot;)</span>
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a><span class="w">    </span><span class="nt">alpha</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1.0</span><span class="w">                       </span><span class="c1"># Demand volume multiplier</span>
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a><span class="w">    </span><span class="nt">include_flow_details</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w">       </span><span class="c1"># Include cost distribution per flow</span>
</span></code></pre></div></p>
<h3 id="trafficmatrixplacement">TrafficMatrixPlacement<a class="headerlink" href="#trafficmatrixplacement" title="Permanent link">&para;</a></h3>
<p>Monte Carlo demand placement using a named demand set.</p>
<p>Baseline (no failures) is always run first as a separate reference. Results are
returned with baseline in a separate field. The flow_results list contains unique
failure patterns (deduplicated); each result has occurrence_count indicating how
many iterations matched that pattern.</p>
<p>Attributes:
    demand_set: Name of the demand set to analyze.
    failure_policy: Optional failure policy name in scenario.failure_policy_set.
    iterations: Number of failure iterations to run.
    parallelism: Number of parallel worker processes.
    placement_rounds: Placement optimization rounds (int or "auto").
    seed: Optional seed for reproducibility.
    store_failure_patterns: Whether to store failure pattern results.
    include_flow_details: When True, include cost_distribution per flow.
    include_used_edges: When True, include set of used edges per demand in entry data.
    alpha: Numeric scale for demands in the set.
    alpha_from_step: Optional producer step name to read alpha from.
    alpha_from_field: Dotted field path in producer step (default: "data.alpha_star").</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>seed</code> (int | None)</li>
<li><code>_seed_source</code> (str)</li>
<li><code>demand_set</code> (str)</li>
<li><code>failure_policy</code> (str | None)</li>
<li><code>iterations</code> (int) = 1</li>
<li><code>parallelism</code> (int | str) = auto</li>
<li><code>placement_rounds</code> (int | str) = auto</li>
<li><code>store_failure_patterns</code> (bool) = False</li>
<li><code>include_flow_details</code> (bool) = False</li>
<li><code>include_used_edges</code> (bool) = False</li>
<li><code>alpha</code> (float) = 1.0</li>
<li><code>alpha_from_step</code> (str | None)</li>
<li><code>alpha_from_field</code> (str) = data.alpha_star</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>execute(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step with logging and metadata storage.</li>
<li><code>run(self, scenario: "'Scenario'") -&gt; 'None'</code> - Execute the workflow step logic.</li>
</ul>
<hr />
<h2 id="ngraphdslblueprintsexpand">ngraph.dsl.blueprints.expand<a class="headerlink" href="#ngraphdslblueprintsexpand" title="Permanent link">&para;</a></h2>
<p>Network topology blueprints and generation.</p>
<h3 id="blueprint">Blueprint<a class="headerlink" href="#blueprint" title="Permanent link">&para;</a></h3>
<p>Represents a reusable blueprint for hierarchical sub-topologies.</p>
<p>A blueprint may contain multiple node definitions (each can have count
and template), plus link definitions describing how those nodes connect.</p>
<p>Attributes:
    name: Unique identifier of this blueprint.
    nodes: A mapping of node_name -&gt; node definition.
    links: A list of link definitions.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>name</code> (str)</li>
<li><code>nodes</code> (Dict[str, Any])</li>
<li><code>links</code> (List[Dict[str, Any]])</li>
</ul>
<h3 id="dslexpansioncontext">DSLExpansionContext<a class="headerlink" href="#dslexpansioncontext" title="Permanent link">&para;</a></h3>
<p>Carries the blueprint definitions and the final Network instance
to be populated during DSL expansion.</p>
<p>Attributes:
    blueprints: Dictionary of blueprint-name -&gt; Blueprint.
    network: The Network into which expanded nodes/links are inserted.
    pending_bp_links: Deferred blueprint link expansions.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>blueprints</code> (Dict[str, Blueprint])</li>
<li><code>network</code> (Network)</li>
<li><code>pending_bp_links</code> (List[tuple[Dict[str, Any], str]]) = []</li>
</ul>
<h3 id="expand_network_dsldata-dictstr-any-network">expand_network_dsl(data: 'Dict[str, Any]') -&gt; 'Network'<a class="headerlink" href="#expand_network_dsldata-dictstr-any-network" title="Permanent link">&para;</a></h3>
<p>Expands a combined blueprint + network DSL into a complete Network object.</p>
<p>Overall flow:
  1) Parse "blueprints" into Blueprint objects.
  2) Build a Network from "network" metadata (e.g. name, version).
  3) Expand 'network["nodes"]' (collect blueprint links for later).</p>
<ul>
<li>
<p>If a node group references a blueprint, incorporate that blueprint's</p>
<p>nodes while merging parent's attrs + disabled + risk_groups.
   Blueprint links are deferred and processed after node rules.</p>
</li>
<li>
<p>Otherwise, directly create nodes (a "direct node group").</p>
</li>
</ul>
<p>4) Process node rules (in order if multiple rules match).
  5) Expand deferred blueprint links.
  6) Expand link definitions in 'network["links"]'.
  7) Process link rules (in order if multiple rules match).</p>
<p>Field validation rules:</p>
<ul>
<li>Only certain top-level fields are permitted in each structure.</li>
<li>Link properties are flat (capacity, cost, etc. at link level).</li>
<li>
<p>For node definitions: count, template, attrs, disabled, risk_groups,</p>
<p>or blueprint for blueprint-based nodes.</p>
</li>
</ul>
<p>Args:
    data: The YAML-parsed dictionary containing optional "blueprints" + "network".</p>
<p>Returns:
    The expanded Network object with all nodes and links.</p>
<hr />
<h2 id="ngraphdslblueprintsparser">ngraph.dsl.blueprints.parser<a class="headerlink" href="#ngraphdslblueprintsparser" title="Permanent link">&para;</a></h2>
<p>Parsing helpers for the network DSL.</p>
<p>This module factors out pure parsing/validation helpers from the expansion
module so they can be tested independently and reused.</p>
<h3 id="check_link_keyslink_def-dictstr-any-context-str-none">check_link_keys(link_def: 'Dict[str, Any]', context: 'str') -&gt; 'None'<a class="headerlink" href="#check_link_keyslink_def-dictstr-any-context-str-none" title="Permanent link">&para;</a></h3>
<p>Ensure link definitions only contain recognized keys.</p>
<h3 id="check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none">check_no_extra_keys(data_dict: 'Dict[str, Any]', allowed: 'set[str]', context: 'str') -&gt; 'None'<a class="headerlink" href="#check_no_extra_keysdata_dict-dictstr-any-allowed-setstr-context-str-none" title="Permanent link">&para;</a></h3>
<p>Raise if <code>data_dict</code> contains keys outside <code>allowed</code>.</p>
<p>Args:
    data_dict: The dict to check.
    allowed: Set of recognized keys.
    context: Short description used in error messages.</p>
<h3 id="join_pathsparent_path-str-rel_path-str-str">join_paths(parent_path: 'str', rel_path: 'str') -&gt; 'str'<a class="headerlink" href="#join_pathsparent_path-str-rel_path-str-str" title="Permanent link">&para;</a></h3>
<p>Join two path segments according to DSL conventions.</p>
<p>The DSL has no concept of absolute paths. All paths are relative to the
current context (parent_path). A leading "/" on rel_path is stripped and
has no functional effect - it serves only as a visual indicator that the
path starts from the current scope's root.</p>
<p>Behavior:</p>
<ul>
<li>Leading "/" on rel_path is stripped (not treated as filesystem root)</li>
<li>Result is always: "{parent_path}/{stripped_rel_path}" if parent_path is non-empty</li>
<li>
<p>Examples:</p>
<p>join_paths("", "/leaf") -&gt; "leaf"
join_paths("pod1", "/leaf") -&gt; "pod1/leaf"
join_paths("pod1", "leaf") -&gt; "pod1/leaf"  (same result)</p>
</li>
</ul>
<p>Args:
    parent_path: Parent path prefix (e.g., "pod1" when expanding a blueprint).
    rel_path: Path to join. Leading "/" is stripped if present.</p>
<p>Returns:
    Combined path string.</p>
<hr />
<h2 id="ngraphdslexpansionbrackets">ngraph.dsl.expansion.brackets<a class="headerlink" href="#ngraphdslexpansionbrackets" title="Permanent link">&para;</a></h2>
<p>Bracket expansion for name patterns.</p>
<p>Provides expand_name_patterns() for expanding bracket expressions
like "fa[1-3]" into ["fa1", "fa2", "fa3"].</p>
<h3 id="expand_name_patternsname-str-liststr">expand_name_patterns(name: 'str') -&gt; 'List[str]'<a class="headerlink" href="#expand_name_patternsname-str-liststr" title="Permanent link">&para;</a></h3>
<p>Expand bracket expressions in a group name.</p>
<p>Supports:</p>
<ul>
<li>Ranges: [1-3] -&gt; 1, 2, 3</li>
<li>Lists: [a,b,c] -&gt; a, b, c</li>
<li>Mixed: [1,3,5-7] -&gt; 1, 3, 5, 6, 7</li>
<li>Multiple brackets: Cartesian product</li>
</ul>
<p>Args:
    name: Name pattern with optional bracket expressions.</p>
<p>Returns:
    List of expanded names.</p>
<p>Examples:
    &gt;&gt;&gt; expand_name_patterns("fa[1-3]")
    ["fa1", "fa2", "fa3"]
    &gt;&gt;&gt; expand_name_patterns("dc[1,3,5-6]")
    ["dc1", "dc3", "dc5", "dc6"]
    &gt;&gt;&gt; expand_name_patterns("fa[1-2]_plane[5-6]")
    ["fa1_plane5", "fa1_plane6", "fa2_plane5", "fa2_plane6"]</p>
<h3 id="expand_risk_group_refsrg_list-iterablestr-setstr">expand_risk_group_refs(rg_list: 'Iterable[str]') -&gt; 'Set[str]'<a class="headerlink" href="#expand_risk_group_refsrg_list-iterablestr-setstr" title="Permanent link">&para;</a></h3>
<p>Expand bracket patterns in a list of risk group references.</p>
<p>Takes an iterable of risk group names (possibly containing bracket
expressions) and returns a set of all expanded names.</p>
<p>Args:
    rg_list: Iterable of risk group name patterns.</p>
<p>Returns:
    Set of expanded risk group names.</p>
<p>Examples:
    &gt;&gt;&gt; expand_risk_group_refs(["RG1"])
    {"RG1"}
    &gt;&gt;&gt; expand_risk_group_refs(["RG[1-3]"])
    {"RG1", "RG2", "RG3"}
    &gt;&gt;&gt; expand_risk_group_refs(["A[1-2]", "B[a,b]"])
    {"A1", "A2", "Ba", "Bb"}</p>
<hr />
<h2 id="ngraphdslexpansionschema">ngraph.dsl.expansion.schema<a class="headerlink" href="#ngraphdslexpansionschema" title="Permanent link">&para;</a></h2>
<p>Schema definitions for variable expansion.</p>
<p>Provides dataclasses for template expansion configuration.</p>
<h3 id="expansionspec">ExpansionSpec<a class="headerlink" href="#expansionspec" title="Permanent link">&para;</a></h3>
<p>Specification for variable-based expansion.</p>
<p>Attributes:
    vars: Mapping of variable names to lists of values.
    mode: How to combine variable values.</p>
<ul>
<li>"cartesian": All combinations (default)</li>
<li>"zip": Pair values by position</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>vars</code> (Dict[str, List[Any]]) = {}</li>
<li><code>mode</code> (Literal['cartesian', 'zip']) = cartesian</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "Optional['ExpansionSpec']"</code> - Extract expand: block from dict.</li>
<li><code>is_empty(self) -&gt; 'bool'</code> - Check if no variables are defined.</li>
</ul>
<hr />
<h2 id="ngraphdslexpansionvariables">ngraph.dsl.expansion.variables<a class="headerlink" href="#ngraphdslexpansionvariables" title="Permanent link">&para;</a></h2>
<p>Variable expansion for templates.</p>
<p>Provides substitution of $var and ${var} placeholders in strings,
with recursive substitution in nested structures.</p>
<h3 id="expand_blockblock-dictstr-any-spec-optionalexpansionspec-iteratordictstr-any">expand_block(block: 'Dict[str, Any]', spec: "Optional['ExpansionSpec']") -&gt; 'Iterator[Dict[str, Any]]'<a class="headerlink" href="#expand_blockblock-dictstr-any-spec-optionalexpansionspec-iteratordictstr-any" title="Permanent link">&para;</a></h3>
<p>Expand a DSL block, yielding one dict per variable combination.</p>
<p>If no expand spec is provided or it has no vars, yields the original block.
Otherwise, yields a deep copy with all strings substituted for each
variable combination.</p>
<p>Args:
    block: DSL block (dict) that may contain template strings.
    spec: Optional expansion specification.</p>
<p>Yields:
    Dict with variable substitutions applied.</p>
<h3 id="expand_templatestemplates-dictstr-str-spec-expansionspec-iteratordictstr-str">expand_templates(templates: 'Dict[str, str]', spec: "'ExpansionSpec'") -&gt; 'Iterator[Dict[str, str]]'<a class="headerlink" href="#expand_templatestemplates-dictstr-str-spec-expansionspec-iteratordictstr-str" title="Permanent link">&para;</a></h3>
<p>Expand template strings with variable substitution.</p>
<p>Uses $var or ${var} syntax only.</p>
<p>Args:
    templates: Dict of template strings.
    spec: Expansion specification with variables and mode.</p>
<p>Yields:
    Dicts with same keys as templates, values substituted.</p>
<p>Raises:
    ValueError: If zip mode has mismatched list lengths or expansion exceeds limit.
    KeyError: If a template references an undefined variable.</p>
<h3 id="substitute_varsobj-any-var_dict-dictstr-any-any">substitute_vars(obj: 'Any', var_dict: 'Dict[str, Any]') -&gt; 'Any'<a class="headerlink" href="#substitute_varsobj-any-var_dict-dictstr-any-any" title="Permanent link">&para;</a></h3>
<p>Recursively substitute ${var} in all strings within obj.</p>
<p>Args:
    obj: Any value (string, dict, list, or primitive).
    var_dict: Mapping of variable names to values.</p>
<p>Returns:
    Object with all string values having variables substituted.</p>
<hr />
<h2 id="ngraphdslloader">ngraph.dsl.loader<a class="headerlink" href="#ngraphdslloader" title="Permanent link">&para;</a></h2>
<p>YAML loader + schema validation for Scenario DSL.</p>
<p>Provides a single entrypoint to parse a YAML string, normalize keys where
needed, validate against the packaged JSON schema, and return a canonical
dictionary suitable for downstream expansion/parsing.</p>
<h3 id="load_scenario_yamlyaml_str-str-dictstr-any">load_scenario_yaml(yaml_str: 'str') -&gt; 'Dict[str, Any]'<a class="headerlink" href="#load_scenario_yamlyaml_str-str-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Load, normalize, and validate a Scenario YAML string.</p>
<p>Returns a canonical dictionary representation that downstream parsers can
consume without worrying about YAML-specific quirks (e.g., boolean-like
keys) and with schema shape already enforced.</p>
<hr />
<h2 id="ngraphdslselectorsconditions">ngraph.dsl.selectors.conditions<a class="headerlink" href="#ngraphdslselectorsconditions" title="Permanent link">&para;</a></h2>
<p>Condition evaluation for node/entity filtering.</p>
<p>Provides evaluation logic for attribute conditions used in selectors
and failure policies. Supports operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=,
contains, not_contains, in, not_in, exists, not_exists.</p>
<p>Supports dot-notation for nested attribute access (e.g., "hardware.vendor").</p>
<h3 id="evaluate_conditionattrs-dictstr-any-cond-condition-bool">evaluate_condition(attrs: 'Dict[str, Any]', cond: "'Condition'") -&gt; 'bool'<a class="headerlink" href="#evaluate_conditionattrs-dictstr-any-cond-condition-bool" title="Permanent link">&para;</a></h3>
<p>Evaluate a single condition against an attribute dict.</p>
<p>Supports dot-notation for nested attribute access (e.g., "hardware.vendor").</p>
<p>Args:
    attrs: Mapping of entity attributes (may contain nested dicts).
    cond: Condition to evaluate.</p>
<p>Returns:
    True if condition passes, False otherwise.</p>
<p>Raises:
    ValueError: If operator is unknown or value type is invalid.</p>
<h3 id="evaluate_conditionsattrs-dictstr-any-conditions-iterablecondition-logic-str-or-bool">evaluate_conditions(attrs: 'Dict[str, Any]', conditions: "Iterable['Condition']", logic: 'str' = 'or') -&gt; 'bool'<a class="headerlink" href="#evaluate_conditionsattrs-dictstr-any-conditions-iterablecondition-logic-str-or-bool" title="Permanent link">&para;</a></h3>
<p>Evaluate multiple conditions with AND/OR logic.</p>
<p>Args:
    attrs: Flat mapping of entity attributes.
    conditions: Iterable of Condition objects.
    logic: "and" (all must match) or "or" (any must match).</p>
<p>Returns:
    True if combined predicate passes.</p>
<p>Raises:
    ValueError: If logic is not "and" or "or".</p>
<h3 id="resolve_attr_pathattrs-dictstr-any-path-str-tuplebool-any">resolve_attr_path(attrs: 'Dict[str, Any]', path: 'str') -&gt; 'Tuple[bool, Any]'<a class="headerlink" href="#resolve_attr_pathattrs-dictstr-any-path-str-tuplebool-any" title="Permanent link">&para;</a></h3>
<p>Resolve a dot-notation attribute path.</p>
<p>Supports nested attribute access like "hardware.vendor" which resolves
to attrs["hardware"]["vendor"].</p>
<p>Args:
    attrs: Attribute dict (may contain nested dicts).
    path: Attribute path, optionally with dots for nesting.</p>
<p>Returns:
    Tuple of (found, value). If found is False, value is None.</p>
<p>Examples:
    &gt;&gt;&gt; resolve_attr_path({"role": "spine"}, "role")
    (True, "spine")
    &gt;&gt;&gt; resolve_attr_path({"hardware": {"vendor": "Acme"}}, "hardware.vendor")
    (True, "Acme")
    &gt;&gt;&gt; resolve_attr_path({"role": "spine"}, "missing")
    (False, None)</p>
<hr />
<h2 id="ngraphdslselectorsnormalize">ngraph.dsl.selectors.normalize<a class="headerlink" href="#ngraphdslselectorsnormalize" title="Permanent link">&para;</a></h2>
<p>Selector parsing and normalization.</p>
<p>Provides the single entry point for converting raw selector values
(strings or dicts) into NodeSelector objects.</p>
<h3 id="normalize_selectorraw-unionstr-dictstr-any-nodeselector-context-str-nodeselector">normalize_selector(raw: 'Union[str, Dict[str, Any], NodeSelector]', context: 'str') -&gt; 'NodeSelector'<a class="headerlink" href="#normalize_selectorraw-unionstr-dictstr-any-nodeselector-context-str-nodeselector" title="Permanent link">&para;</a></h3>
<p>Normalize a raw selector (string or dict) to a NodeSelector.</p>
<p>This is the single entry point for all selector parsing. All downstream
code works with NodeSelector objects only.</p>
<p>Args:
    raw: Either a regex string, selector dict, or existing NodeSelector.
    context: Usage context ("adjacency", "demand", "override", "workflow").
        Determines the default for active_only.</p>
<p>Returns:
    Normalized NodeSelector instance.</p>
<p>Raises:
    ValueError: If selector format is invalid or context is unknown.</p>
<h3 id="parse_match_specraw-dictstr-any-default_logic-literaland-or-or-require_conditions-bool-false-context-str-match-matchspec">parse_match_spec(raw: 'Dict[str, Any]', *, default_logic: "Literal['and', 'or']" = 'or', require_conditions: 'bool' = False, context: 'str' = 'match') -&gt; 'MatchSpec'<a class="headerlink" href="#parse_match_specraw-dictstr-any-default_logic-literaland-or-or-require_conditions-bool-false-context-str-match-matchspec" title="Permanent link">&para;</a></h3>
<p>Parse a match specification from raw dict.</p>
<p>Unified match specification parser for use across adjacency, demands,
membership rules, and failure policies.</p>
<p>Args:
    raw: Dict with 'conditions' list and optional 'logic'.
    default_logic: Default when 'logic' not specified.
    require_conditions: If True, raise when conditions list is empty.
    context: Used in error messages.</p>
<p>Returns:
    Parsed MatchSpec.</p>
<p>Raises:
    ValueError: If validation fails.</p>
<hr />
<h2 id="ngraphdslselectorsschema">ngraph.dsl.selectors.schema<a class="headerlink" href="#ngraphdslselectorsschema" title="Permanent link">&para;</a></h2>
<p>Schema definitions for unified node selection.</p>
<p>Provides dataclasses for node selection configuration used across
network rules, demands, and workflow steps.</p>
<h3 id="condition">Condition<a class="headerlink" href="#condition" title="Permanent link">&para;</a></h3>
<p>A single attribute condition for filtering.</p>
<p>Supports dot-notation for nested attribute access (e.g., "hardware.vendor"
resolves to attrs["hardware"]["vendor"]).</p>
<p>Attributes:
    attr: Attribute name to match (supports dot-notation for nested attrs).
    op: Comparison operator.
    value: Right-hand operand (unused for exists/not_exists).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>attr</code> (str)</li>
<li><code>op</code> (Literal['==', '!=', '&lt;', '&lt;=', '&gt;', '&gt;=', 'contains', 'not_contains', 'in', 'not_in', 'exists', 'not_exists'])</li>
<li><code>value</code> (Any)</li>
</ul>
<h3 id="matchspec">MatchSpec<a class="headerlink" href="#matchspec" title="Permanent link">&para;</a></h3>
<p>Specification for filtering nodes by attribute conditions.</p>
<p>Attributes:
    conditions: List of conditions to evaluate.
    logic: How to combine conditions ("and" = all, "or" = any).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>conditions</code> (List[Condition]) = []</li>
<li><code>logic</code> (Literal['and', 'or']) = or</li>
</ul>
<h3 id="nodeselector">NodeSelector<a class="headerlink" href="#nodeselector" title="Permanent link">&para;</a></h3>
<p>Unified node selection specification.</p>
<p>Evaluation order:</p>
<ol>
<li>Select nodes matching <code>path</code> regex (default ".*" if omitted)</li>
<li>Filter by <code>match</code> conditions</li>
<li>Filter by <code>active_only</code> flag</li>
<li>Group by <code>group_by</code> attribute (if specified)</li>
</ol>
<p>At least one of path, group_by, or match must be specified.</p>
<p>Attributes:
    path: Regex pattern on node.name.
    group_by: Attribute name to group nodes by.
    match: Attribute-based filtering conditions.
    active_only: Whether to exclude disabled nodes. None uses context default.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>path</code> (Optional[str])</li>
<li><code>group_by</code> (Optional[str])</li>
<li><code>match</code> (Optional[MatchSpec])</li>
<li><code>active_only</code> (Optional[bool])</li>
</ul>
<hr />
<h2 id="ngraphdslselectorsselect">ngraph.dsl.selectors.select<a class="headerlink" href="#ngraphdslselectorsselect" title="Permanent link">&para;</a></h2>
<p>Node selection and evaluation.</p>
<p>Provides the unified select_nodes() function that handles regex matching,
attribute filtering, active-only filtering, and grouping.</p>
<h3 id="flatten_link_attrslink-link-link_id-str-dictstr-any">flatten_link_attrs(link: "'Link'", link_id: 'str') -&gt; 'Dict[str, Any]'<a class="headerlink" href="#flatten_link_attrslink-link-link_id-str-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Build flat attribute dict for condition evaluation on links.</p>
<p>Merges link's top-level fields with link.attrs. Top-level fields
take precedence on key conflicts.</p>
<p>Args:
    link: Link object to flatten.
    link_id: The link's ID in the network.</p>
<p>Returns:
    Flat dict suitable for condition evaluation.</p>
<h3 id="flatten_node_attrsnode-node-dictstr-any">flatten_node_attrs(node: "'Node'") -&gt; 'Dict[str, Any]'<a class="headerlink" href="#flatten_node_attrsnode-node-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Build flat attribute dict for condition evaluation.</p>
<p>Merges node's top-level fields (name, disabled, risk_groups) with
node.attrs. Top-level fields take precedence on key conflicts.</p>
<p>Args:
    node: Node object to flatten.</p>
<p>Returns:
    Flat dict suitable for condition evaluation.</p>
<h3 id="flatten_risk_group_attrsrg-unionriskgroup-dictstr-any-dictstr-any">flatten_risk_group_attrs(rg: "Union['RiskGroup', Dict[str, Any]]") -&gt; 'Dict[str, Any]'<a class="headerlink" href="#flatten_risk_group_attrsrg-unionriskgroup-dictstr-any-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Build flat attribute dict for condition evaluation on risk groups.</p>
<p>Merges risk group's top-level fields (name, disabled, children) with
rg.attrs. Top-level fields take precedence on key conflicts.</p>
<p>Supports both RiskGroup objects and dict representations (for flexibility
in failure policy matching).</p>
<p>Args:
    rg: RiskGroup object or dict representation.</p>
<p>Returns:
    Flat dict suitable for condition evaluation.</p>
<h3 id="match_entity_idsentity_attrs-dictstr-dictstr-any-conditions-listcondition-logic-str-or-setstr">match_entity_ids(entity_attrs: 'Dict[str, Dict[str, Any]]', conditions: 'List[Condition]', logic: 'str' = 'or') -&gt; 'Set[str]'<a class="headerlink" href="#match_entity_idsentity_attrs-dictstr-dictstr-any-conditions-listcondition-logic-str-or-setstr" title="Permanent link">&para;</a></h3>
<p>Match entity IDs by attribute conditions.</p>
<p>General primitive for condition-based entity selection. Works with
any entity type as long as attributes are pre-flattened.</p>
<p>Args:
    entity_attrs: Mapping of {entity_id: flattened_attrs_dict}
    conditions: List of conditions to evaluate
    logic: "and" (all must match) or "or" (any must match)</p>
<p>Returns:
    Set of matching entity IDs. Returns all IDs if conditions is empty.</p>
<h3 id="select_nodesnetwork-network-selector-nodeselector-default_active_only-bool-excluded_nodes-optionalsetstr-none-dictstr-listnode">select_nodes(network: "'Network'", selector: 'NodeSelector', default_active_only: 'bool', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; "Dict[str, List['Node']]"<a class="headerlink" href="#select_nodesnetwork-network-selector-nodeselector-default_active_only-bool-excluded_nodes-optionalsetstr-none-dictstr-listnode" title="Permanent link">&para;</a></h3>
<p>Unified entry point for node selection.</p>
<p>Evaluation order:</p>
<ol>
<li>Select nodes matching <code>path</code> regex (or all nodes if path is None)</li>
<li>Filter by <code>match</code> conditions</li>
<li>Filter by <code>active_only</code> flag and excluded_nodes</li>
<li>Group by <code>group_by</code> attribute (overrides regex capture grouping)</li>
</ol>
<p>Args:
    network: The network graph.
    selector: Node selection specification.
    default_active_only: Context-aware default for active_only flag.
        Required parameter to prevent silent bugs.
    excluded_nodes: Additional node names to exclude.</p>
<p>Returns:
    Dict mapping group labels to lists of nodes.</p>
<hr />
<h2 id="ngraphresultsartifacts">ngraph.results.artifacts<a class="headerlink" href="#ngraphresultsartifacts" title="Permanent link">&para;</a></h2>
<p>Serializable result artifacts for analysis workflows.</p>
<p>This module defines dataclasses that capture outputs from analyses and
simulations in a JSON-serializable form:</p>
<ul>
<li><code>CapacityEnvelope</code>: frequency-based capacity distributions and optional</li>
</ul>
<p>aggregated flow statistics</p>
<ul>
<li><code>FailurePatternResult</code>: capacity results for specific failure patterns</li>
</ul>
<h3 id="capacityenvelope">CapacityEnvelope<a class="headerlink" href="#capacityenvelope" title="Permanent link">&para;</a></h3>
<p>Frequency-based capacity envelope that stores capacity values as frequencies.</p>
<p>This approach is memory-efficient for Monte Carlo analysis where we care
about statistical distributions rather than individual sample order.</p>
<p>Attributes:
    source_pattern: Regex pattern used to select source nodes.
    sink_pattern: Regex pattern used to select sink nodes.
    mode: Flow analysis mode ("combine" or "pairwise").
    frequencies: Dictionary mapping capacity values to their occurrence counts.
    min_capacity: Minimum observed capacity.
    max_capacity: Maximum observed capacity.
    mean_capacity: Mean capacity across all samples.
    stdev_capacity: Standard deviation of capacity values.
    total_samples: Total number of samples represented.
    flow_summary_stats: Optional dictionary with aggregated FlowSummary statistics.
                       Contains cost_distribution_stats and other flow analytics.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source_pattern</code> (str)</li>
<li><code>sink_pattern</code> (str)</li>
<li><code>mode</code> (str)</li>
<li><code>frequencies</code> (Dict[float, int])</li>
<li><code>min_capacity</code> (float)</li>
<li><code>max_capacity</code> (float)</li>
<li><code>mean_capacity</code> (float)</li>
<li><code>stdev_capacity</code> (float)</li>
<li><code>total_samples</code> (int)</li>
<li><code>flow_summary_stats</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>expand_to_values(self) -&gt; 'List[float]'</code> - Expand frequency map back to individual values.</li>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "'CapacityEnvelope'"</code> - Construct a CapacityEnvelope from a dictionary.</li>
<li><code>from_values(source_pattern: 'str', sink_pattern: 'str', mode: 'str', values: 'List[float]', flow_summaries: 'List[Any] | None' = None) -&gt; "'CapacityEnvelope'"</code> - Create envelope from capacity values and optional flow summaries.</li>
<li><code>get_percentile(self, percentile: 'float') -&gt; 'float'</code> - Calculate percentile from frequency distribution.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<h3 id="failurepatternresult">FailurePatternResult<a class="headerlink" href="#failurepatternresult" title="Permanent link">&para;</a></h3>
<p>Result for a unique failure pattern with associated capacity matrix.</p>
<p>Attributes:
    excluded_nodes: List of failed node IDs.
    excluded_links: List of failed link IDs.
    capacity_matrix: Dictionary mapping flow keys to capacity values.
    count: Number of times this pattern occurred.
    is_baseline: Whether this represents the baseline (no failures) case.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>excluded_nodes</code> (List[str])</li>
<li><code>excluded_links</code> (List[str])</li>
<li><code>capacity_matrix</code> (Dict[str, float])</li>
<li><code>count</code> (int)</li>
<li><code>is_baseline</code> (bool) = False</li>
<li><code>_pattern_key_cache</code> (str)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_dict(data: 'Dict[str, Any]') -&gt; "'FailurePatternResult'"</code> - Construct FailurePatternResult from a dictionary.</li>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Convert to dictionary for JSON serialization.</li>
</ul>
<hr />
<h2 id="ngraphresultsflow">ngraph.results.flow<a class="headerlink" href="#ngraphresultsflow" title="Permanent link">&para;</a></h2>
<p>Unified flow result containers for failure-analysis iterations.</p>
<p>Defines small, serializable dataclasses that capture per-iteration outcomes
for capacity and demand-placement style analyses in a unit-agnostic form.</p>
<p>Objects expose <code>to_dict()</code> that returns JSON-safe primitives. Float-keyed
distributions are normalized to string keys via <code>_fmt_float_key()</code>, and
arbitrary <code>data</code> payloads are sanitized. These dicts are written under
<code>data.flow_results</code> by steps.</p>
<p>Utilities:
    _fmt_float_key: Formats floats as stable string keys for JSON serialization.
        Uses fixed-point notation with trailing zeros stripped for human-readable,
        canonical representations of numeric keys like cost distributions.</p>
<h3 id="flowentry">FlowEntry<a class="headerlink" href="#flowentry" title="Permanent link">&para;</a></h3>
<p>Represents a single sourcedestination flow outcome within an iteration.</p>
<p>Fields are unit-agnostic. Callers can interpret numbers as needed for
presentation (e.g., Gbit/s).</p>
<p>Args:
    source: Source identifier.
    destination: Destination identifier.
    priority: Priority/class for traffic placement scenarios. Zero when not applicable.
    demand: Requested volume for this flow.
    placed: Delivered volume for this flow.
    dropped: Unmet volume (<code>demand - placed</code>).
    cost_distribution: Optional distribution of placed volume by path cost.
    data: Optional per-flow details (e.g., min-cut edges, used edges).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>source</code> (str)</li>
<li><code>destination</code> (str)</li>
<li><code>priority</code> (int)</li>
<li><code>demand</code> (float)</li>
<li><code>placed</code> (float)</li>
<li><code>dropped</code> (float)</li>
<li><code>cost_distribution</code> (Dict[float, float]) = {}</li>
<li><code>data</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<h3 id="flowiterationresult">FlowIterationResult<a class="headerlink" href="#flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Container for per-iteration analysis results.</p>
<p>Args:
    failure_id: Stable identifier for the failure scenario (hash of excluded
        components, or "" for no exclusions).
    failure_state: Optional excluded components for the iteration.
    failure_trace: Optional trace info (mode_index, selections, expansion) when
        store_failure_patterns=True. None for baseline or when tracing disabled.
    occurrence_count: Number of Monte Carlo iterations that produced this exact
        failure pattern. Used with deduplication to avoid re-running identical
        analyses. Defaults to 1.
    flows: List of flow entries for this iteration.
    summary: Aggregated summary across <code>flows</code>.
    data: Optional per-iteration extras.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>failure_id</code> (str)</li>
<li><code>failure_state</code> (Optional[Dict[str, List[str]]])</li>
<li><code>failure_trace</code> (Optional[Dict[str, Any]])</li>
<li><code>occurrence_count</code> (int) = 1</li>
<li><code>flows</code> (List[FlowEntry]) = []</li>
<li><code>summary</code> (FlowSummary) = FlowSummary(total_demand=0.0, total_placed=0.0, overall_ratio=1.0, dropped_flows=0, num_flows=0)</li>
<li><code>data</code> (Dict[str, Any]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<h3 id="flowsummary">FlowSummary<a class="headerlink" href="#flowsummary" title="Permanent link">&para;</a></h3>
<p>Aggregated metrics across all flows in one iteration.</p>
<p>Args:
    total_demand: Sum of all demands in this iteration.
    total_placed: Sum of all delivered volumes in this iteration.
    overall_ratio: <code>total_placed / total_demand</code> when demand &gt; 0, else 1.0.
    dropped_flows: Number of flow entries with non-zero drop.
    num_flows: Total number of flows considered.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>total_demand</code> (float)</li>
<li><code>total_placed</code> (float)</li>
<li><code>overall_ratio</code> (float)</li>
<li><code>dropped_flows</code> (int)</li>
<li><code>num_flows</code> (int)</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>to_dict(self) -&gt; 'Dict[str, Any]'</code> - Return a JSON-serializable dictionary representation.</li>
</ul>
<hr />
<h2 id="ngraphresultssnapshot">ngraph.results.snapshot<a class="headerlink" href="#ngraphresultssnapshot" title="Permanent link">&para;</a></h2>
<p>Scenario snapshot helpers.</p>
<p>Build a concise dictionary snapshot of failure policies and demand sets for
export into results without keeping heavy domain objects.</p>
<h3 id="build_scenario_snapshot-seed-int-none-failure_policy_set-demand_set-dictstr-any">build_scenario_snapshot(*, seed: 'int | None', failure_policy_set, demand_set) -&gt; 'Dict[str, Any]'<a class="headerlink" href="#build_scenario_snapshot-seed-int-none-failure_policy_set-demand_set-dictstr-any" title="Permanent link">&para;</a></h3>
<p>Build a concise dictionary snapshot of the scenario state.</p>
<p>Creates a serializable representation of the scenario's failure policies
and demand sets, suitable for export into results without keeping heavy
domain objects.</p>
<p>Args:
    seed: Scenario-level seed for reproducibility, or None if unseeded.
    failure_policy_set: FailurePolicySet containing named failure policies.
    demand_set: DemandSet containing named demand collections.</p>
<p>Returns:
    Dict containing: seed, failures (policy snapshots), demands (demand snapshots).</p>
<hr />
<h2 id="ngraphresultsstore">ngraph.results.store<a class="headerlink" href="#ngraphresultsstore" title="Permanent link">&para;</a></h2>
<p>Generic results store for workflow steps and their metadata.</p>
<p><code>Results</code> organizes outputs by workflow step name and records
<code>WorkflowStepMetadata</code> for execution context. Storage is strictly
step-scoped: steps must write two keys under their namespace:</p>
<ul>
<li><code>metadata</code>: step-level metadata (dict)</li>
<li><code>data</code>: step-specific payload (dict)</li>
</ul>
<p>Export with :meth:<code>Results.to_dict</code>, which returns a JSON-safe structure
with shape <code>{workflow, steps, scenario}</code>. During export, objects with a
<code>to_dict()</code> method are converted, dictionary keys are coerced to strings,
tuples are emitted as lists, and only JSON primitives are produced.</p>
<h3 id="results">Results<a class="headerlink" href="#results" title="Permanent link">&para;</a></h3>
<p>Step-scoped results container with deterministic export shape.</p>
<p>Structure:</p>
<ul>
<li>workflow: step metadata registry</li>
<li>steps: per-step results with enforced keys {"metadata", "data"}</li>
<li>scenario: optional scenario snapshot set once at load time</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>_store</code> (Dict) = {}</li>
<li><code>_metadata</code> (Dict) = {}</li>
<li><code>_active_step</code> (Optional)</li>
<li><code>_scenario</code> (Dict) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>enter_step(self, step_name: str) -&gt; None</code> - Enter step scope. Subsequent put/get are scoped to this step.</li>
<li><code>exit_step(self) -&gt; None</code> - Exit step scope.</li>
<li><code>get(self, key: str, default: Any = None) -&gt; Any</code> - Get a value from the active step scope.</li>
<li><code>get_all_step_metadata(self) -&gt; Dict[str, ngraph.results.store.WorkflowStepMetadata]</code> - Get metadata for all workflow steps.</li>
<li><code>get_step(self, step_name: str) -&gt; Dict[str, Any]</code> - Return the raw dict for a given step name (for cross-step reads).</li>
<li><code>get_step_metadata(self, step_name: str) -&gt; Optional[ngraph.results.store.WorkflowStepMetadata]</code> - Get metadata for a workflow step.</li>
<li><code>get_steps_by_execution_order(self) -&gt; list[str]</code> - Get step names ordered by their execution order.</li>
<li><code>put(self, key: str, value: Any) -&gt; None</code> - Store a value in the active step under an allowed key.</li>
<li><code>put_step_metadata(self, step_name: str, step_type: str, execution_order: int, *, scenario_seed: Optional[int] = None, step_seed: Optional[int] = None, seed_source: str = 'none', active_seed: Optional[int] = None) -&gt; None</code> - Store metadata for a workflow step.</li>
<li><code>set_scenario_snapshot(self, snapshot: Dict[str, Any]) -&gt; None</code> - Attach a normalized scenario snapshot for export.</li>
<li><code>to_dict(self) -&gt; Dict[str, Any]</code> - Return exported results with shape: {workflow, steps, scenario}.</li>
</ul>
<h3 id="workflowstepmetadata">WorkflowStepMetadata<a class="headerlink" href="#workflowstepmetadata" title="Permanent link">&para;</a></h3>
<p>Metadata for a workflow step execution.</p>
<p>Attributes:
    step_type: The workflow step class name (e.g., 'CapacityEnvelopeAnalysis').
    step_name: The instance name of the step.
    execution_order: Order in which this step was executed (0-based).
    scenario_seed: Scenario-level seed provided in the YAML (if any).
    step_seed: Seed assigned to this step (explicit or scenario-derived).
    seed_source: Source for the step seed. One of:</p>
<ul>
<li>"scenario-derived": seed was derived from scenario.seed</li>
<li>"explicit-step": seed was explicitly provided for the step</li>
<li>
<p>"none": no seed provided/active for this step</p>
<p>active_seed: The effective base seed used by the step, if any. For steps
    that use Monte Carlo execution, per-iteration seeds are derived from
    active_seed (e.g., active_seed + iteration_index).</p>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_type</code> (str)</li>
<li><code>step_name</code> (str)</li>
<li><code>execution_order</code> (int)</li>
<li><code>scenario_seed</code> (Optional)</li>
<li><code>step_seed</code> (Optional)</li>
<li><code>seed_source</code> (str) = none</li>
<li><code>active_seed</code> (Optional)</li>
</ul>
<hr />
<h2 id="ngraphprofilingprofiler">ngraph.profiling.profiler<a class="headerlink" href="#ngraphprofilingprofiler" title="Permanent link">&para;</a></h2>
<p>Profiling for NetGraph workflow execution.</p>
<p>Provides CPU and wall-clock timing per workflow step using <code>cProfile</code> and
optionally peak memory via <code>tracemalloc</code>. Aggregates results into structured
summaries and identifies time-dominant steps (bottlenecks).</p>
<h3 id="performanceprofiler">PerformanceProfiler<a class="headerlink" href="#performanceprofiler" title="Permanent link">&para;</a></h3>
<p>CPU profiler for NetGraph workflow execution.</p>
<p>Profiles workflow steps using cProfile and identifies bottlenecks.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>analyze_performance(self) -&gt; 'None'</code> - Analyze profiling results and identify bottlenecks.</li>
<li><code>end_scenario(self) -&gt; 'None'</code> - End profiling for the entire scenario execution.</li>
<li><code>get_top_functions(self, step_name: 'str', limit: 'int' = 10) -&gt; 'List[Tuple[str, float, int]]'</code> - Get the top CPU-consuming functions for a specific step.</li>
<li><code>merge_child_profiles(self, profile_dir: 'Path', step_name: 'str') -&gt; 'None'</code> - Merge child worker profiles into the parent step profile.</li>
<li><code>profile_step(self, step_name: 'str', step_type: 'str') -&gt; 'Generator[None, None, None]'</code> - Context manager for profiling individual workflow steps.</li>
<li><code>save_detailed_profile(self, output_path: 'Path', step_name: 'Optional[str]' = None) -&gt; 'None'</code> - Save detailed profiling data to a file.</li>
<li><code>start_scenario(self) -&gt; 'None'</code> - Start profiling for the entire scenario execution.</li>
</ul>
<h3 id="performancereporter">PerformanceReporter<a class="headerlink" href="#performancereporter" title="Permanent link">&para;</a></h3>
<p>Format and render performance profiling results.</p>
<p>Generates plain-text reports with timing analysis, bottleneck identification,
and practical performance tuning suggestions.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>generate_report(self) -&gt; 'str'</code> - Generate performance report.</li>
</ul>
<h3 id="profileresults">ProfileResults<a class="headerlink" href="#profileresults" title="Permanent link">&para;</a></h3>
<p>Profiling results for a scenario execution.</p>
<p>Attributes:
    step_profiles: List of individual step performance profiles.
    total_wall_time: Total wall-clock time for entire scenario.
    total_cpu_time: Total CPU time across all steps.
    total_function_calls: Total function calls across all steps.
    bottlenecks: List of performance bottlenecks (&gt;10% execution time).
    analysis_summary: Performance metrics and statistics.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_profiles</code> (List[StepProfile]) = []</li>
<li><code>total_wall_time</code> (float) = 0.0</li>
<li><code>total_cpu_time</code> (float) = 0.0</li>
<li><code>total_function_calls</code> (int) = 0</li>
<li><code>bottlenecks</code> (List[Dict[str, Any]]) = []</li>
<li><code>analysis_summary</code> (Dict[str, Any]) = {}</li>
</ul>
<h3 id="stepprofile">StepProfile<a class="headerlink" href="#stepprofile" title="Permanent link">&para;</a></h3>
<p>Performance profile data for a single workflow step.</p>
<p>Attributes:
    step_name: Name of the workflow step.
    step_type: Type/class name of the workflow step.
    wall_time: Total wall-clock time in seconds.
    cpu_time: CPU time spent in step execution.
    function_calls: Number of function calls during execution.
    memory_peak: Peak memory usage during step in bytes (if available).
    cprofile_stats: Detailed cProfile statistics object.
    worker_profiles_merged: Number of worker profiles merged into this step.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>step_name</code> (str)</li>
<li><code>step_type</code> (str)</li>
<li><code>wall_time</code> (float)</li>
<li><code>cpu_time</code> (float)</li>
<li><code>function_calls</code> (int)</li>
<li><code>memory_peak</code> (Optional[float])</li>
<li><code>cprofile_stats</code> (Optional[pstats.Stats])</li>
<li><code>worker_profiles_merged</code> (int) = 0</li>
</ul>
<hr />
<h2 id="ngraphtypesbase">ngraph.types.base<a class="headerlink" href="#ngraphtypesbase" title="Permanent link">&para;</a></h2>
<p>Base classes and enums for network analysis algorithms.</p>
<h3 id="edgeselect">EdgeSelect<a class="headerlink" href="#edgeselect" title="Permanent link">&para;</a></h3>
<p>Edge selection criteria for shortest-path algorithms.</p>
<p>Determines which edges are considered when finding paths between nodes.
These map to NetGraph-Core's EdgeSelection configuration.</p>
<h3 id="flowplacement">FlowPlacement<a class="headerlink" href="#flowplacement" title="Permanent link">&para;</a></h3>
<p>Strategies to distribute flow across parallel equal-cost paths.</p>
<h3 id="mode">Mode<a class="headerlink" href="#mode" title="Permanent link">&para;</a></h3>
<p>Analysis mode for source/sink group handling.</p>
<p>Determines how multiple source and sink nodes are combined for analysis.</p>
<hr />
<h2 id="ngraphtypesdto">ngraph.types.dto<a class="headerlink" href="#ngraphtypesdto" title="Permanent link">&para;</a></h2>
<p>Types and data structures for algorithm analytics.</p>
<p>Defines immutable summary containers for algorithm outputs.</p>
<h3 id="edgeref">EdgeRef<a class="headerlink" href="#edgeref" title="Permanent link">&para;</a></h3>
<p>Reference to a directed edge via scenario link_id and direction.</p>
<p>Provides stable, scenario-native edge identification across Core reorderings
using the link's unique ID rather than node name tuples.</p>
<p>Attributes:
    link_id: Scenario link identifier (matches Network.links keys)
    direction: 'fwd' for sourcetarget as defined in Link; 'rev' for reverse</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>link_id</code> (str)</li>
<li><code>direction</code> (EdgeDir)</li>
</ul>
<h3 id="maxflowresult">MaxFlowResult<a class="headerlink" href="#maxflowresult" title="Permanent link">&para;</a></h3>
<p>Result of max-flow computation between a source/sink pair.</p>
<p>Captures total flow, cost distribution, and optionally min-cut edges.</p>
<p>Attributes:
    total_flow: Maximum flow value achieved.
    cost_distribution: Mapping of path cost to flow volume placed at that cost.
    min_cut: Saturated edges forming the min-cut (None if not computed).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>total_flow</code> (float)</li>
<li><code>cost_distribution</code> (Dict[Cost, float])</li>
<li><code>min_cut</code> (Tuple[EdgeRef, ...] | None)</li>
</ul>
<hr />
<h2 id="ngraphutilsids">ngraph.utils.ids<a class="headerlink" href="#ngraphutilsids" title="Permanent link">&para;</a></h2>
<h3 id="new_base64_uuid-str">new_base64_uuid() -&gt; 'str'<a class="headerlink" href="#new_base64_uuid-str" title="Permanent link">&para;</a></h3>
<p>Return a 22-character URL-safe Base64-encoded UUID without padding.</p>
<p>The function generates a random version 4 UUID, encodes the 16 raw bytes
using URL-safe Base64, removes the two trailing padding characters, and
decodes to ASCII. The resulting string length is 22 characters.</p>
<p>Returns:
    A 22-character URL-safe Base64 representation of a UUID4 without
    padding.</p>
<hr />
<h2 id="ngraphutilsoutput_paths">ngraph.utils.output_paths<a class="headerlink" href="#ngraphutilsoutput_paths" title="Permanent link">&para;</a></h2>
<p>Utilities for building CLI artifact output paths.</p>
<p>This module centralizes logic for composing file and directory paths for
artifacts produced by the NetGraph CLI. Paths are built from an optional
output directory, a prefix (usually derived from the scenario file or
results file), and a per-artifact suffix.</p>
<h3 id="build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path">build_artifact_path(output_dir: 'Optional[Path]', prefix: 'str', suffix: 'str') -&gt; 'Path'<a class="headerlink" href="#build_artifact_pathoutput_dir-optionalpath-prefix-str-suffix-str-path" title="Permanent link">&para;</a></h3>
<p>Compose an artifact path as output_dir / (prefix + suffix).</p>
<p>If <code>output_dir</code> is None, the path is created relative to the current
working directory.</p>
<p>Args:
    output_dir: Base directory for outputs; if None, use CWD.
    prefix: Filename prefix; usually derived from scenario or results stem.
    suffix: Per-artifact suffix including the dot (e.g. ".results.json").</p>
<p>Returns:
    The composed path.</p>
<h3 id="ensure_parent_dirpath-path-none">ensure_parent_dir(path: 'Path') -&gt; 'None'<a class="headerlink" href="#ensure_parent_dirpath-path-none" title="Permanent link">&para;</a></h3>
<p>Ensure the parent directory exists for a file path.</p>
<h3 id="profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path">profiles_dir_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]') -&gt; 'Path'<a class="headerlink" href="#profiles_dir_for_runscenario_path-path-output_dir-optionalpath-path" title="Permanent link">&para;</a></h3>
<p>Return the directory for child worker profiles for <code>run --profile</code>.</p>
<p>Args:
    scenario_path: The scenario YAML path.
    output_dir: Optional base output directory.</p>
<p>Returns:
    Directory path where worker profiles should be stored.</p>
<h3 id="resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath">resolve_override_path(override: 'Optional[Path]', output_dir: 'Optional[Path]') -&gt; 'Optional[Path]'<a class="headerlink" href="#resolve_override_pathoverride-optionalpath-output_dir-optionalpath-optionalpath" title="Permanent link">&para;</a></h3>
<p>Resolve an override path with respect to an optional output directory.</p>
<ul>
<li>Absolute override paths are returned as-is.</li>
<li>Relative override paths are interpreted as relative to <code>output_dir</code></li>
</ul>
<p>when provided; otherwise relative to the current working directory.</p>
<p>Args:
    override: Path provided by the user to override the default.
    output_dir: Optional base directory for relative overrides.</p>
<p>Returns:
    The resolved path or None if no override was provided.</p>
<h3 id="results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path">results_path_for_run(scenario_path: 'Path', output_dir: 'Optional[Path]', results_override: 'Optional[Path]') -&gt; 'Path'<a class="headerlink" href="#results_path_for_runscenario_path-path-output_dir-optionalpath-results_override-optionalpath-path" title="Permanent link">&para;</a></h3>
<p>Determine the results JSON path for the <code>run</code> command.</p>
<p>Behavior:</p>
<ul>
<li>If <code>results_override</code> is provided, return it (resolved relative to</li>
</ul>
<p><code>output_dir</code> when that is specified, otherwise as-is).</p>
<ul>
<li>Else if <code>output_dir</code> is provided, return <code>output_dir/&lt;prefix&gt;.results.json</code>.</li>
<li>Else, return <code>&lt;scenario_stem&gt;.results.json</code> in the current working directory.</li>
</ul>
<p>Args:
    scenario_path: The scenario YAML file path.
    output_dir: Optional base output directory.
    results_override: Optional explicit results file path.</p>
<p>Returns:
    The path where results should be written.</p>
<h3 id="scenario_prefix_from_pathscenario_path-path-str">scenario_prefix_from_path(scenario_path: 'Path') -&gt; 'str'<a class="headerlink" href="#scenario_prefix_from_pathscenario_path-path-str" title="Permanent link">&para;</a></h3>
<p>Return a safe prefix derived from a scenario file path.</p>
<p>Args:
    scenario_path: The scenario YAML file path.</p>
<p>Returns:
    The scenario filename stem, trimmed of extensions.</p>
<hr />
<h2 id="ngraphutilsseed_manager">ngraph.utils.seed_manager<a class="headerlink" href="#ngraphutilsseed_manager" title="Permanent link">&para;</a></h2>
<p>Deterministic seed derivation to avoid global random.seed() order dependencies.</p>
<h3 id="seedmanager">SeedManager<a class="headerlink" href="#seedmanager" title="Permanent link">&para;</a></h3>
<p>Manages deterministic seed derivation for isolated component reproducibility.</p>
<p>Global random.seed() creates order dependencies and component interference.
SeedManager derives unique seeds per component from a master seed using SHA-256,
ensuring reproducible results regardless of execution order or parallelism.</p>
<p>Usage:
    seed_mgr = SeedManager(42)
    failure_seed = seed_mgr.derive_seed("failure_policy", "default")</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>derive_seed(self, *components: 'Any') -&gt; 'Optional[int]'</code> - Derive a deterministic seed from master seed and component identifiers.</li>
</ul>
<hr />
<h2 id="ngraphutilsyaml_utils">ngraph.utils.yaml_utils<a class="headerlink" href="#ngraphutilsyaml_utils" title="Permanent link">&para;</a></h2>
<p>Utilities for handling YAML parsing quirks and common operations.</p>
<h3 id="normalize_yaml_dict_keysdata-dictany-v-dictstr-v">normalize_yaml_dict_keys(data: Dict[Any, ~V]) -&gt; Dict[str, ~V]<a class="headerlink" href="#normalize_yaml_dict_keysdata-dictany-v-dictstr-v" title="Permanent link">&para;</a></h3>
<p>Normalize dictionary keys from YAML parsing to ensure consistent string keys.</p>
<p>YAML 1.1 boolean keys (e.g., true, false, yes, no, on, off) get converted to
Python True/False boolean values. This function converts them to predictable
string representations ("True"/"False") and ensures all keys are strings.</p>
<p>Args:
    data: Dictionary that may contain boolean or other non-string keys from YAML parsing</p>
<p>Returns:
    Dictionary with all keys converted to strings, boolean keys converted to "True"/"False"</p>
<p>Examples:
    &gt;&gt;&gt; normalize_yaml_dict_keys({True: "value1", False: "value2", "normal": "value3"})
    {"True": "value1", "False": "value2", "normal": "value3"}</p>
<div class="language-text highlight"><pre><span></span><code>&gt;&gt;&gt; # In YAML: true:, yes:, on: all become Python True
&gt;&gt;&gt; # In YAML: false:, no:, off: all become Python False
</code></pre></div>
<hr />
<h2 id="ngraphanalysiscontext">ngraph.analysis.context<a class="headerlink" href="#ngraphanalysiscontext" title="Permanent link">&para;</a></h2>
<p>AnalysisContext: Prepared state for efficient network analysis.</p>
<p>This module provides the primary API for network analysis in NetGraph.
AnalysisContext encapsulates Core graph infrastructure and provides
methods for max-flow, shortest paths, and sensitivity analysis.</p>
<p>Usage:
    # One-off analysis
    from ngraph import analyze
    flow = analyze(network).max_flow("^A$", "^B$")</p>
<div class="language-text highlight"><pre><span></span><code># Efficient repeated analysis (bound context)
ctx = analyze(network, source=&quot;^A$&quot;, sink=&quot;^B$&quot;)
baseline = ctx.max_flow()
degraded = ctx.max_flow(excluded_links=failed_links)
</code></pre></div>
<h3 id="analysiscontext">AnalysisContext<a class="headerlink" href="#analysiscontext" title="Permanent link">&para;</a></h3>
<p>Prepared state for efficient network analysis.</p>
<p>Encapsulates Core graph infrastructure. Supports two usage patterns:</p>
<p><strong>Unbound</strong> - flexible, specify source/sink per-call:</p>
<div class="language-text highlight"><pre><span></span><code>ctx = AnalysisContext.from_network(network)
cost = ctx.shortest_path_cost(&quot;A&quot;, &quot;B&quot;)
flow = ctx.max_flow(&quot;A&quot;, &quot;B&quot;)  # Builds pseudo-nodes each call
</code></pre></div>
<p><strong>Bound</strong> - optimized for repeated analysis with same groups:</p>
<div class="language-text highlight"><pre><span></span><code>ctx = AnalysisContext.from_network(
    network,
    source=&quot;^dc/&quot;,
    sink=&quot;^edge/&quot;
)
baseline = ctx.max_flow()  # Uses pre-built pseudo-nodes
degraded = ctx.max_flow(excluded_links=failed)
</code></pre></div>
<p>Thread Safety:
    Immutable after creation. Safe for concurrent analysis calls
    with different exclusion sets.</p>
<p>Attributes:
    network: Reference to source Network (read-only).
    is_bound: True if source/sink groups are pre-configured.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>_network</code> ('Network')</li>
<li><code>_handle</code> (netgraph_core.Graph)</li>
<li><code>_multidigraph</code> (netgraph_core.StrictMultiDiGraph)</li>
<li><code>_node_mapper</code> (_NodeMapper)</li>
<li><code>_edge_mapper</code> (_EdgeMapper)</li>
<li><code>_algorithms</code> (netgraph_core.Algorithms)</li>
<li><code>_disabled_node_ids</code> (FrozenSet[int])</li>
<li><code>_disabled_link_ids</code> (FrozenSet[str])</li>
<li><code>_link_id_to_edge_indices</code> (Mapping[str, Tuple[int, ...]])</li>
<li><code>_source</code> (Optional[Union[str, Dict[str, Any]]])</li>
<li><code>_sink</code> (Optional[Union[str, Dict[str, Any]]])</li>
<li><code>_mode</code> (Optional[Mode])</li>
<li><code>_pseudo_context</code> (Optional[_PseudoNodeContext])</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_network(network: "'Network'", *, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, augmentations: 'Optional[List[AugmentationEdge]]' = None) -&gt; "'AnalysisContext'"</code> - Create analysis context from network.</li>
<li><code>k_shortest_paths(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.PAIRWISE: 2&gt;, max_k: 'int' = 3, edge_select: 'EdgeSelect' = &lt;EdgeSelect.ALL_MIN_COST: 1&gt;, max_path_cost: 'float' = inf, max_path_cost_factor: 'Optional[float]' = None, split_parallel_edges: 'bool' = False, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None) -&gt; 'Dict[Tuple[str, str], List[Path]]'</code> - Compute up to K shortest paths per group pair.</li>
<li><code>max_flow(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None) -&gt; 'Dict[Tuple[str, str], float]'</code> - Compute maximum flow between node groups.</li>
<li><code>max_flow_detailed(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None, include_min_cut: 'bool' = False) -&gt; 'Dict[Tuple[str, str], MaxFlowResult]'</code> - Compute max flow with detailed results including cost distribution.</li>
<li><code>sensitivity(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None) -&gt; 'Dict[Tuple[str, str], Dict[str, float]]'</code> - Analyze sensitivity of max flow to edge failures.</li>
<li><code>shortest_path_cost(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, edge_select: 'EdgeSelect' = &lt;EdgeSelect.ALL_MIN_COST: 1&gt;, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None) -&gt; 'Dict[Tuple[str, str], float]'</code> - Compute shortest path costs between node groups.</li>
<li><code>shortest_paths(self, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, *, mode: 'Mode' = &lt;Mode.COMBINE: 1&gt;, edge_select: 'EdgeSelect' = &lt;EdgeSelect.ALL_MIN_COST: 1&gt;, split_parallel_edges: 'bool' = False, excluded_nodes: 'Optional[Set[str]]' = None, excluded_links: 'Optional[Set[str]]' = None) -&gt; 'Dict[Tuple[str, str], List[Path]]'</code> - Compute concrete shortest paths between node groups.</li>
</ul>
<h3 id="augmentationedge">AugmentationEdge<a class="headerlink" href="#augmentationedge" title="Permanent link">&para;</a></h3>
<p>Edge specification for graph augmentation.</p>
<p>Augmentation edges are added to the graph as-is (unidirectional).
Nodes referenced in augmentations that don't exist in the network
are automatically treated as pseudo/virtual nodes.</p>
<p>Attributes:
    source: Source node name (real or pseudo)
    target: Target node name (real or pseudo)
    capacity: Edge capacity
    cost: Edge cost (converted to int64 for Core)</p>
<h3 id="analyzenetwork-network-source-optionalunionstr-dictstr-any-none-sink-optionalunionstr-dictstr-any-none-mode-mode-augmentations-optionallistaugmentationedge-none-analysiscontext">analyze(network: "'Network'", *, source: 'Optional[Union[str, Dict[str, Any]]]' = None, sink: 'Optional[Union[str, Dict[str, Any]]]' = None, mode: 'Mode' = <Mode.COMBINE: 1>, augmentations: 'Optional[List[AugmentationEdge]]' = None) -&gt; 'AnalysisContext'<a class="headerlink" href="#analyzenetwork-network-source-optionalunionstr-dictstr-any-none-sink-optionalunionstr-dictstr-any-none-mode-mode-augmentations-optionallistaugmentationedge-none-analysiscontext" title="Permanent link">&para;</a></h3>
<p>Create an analysis context for the network.</p>
<p>This is THE primary entry point for network analysis in NetGraph.</p>
<p>Args:
    network: Network topology to analyze.
    source: Optional source node selector (string path or selector dict).
            If provided with sink, creates bound context with pre-built
            pseudo-nodes for efficient repeated flow analysis.
    sink: Optional sink node selector (string path or selector dict).
    mode: Group mode (COMBINE or PAIRWISE). Only used if bound.
    augmentations: Optional custom augmentation edges.</p>
<p>Returns:
    AnalysisContext ready for analysis calls.</p>
<p>Examples:
    One-off analysis (unbound context):</p>
<div class="language-text highlight"><pre><span></span><code>    flow = analyze(network).max_flow(&quot;^A$&quot;, &quot;^B$&quot;)
    paths = analyze(network).shortest_paths(&quot;^A$&quot;, &quot;^B$&quot;)

Efficient repeated analysis (bound context):

    ctx = analyze(network, source=&quot;^dc/&quot;, sink=&quot;^edge/&quot;)
    baseline = ctx.max_flow()
    degraded = ctx.max_flow(excluded_links=failed_links)

Multiple exclusion scenarios:

    ctx = analyze(network, source=&quot;^A$&quot;, sink=&quot;^B$&quot;)
    for scenario in failure_scenarios:
        result = ctx.max_flow(excluded_links=scenario)
</code></pre></div>
<h3 id="build_edge_maskctx-analysiscontext-excluded_links-optionalsetstr-none-npndarray">build_edge_mask(ctx: 'AnalysisContext', excluded_links: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'<a class="headerlink" href="#build_edge_maskctx-analysiscontext-excluded_links-optionalsetstr-none-npndarray" title="Permanent link">&para;</a></h3>
<p>Build an edge mask array for Core algorithms.</p>
<p>Uses O(|excluded| + |disabled|) time complexity.
Core semantics: True = include, False = exclude.</p>
<p>Args:
    ctx: AnalysisContext with pre-computed edge index mapping.
    excluded_links: Optional set of link IDs to exclude.</p>
<p>Returns:
    Boolean numpy array of shape (num_edges,) where True means included.</p>
<h3 id="build_node_maskctx-analysiscontext-excluded_nodes-optionalsetstr-none-npndarray">build_node_mask(ctx: 'AnalysisContext', excluded_nodes: 'Optional[Set[str]]' = None) -&gt; 'np.ndarray'<a class="headerlink" href="#build_node_maskctx-analysiscontext-excluded_nodes-optionalsetstr-none-npndarray" title="Permanent link">&para;</a></h3>
<p>Build a node mask array for Core algorithms.</p>
<p>Uses O(|excluded| + |disabled|) time complexity.
Core semantics: True = include, False = exclude.</p>
<p>Args:
    ctx: AnalysisContext with pre-computed disabled node IDs.
    excluded_nodes: Optional set of node names to exclude.</p>
<p>Returns:
    Boolean numpy array of shape (num_nodes,) where True means included.</p>
<hr />
<h2 id="ngraphanalysisdemand">ngraph.analysis.demand<a class="headerlink" href="#ngraphanalysisdemand" title="Permanent link">&para;</a></h2>
<p>Demand expansion: converts TrafficDemand specs into concrete placement demands.</p>
<p>Supports both pairwise and combine modes through augmentation-based pseudo nodes.
Uses unified selectors for node selection.</p>
<h3 id="demandexpansion">DemandExpansion<a class="headerlink" href="#demandexpansion" title="Permanent link">&para;</a></h3>
<p>Demand expansion result.</p>
<p>Attributes:
    demands: Concrete demands ready for placement (sorted by priority).
    augmentations: Augmentation edges for pseudo nodes (empty for pairwise).</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>demands</code> (List[ExpandedDemand])</li>
<li><code>augmentations</code> (List[AugmentationEdge])</li>
</ul>
<h3 id="expandeddemand">ExpandedDemand<a class="headerlink" href="#expandeddemand" title="Permanent link">&para;</a></h3>
<p>Concrete demand ready for placement.</p>
<p>Uses node names (not IDs) so expansion happens before graph building.
Node IDs are resolved after the graph is built with pseudo nodes.</p>
<p>Attributes:
    src_name: Source node name (real or pseudo).
    dst_name: Destination node name (real or pseudo).
    volume: Traffic volume to place.
    priority: Priority class (lower is higher priority).
    policy_preset: FlowPolicy configuration preset.
    demand_id: Parent TrafficDemand ID for tracking.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>src_name</code> (str)</li>
<li><code>dst_name</code> (str)</li>
<li><code>volume</code> (float)</li>
<li><code>priority</code> (int)</li>
<li><code>policy_preset</code> (FlowPolicyPreset)</li>
<li><code>demand_id</code> (str)</li>
</ul>
<h3 id="expand_demandsnetwork-network-traffic_demands-listtrafficdemand-default_policy_preset-flowpolicypreset-demandexpansion">expand_demands(network: 'Network', traffic_demands: 'List[TrafficDemand]', default_policy_preset: 'FlowPolicyPreset' = <FlowPolicyPreset.SHORTEST_PATHS_ECMP: 1>) -&gt; 'DemandExpansion'<a class="headerlink" href="#expand_demandsnetwork-network-traffic_demands-listtrafficdemand-default_policy_preset-flowpolicypreset-demandexpansion" title="Permanent link">&para;</a></h3>
<p>Expand TrafficDemand specifications into concrete demands with augmentations.</p>
<p>Pure function that:</p>
<ol>
<li>Normalizes and evaluates selectors to get node groups</li>
<li>Distributes volume based on mode (combine/pairwise) and group_mode</li>
<li>Generates augmentation edges for combine mode (pseudo nodes)</li>
<li>Returns demands (node names) + augmentations</li>
</ol>
<p>Node names are used (not IDs) so expansion happens BEFORE graph building.
IDs are resolved after graph is built with augmentations.</p>
<p>Note: Variable expansion (expand: block) is handled during YAML parsing in
build_demand_set(), so TrafficDemand objects here are already expanded.</p>
<p>Args:
    network: Network for node selection.
    traffic_demands: High-level demand specifications.
    default_policy_preset: Default policy if demand doesn't specify one.</p>
<p>Returns:
    DemandExpansion with demands and augmentations.</p>
<p>Raises:
    ValueError: If no demands could be expanded or unsupported mode.</p>
<hr />
<h2 id="ngraphanalysisfailure_manager">ngraph.analysis.failure_manager<a class="headerlink" href="#ngraphanalysisfailure_manager" title="Permanent link">&para;</a></h2>
<p>FailureManager for Monte Carlo failure analysis.</p>
<p>Provides the failure analysis engine for NetGraph. Supports parallel
processing, graph caching, and failure policy handling for workflow steps
and direct programmatic use.</p>
<p>Performance characteristics:
Time complexity: O(S + I * A / P), where S is one-time graph setup cost,
I is iteration count, A is per-iteration analysis cost, and P is parallelism.
Graph caching amortizes expensive graph construction across all iterations,
and O(|excluded|) mask building replaces O(V+E) iteration.</p>
<p>Space complexity: O(V + E + I * R), where V and E are node and link counts,
and R is result size per iteration. The pre-built graph is shared across
all iterations.</p>
<p>Parallelism: The C++ Core backend releases the GIL during computation,
enabling true parallelism with Python threads. With graph caching, most
per-iteration work runs in GIL-free C++ code; speedup depends on workload
and parallelism level.</p>
<h3 id="analysisfunction">AnalysisFunction<a class="headerlink" href="#analysisfunction" title="Permanent link">&para;</a></h3>
<p>Protocol for analysis functions used with FailureManager.</p>
<p>Analysis functions take a Network, exclusion sets, and analysis-specific
parameters, returning results of any type.</p>
<h3 id="failuremanager">FailureManager<a class="headerlink" href="#failuremanager" title="Permanent link">&para;</a></h3>
<p>Failure analysis engine with Monte Carlo capabilities.</p>
<p>This is the component for failure analysis in NetGraph.
Provides parallel processing, worker caching, and failure
policy handling for workflow steps and direct notebook usage.</p>
<p>The FailureManager can execute any analysis function that takes a Network
with exclusion sets and returns results, making it generic for different
types of failure analysis (capacity, traffic, connectivity, etc.).</p>
<p>Attributes:
    network: The underlying network (not modified during analysis).
    failure_policy_set: Set of named failure policies.
    policy_name: Name of specific failure policy to use.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>compute_exclusions(self, policy: "'FailurePolicy | None'" = None, seed_offset: 'int | None' = None, failure_trace: 'Optional[Dict[str, Any]]' = None) -&gt; 'tuple[set[str], set[str]]'</code> - Compute set of nodes and links to exclude for a failure iteration.</li>
<li><code>get_failure_policy(self) -&gt; "'FailurePolicy | None'"</code> - Get failure policy for analysis.</li>
<li><code>run_demand_placement_monte_carlo(self, demands_config: 'list[dict[str, Any]] | Any', iterations: 'int' = 100, parallelism: 'int' = 1, placement_rounds: 'int | str' = 'auto', seed: 'int | None' = None, store_failure_patterns: 'bool' = False, include_flow_details: 'bool' = False, include_used_edges: 'bool' = False) -&gt; 'Any'</code> - Analyze traffic demand placement success under failures.</li>
<li><code>run_max_flow_monte_carlo(self, source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', iterations: 'int' = 100, parallelism: 'int' = 1, shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement | str' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, include_flow_summary: 'bool' = False, include_min_cut: 'bool' = False) -&gt; 'Any'</code> - Analyze maximum flow capacity envelopes between node groups under failures.</li>
<li><code>run_monte_carlo_analysis(self, analysis_func: 'AnalysisFunction', iterations: 'int' = 1, parallelism: 'int' = 1, seed: 'int | None' = None, store_failure_patterns: 'bool' = False, **analysis_kwargs) -&gt; 'dict[str, Any]'</code> - Run Monte Carlo failure analysis with any analysis function.</li>
<li><code>run_sensitivity_monte_carlo(self, source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', iterations: 'int' = 100, parallelism: 'int' = 1, shortest_path: 'bool' = False, flow_placement: 'FlowPlacement | str' = &lt;FlowPlacement.PROPORTIONAL: 1&gt;, seed: 'int | None' = None, store_failure_patterns: 'bool' = False) -&gt; 'dict[str, Any]'</code> - Analyze component criticality for flow capacity under failures.</li>
<li><code>run_single_failure_scenario(self, analysis_func: 'AnalysisFunction', **kwargs) -&gt; 'Any'</code> - Run a single failure scenario for convenience.</li>
</ul>
<hr />
<h2 id="ngraphanalysisfunctions">ngraph.analysis.functions<a class="headerlink" href="#ngraphanalysisfunctions" title="Permanent link">&para;</a></h2>
<p>Flow analysis functions for network evaluation.</p>
<p>These functions are designed for use with FailureManager. Each analysis function
takes a Network, exclusion sets, and analysis-specific parameters, returning
results of type FlowIterationResult.</p>
<p>Parameters should ideally be hashable for efficient caching in FailureManager;
non-hashable objects are identified by memory address for cache key generation.</p>
<p>Graph caching enables efficient repeated analysis with different exclusion
sets by building the graph once and using O(|excluded|) masks for exclusions.</p>
<p>SPF caching enables efficient demand placement by computing shortest paths once
per unique source node rather than once per demand. For networks with many demands
sharing the same sources, this can reduce SPF computations by an order of magnitude.</p>
<h3 id="build_demand_contextnetwork-network-demands_config-listdictstr-any-analysiscontext">build_demand_context(network: "'Network'", demands_config: 'list[dict[str, Any]]') -&gt; 'AnalysisContext'<a class="headerlink" href="#build_demand_contextnetwork-network-demands_config-listdictstr-any-analysiscontext" title="Permanent link">&para;</a></h3>
<p>Build an AnalysisContext for repeated demand placement analysis.</p>
<p>Pre-computes the graph with augmentations (pseudo source/target nodes) for
efficient repeated analysis with different exclusion sets.</p>
<p>Args:
    network: Network instance.
    demands_config: List of demand configurations (same format as demand_placement_analysis).</p>
<p>Returns:
    AnalysisContext ready for use with demand_placement_analysis.</p>
<h3 id="build_maxflow_contextnetwork-network-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-analysiscontext">build_maxflow_context(network: "'Network'", source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine') -&gt; 'AnalysisContext'<a class="headerlink" href="#build_maxflow_contextnetwork-network-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-analysiscontext" title="Permanent link">&para;</a></h3>
<p>Build an AnalysisContext for repeated max-flow analysis.</p>
<p>Pre-computes the graph with pseudo source/target nodes for all source/target
pairs, enabling O(|excluded|) mask building per iteration.</p>
<p>Args:
    network: Network instance.
    source: Source node selector (string path or selector dict).
    target: Target node selector (string path or selector dict).
    mode: Flow analysis mode ("combine" or "pairwise").</p>
<p>Returns:
    AnalysisContext ready for use with max_flow_analysis or sensitivity_analysis.</p>
<h3 id="demand_placement_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-context-optionalanalysiscontext-none-flowiterationresult">demand_placement_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', demands_config: 'list[dict[str, Any]]', placement_rounds: 'int | str' = 'auto', include_flow_details: 'bool' = False, include_used_edges: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'<a class="headerlink" href="#demand_placement_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-demands_config-listdictstr-any-placement_rounds-int-str-auto-include_flow_details-bool-false-include_used_edges-bool-false-context-optionalanalysiscontext-none-flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Analyze traffic demand placement success rates using Core directly.</p>
<p>This function:</p>
<ol>
<li>Builds Core infrastructure (graph, algorithms, flow_graph) or uses cached</li>
<li>Expands demands into concrete (src, dst, volume) tuples</li>
<li>Places each demand using SPF caching for cacheable policies</li>
<li>Uses FlowPolicy for complex multi-flow policies</li>
<li>Aggregates results into FlowIterationResult</li>
</ol>
<p>SPF Caching Optimization:
    For cacheable policies (ECMP, WCMP, TE_WCMP_UNLIM), SPF results are
    cached by source node. This reduces SPF computations from O(demands)
    to O(unique_sources), typically a 5-10x reduction for workloads with
    many demands sharing the same sources.</p>
<p>Args:
    network: Network instance.
    excluded_nodes: Set of node names to exclude temporarily.
    excluded_links: Set of link IDs to exclude temporarily.
    demands_config: List of demand configurations (serializable dicts).
    placement_rounds: Number of placement optimization rounds (unused - Core handles internally).
    include_flow_details: When True, include cost_distribution per flow.
    include_used_edges: When True, include set of used edges per demand in entry data.
    context: Pre-built AnalysisContext for fast repeated analysis.</p>
<p>Returns:
    FlowIterationResult describing this iteration.</p>
<h3 id="max_flow_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-require_capacity-bool-true-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-context-optionalanalysiscontext-none-flowiterationresult">max_flow_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, require_capacity: 'bool' = True, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, include_flow_details: 'bool' = False, include_min_cut: 'bool' = False, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'<a class="headerlink" href="#max_flow_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-require_capacity-bool-true-flow_placement-flowplacement-include_flow_details-bool-false-include_min_cut-bool-false-context-optionalanalysiscontext-none-flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Analyze maximum flow capacity between node groups.</p>
<p>Args:
    network: Network instance.
    excluded_nodes: Set of node names to exclude temporarily.
    excluded_links: Set of link IDs to exclude temporarily.
    source: Source node selector (string path or selector dict).
    target: Target node selector (string path or selector dict).
    mode: Flow analysis mode ("combine" or "pairwise").
    shortest_path: Whether to use shortest paths only.
    require_capacity: If True (default), path selection considers available
        capacity. If False, path selection is cost-only (true IP/IGP semantics).
    flow_placement: Flow placement strategy.
    include_flow_details: Whether to collect cost distribution and similar details.
    include_min_cut: Whether to include min-cut edge list in entry data.
    context: Pre-built AnalysisContext for efficient repeated analysis.</p>
<p>Returns:
    FlowIterationResult describing this iteration.</p>
<h3 id="sensitivity_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-context-optionalanalysiscontext-none-flowiterationresult">sensitivity_analysis(network: "'Network'", excluded_nodes: 'Set[str]', excluded_links: 'Set[str]', source: 'str | dict[str, Any]', target: 'str | dict[str, Any]', mode: 'str' = 'combine', shortest_path: 'bool' = False, flow_placement: 'FlowPlacement' = <FlowPlacement.PROPORTIONAL: 1>, context: 'Optional[AnalysisContext]' = None) -&gt; 'FlowIterationResult'<a class="headerlink" href="#sensitivity_analysisnetwork-network-excluded_nodes-setstr-excluded_links-setstr-source-str-dictstr-any-target-str-dictstr-any-mode-str-combine-shortest_path-bool-false-flow_placement-flowplacement-context-optionalanalysiscontext-none-flowiterationresult" title="Permanent link">&para;</a></h3>
<p>Analyze component sensitivity to failures.</p>
<p>Identifies critical edges (saturated edges) and computes the flow reduction
caused by removing each one. Returns a FlowIterationResult where each
FlowEntry represents a source/target pair with:</p>
<ul>
<li>demand/placed = max flow value (the capacity being analyzed)</li>
<li>dropped = 0.0 (baseline analysis, no failures applied)</li>
<li>data["sensitivity"] = {link_id:direction: flow_reduction} for critical edges</li>
</ul>
<p>Args:
    network: Network instance.
    excluded_nodes: Set of node names to exclude temporarily.
    excluded_links: Set of link IDs to exclude temporarily.
    source: Source node selector (string path or selector dict).
    target: Target node selector (string path or selector dict).
    mode: Flow analysis mode ("combine" or "pairwise").
    shortest_path: If True, use single-tier shortest-path flow (IP/IGP mode).
        Reports only edges used under ECMP routing. If False (default), use
        full iterative max-flow (SDN/TE mode) and report all saturated edges.
    flow_placement: Flow placement strategy.
    context: Pre-built AnalysisContext for efficient repeated analysis.</p>
<p>Returns:
    FlowIterationResult with sensitivity data in each FlowEntry.data.</p>
<hr />
<h2 id="ngraphanalysisplacement">ngraph.analysis.placement<a class="headerlink" href="#ngraphanalysisplacement" title="Permanent link">&para;</a></h2>
<p>Core demand placement with SPF caching.</p>
<h3 id="placemententry">PlacementEntry<a class="headerlink" href="#placemententry" title="Permanent link">&para;</a></h3>
<p>Single demand placement result.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>src_name</code> (str)</li>
<li><code>dst_name</code> (str)</li>
<li><code>priority</code> (int)</li>
<li><code>volume</code> (float)</li>
<li><code>placed</code> (float)</li>
<li><code>cost_distribution</code> (dict[float, float]) = {}</li>
<li><code>used_edges</code> (set[str]) = set()</li>
</ul>
<h3 id="placementresult">PlacementResult<a class="headerlink" href="#placementresult" title="Permanent link">&para;</a></h3>
<p>Complete placement result.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>summary</code> (PlacementSummary)</li>
<li><code>entries</code> (list[PlacementEntry] | None)</li>
</ul>
<h3 id="placementsummary">PlacementSummary<a class="headerlink" href="#placementsummary" title="Permanent link">&para;</a></h3>
<p>Aggregated placement totals.</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>total_demand</code> (float)</li>
<li><code>total_placed</code> (float)</li>
</ul>
<h3 id="place_demandsdemands-sequenceexpandeddemand-volumes-sequencefloat-flow_graph-netgraph_coreflowgraph-ctx-analysiscontext-node_mask-npndarray-edge_mask-npndarray-resolved_ids-sequencetupleint-int-none-none-collect_entries-bool-false-include_cost_distribution-bool-false-include_used_edges-bool-false-placementresult">place_demands(demands: "Sequence['ExpandedDemand']", volumes: 'Sequence[float]', flow_graph: 'netgraph_core.FlowGraph', ctx: "'AnalysisContext'", node_mask: 'np.ndarray', edge_mask: 'np.ndarray', *, resolved_ids: 'Sequence[tuple[int, int]] | None' = None, collect_entries: 'bool' = False, include_cost_distribution: 'bool' = False, include_used_edges: 'bool' = False) -&gt; 'PlacementResult'<a class="headerlink" href="#place_demandsdemands-sequenceexpandeddemand-volumes-sequencefloat-flow_graph-netgraph_coreflowgraph-ctx-analysiscontext-node_mask-npndarray-edge_mask-npndarray-resolved_ids-sequencetupleint-int-none-none-collect_entries-bool-false-include_cost_distribution-bool-false-include_used_edges-bool-false-placementresult" title="Permanent link">&para;</a></h3>
<p>Place demands on a flow graph with SPF caching.</p>
<p>Args:
    demands: Expanded demands (policy_preset, priority, names).
    volumes: Demand volumes (allows scaling without modifying demands).
    flow_graph: Target FlowGraph.
    ctx: AnalysisContext with graph infrastructure.
    node_mask: Node inclusion mask.
    edge_mask: Edge inclusion mask.
    resolved_ids: Pre-resolved (src_id, dst_id) pairs. Computed if None.
    collect_entries: If True, populate result.entries.
    include_cost_distribution: Include cost distribution in entries.
    include_used_edges: Include used edges in entries.</p>
<p>Returns:
    PlacementResult with summary and optional entries.</p>
<hr />
<h2 id="ngraphlibnx">ngraph.lib.nx<a class="headerlink" href="#ngraphlibnx" title="Permanent link">&para;</a></h2>
<p>NetworkX graph conversion utilities.</p>
<p>This module provides functions to convert between NetworkX graphs and the
internal graph representation used by ngraph for high-performance algorithms.</p>
<p>Example:
    &gt;&gt;&gt; import networkx as nx
    &gt;&gt;&gt; from ngraph.lib.nx import from_networkx, to_networkx
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a NetworkX graph
    &gt;&gt;&gt; G = nx.DiGraph()
    &gt;&gt;&gt; G.add_edge("A", "B", capacity=100.0, cost=10)
    &gt;&gt;&gt; G.add_edge("B", "C", capacity=50.0, cost=5)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Convert to ngraph format for analysis
    &gt;&gt;&gt; graph, node_map, edge_map = from_networkx(G)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Use with ngraph algorithms...
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Convert back to NetworkX
    &gt;&gt;&gt; G_out = to_networkx(graph, node_map)</p>
<h3 id="edgemap">EdgeMap<a class="headerlink" href="#edgemap" title="Permanent link">&para;</a></h3>
<p>Bidirectional mapping between internal edge IDs and original edge references.</p>
<p>When converting a NetworkX graph, each edge is assigned an internal integer ID
(ext_edge_id). This class preserves the mapping for interpreting algorithm
results and updating the original graph.</p>
<p>Attributes:
    to_ref: Maps internal edge ID to original (source, target, key) tuple
    from_ref: Maps original (source, target, key) to list of internal edge IDs
        (list because bidirectional=True creates two IDs per edge)</p>
<p>Example:
    &gt;&gt;&gt; graph, node_map, edge_map = from_networkx(G)
    &gt;&gt;&gt; # After running algorithms, map flow results back to original edges
    &gt;&gt;&gt; for ext_id, flow in enumerate(flow_state.edge_flow_view()):
    ...     if flow &gt; 0:
    ...         u, v, key = edge_map.to_ref[ext_id]
    ...         G.edges[u, v, key]["flow"] = flow</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>to_ref</code> (Dict[int, NxEdgeTuple]) = {}</li>
<li><code>from_ref</code> (Dict[NxEdgeTuple, List[int]]) = {}</li>
</ul>
<h3 id="nodemap">NodeMap<a class="headerlink" href="#nodemap" title="Permanent link">&para;</a></h3>
<p>Bidirectional mapping between node names and integer indices.</p>
<p>When converting a NetworkX graph to the internal representation, node names
(which can be any hashable type) are mapped to contiguous integer indices
starting from 0. This class preserves the mapping for result interpretation
and back-conversion.</p>
<p>Attributes:
    to_index: Maps original node names to integer indices
    to_name: Maps integer indices back to original node names</p>
<p>Example:
    &gt;&gt;&gt; node_map = NodeMap.from_names(["A", "B", "C"])
    &gt;&gt;&gt; node_map.to_index["A"]
    0
    &gt;&gt;&gt; node_map.to_name[1]
    'B'</p>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>to_index</code> (Dict[Hashable, int]) = {}</li>
<li><code>to_name</code> (Dict[int, Hashable]) = {}</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>from_names(names: 'List[Hashable]') -&gt; "'NodeMap'"</code> - Create a NodeMap from a list of node names.</li>
</ul>
<h3 id="from_networkxg-nxgraph-capacity_attr-str-capacity-cost_attr-str-cost-default_capacity-float-10-default_cost-int-1-bidirectional-bool-false-tuplenetgraph_corestrictmultidigraph-nodemap-edgemap">from_networkx(G: 'NxGraph', *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost', default_capacity: 'float' = 1.0, default_cost: 'int' = 1, bidirectional: 'bool' = False) -&gt; 'Tuple[netgraph_core.StrictMultiDiGraph, NodeMap, EdgeMap]'<a class="headerlink" href="#from_networkxg-nxgraph-capacity_attr-str-capacity-cost_attr-str-cost-default_capacity-float-10-default_cost-int-1-bidirectional-bool-false-tuplenetgraph_corestrictmultidigraph-nodemap-edgemap" title="Permanent link">&para;</a></h3>
<p>Convert a NetworkX graph to ngraph's internal graph format.</p>
<p>Converts any NetworkX graph (DiGraph, MultiDiGraph, Graph, MultiGraph) to
netgraph_core.StrictMultiDiGraph. Node names are mapped to integer indices;
the returned NodeMap and EdgeMap preserve mappings for result interpretation.</p>
<p>Args:
    G: NetworkX graph (DiGraph, MultiDiGraph, Graph, or MultiGraph)
    capacity_attr: Edge attribute name for capacity (default: "capacity")
    cost_attr: Edge attribute name for cost (default: "cost")
    default_capacity: Capacity value when attribute is missing (default: 1.0)
    default_cost: Cost value when attribute is missing (default: 1)
    bidirectional: If True, add reverse edge for each edge. Useful for
        undirected connectivity analysis. (default: False)</p>
<p>Returns:
    Tuple of (graph, node_map, edge_map) where:</p>
<ul>
<li>graph: netgraph_core.StrictMultiDiGraph ready for algorithms</li>
<li>node_map: NodeMap for converting node indices back to names</li>
<li>edge_map: EdgeMap for converting edge IDs back to (u, v, key) refs</li>
</ul>
<p>Raises:
    TypeError: If G is not a NetworkX graph
    ValueError: If graph has no nodes</p>
<p>Example:
    &gt;&gt;&gt; import networkx as nx
    &gt;&gt;&gt; G = nx.DiGraph()
    &gt;&gt;&gt; G.add_edge("src", "dst", capacity=100.0, cost=10)
    &gt;&gt;&gt; graph, node_map, edge_map = from_networkx(G)
    &gt;&gt;&gt; graph.num_nodes()
    2
    &gt;&gt;&gt; node_map.to_index["src"]
    0
    &gt;&gt;&gt; edge_map.to_ref[0]  # First edge
    ('dst', 'src', 0)  # sorted node order: dst &lt; src</p>
<h3 id="to_networkxgraph-netgraph_corestrictmultidigraph-node_map-optionalnodemap-none-capacity_attr-str-capacity-cost_attr-str-cost-nxmultidigraph">to_networkx(graph: 'netgraph_core.StrictMultiDiGraph', node_map: 'Optional[NodeMap]' = None, *, capacity_attr: 'str' = 'capacity', cost_attr: 'str' = 'cost') -&gt; "'nx.MultiDiGraph'"<a class="headerlink" href="#to_networkxgraph-netgraph_corestrictmultidigraph-node_map-optionalnodemap-none-capacity_attr-str-capacity-cost_attr-str-cost-nxmultidigraph" title="Permanent link">&para;</a></h3>
<p>Convert ngraph's internal graph format back to NetworkX MultiDiGraph.</p>
<p>Reconstructs a NetworkX graph from the internal representation. If a
NodeMap is provided, original node names are restored; otherwise, nodes
are labeled with integer indices.</p>
<p>Args:
    graph: netgraph_core.StrictMultiDiGraph to convert
    node_map: Optional NodeMap to restore original node names.
        If None, nodes are labeled 0, 1, 2, ...
    capacity_attr: Edge attribute name for capacity (default: "capacity")
    cost_attr: Edge attribute name for cost (default: "cost")</p>
<p>Returns:
    nx.MultiDiGraph with edges and attributes from the internal graph</p>
<p>Example:
    &gt;&gt;&gt; graph, node_map, edge_map = from_networkx(G)
    &gt;&gt;&gt; # ... run algorithms ...
    &gt;&gt;&gt; G_out = to_networkx(graph, node_map)
    &gt;&gt;&gt; list(G_out.nodes())
    ['A', 'B', 'C']</p>
<hr />
<h2 id="error-handling">Error Handling<a class="headerlink" href="#error-handling" title="Permanent link">&para;</a></h2>
<p>NetGraph uses standard Python exceptions:</p>
<ul>
<li><code>ValueError</code> - For validation errors</li>
<li><code>KeyError</code> - For missing required fields</li>
<li><code>RuntimeError</code> - For runtime errors</li>
</ul>
<p>For complete method signatures and detailed documentation, use Python's help system:</p>
<div class="language-python highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="n">help</span><span class="p">(</span><span class="n">ngraph</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">Scenario</span><span class="p">)</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="n">help</span><span class="p">(</span><span class="n">ngraph</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">Network</span><span class="o">.</span><span class="n">max_flow</span><span class="p">)</span>
</span></code></pre></div>
<hr />
<p><em>This documentation was auto-generated from the NetGraph source code.</em></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.sections", "navigation.tabs", "navigation.top", "content.code.copy"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>